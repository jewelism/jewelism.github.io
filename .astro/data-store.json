[["Map",1,2,9,10],"meta::meta",["Map",3,4,5,6,7,8],"astro-version","5.14.8","content-config-digest","aa3455847d3568fa","astro-config-digest","{\"root\":{},\"srcDir\":{},\"publicDir\":{},\"outDir\":{},\"cacheDir\":{},\"site\":\"https://jewelism.github.io/\",\"compressHTML\":true,\"base\":\"/\",\"trailingSlash\":\"ignore\",\"output\":\"static\",\"scopedStyleStrategy\":\"where\",\"build\":{\"format\":\"directory\",\"client\":{},\"server\":{},\"assets\":\"_astro\",\"serverEntry\":\"entry.mjs\",\"redirects\":true,\"inlineStylesheets\":\"auto\",\"concurrency\":1},\"server\":{\"open\":false,\"host\":false,\"port\":4321,\"streaming\":true,\"allowedHosts\":[]},\"redirects\":{},\"image\":{\"endpoint\":{\"route\":\"/_image\"},\"service\":{\"entrypoint\":\"astro/assets/services/sharp\",\"config\":{}},\"domains\":[],\"remotePatterns\":[],\"responsiveStyles\":false},\"devToolbar\":{\"enabled\":true},\"markdown\":{\"syntaxHighlight\":false,\"shikiConfig\":{\"langs\":[],\"langAlias\":{},\"theme\":\"github-dark\",\"themes\":{},\"wrap\":false,\"transformers\":[]},\"remarkPlugins\":[null,null,null],\"rehypePlugins\":[null,[null,{\"experimentalHeadingIdCompat\":false}],null,[null,{\"themes\":[\"vitesse-dark\",\"vitesse-light\"],\"defaultLocale\":\"en\",\"cascadeLayer\":\"starlight.components\",\"styleOverrides\":{\"borderRadius\":\"0.5rem\",\"borderWidth\":\"1px\",\"codePaddingBlock\":\"0.75rem\",\"codePaddingInline\":\"1rem\",\"codeFontFamily\":\"var(--__sl-font-mono)\",\"codeFontSize\":\"var(--sl-text-code)\",\"codeLineHeight\":\"var(--sl-line-height)\",\"uiFontFamily\":\"var(--__sl-font)\",\"textMarkers\":{\"lineDiffIndicatorMarginLeft\":\"0.25rem\",\"defaultChroma\":\"45\",\"backgroundOpacity\":\"40%\",\"markBackground\":\"var(--sl-rapide-ec-marker-bg-color)\",\"markBorderColor\":\"var(--sl-rapide-ec-marker-border-color)\"},\"borderColor\":\"var(--sl-rapide-ui-border-color)\",\"frames\":{\"editorActiveTabIndicatorTopColor\":\"unset\",\"editorActiveTabIndicatorBottomColor\":\"var(--sl-color-gray-3)\",\"editorTabBarBorderBottomColor\":\"var(--sl-rapide-ui-border-color)\",\"frameBoxShadowCssValue\":\"unset\"}},\"plugins\":[{\"name\":\"Starlight Plugin\",\"hooks\":{}},{\"name\":\"astro-expressive-code\",\"hooks\":{}}]}]],\"remarkRehype\":{},\"gfm\":true,\"smartypants\":true},\"security\":{\"checkOrigin\":true,\"allowedDomains\":[]},\"env\":{\"schema\":{},\"validateSecrets\":false},\"experimental\":{\"clientPrerender\":false,\"contentIntellisense\":false,\"headingIdCompat\":false,\"preserveScriptOrder\":false,\"liveContentCollections\":false,\"csp\":false,\"staticImportMetaEnv\":false,\"chromeDevtoolsWorkspace\":false,\"failOnPrerenderConflict\":false},\"legacy\":{\"collections\":false},\"prefetch\":{\"prefetchAll\":true},\"i18n\":{\"defaultLocale\":\"en\",\"locales\":[\"en\"],\"routing\":{\"prefixDefaultLocale\":false,\"redirectToDefaultLocale\":false,\"fallbackType\":\"redirect\"}}}","docs",["Map",11,12,24,25,34,35,44,45,54,55,64,65,74,75,84,85,94,95,104,105,114,115,124,125,134,135,144,145,154,155,164,165,174,175,184,185,194,195,204,205,214,215,224,225,234,235,244,245,254,255,264,265,274,275,284,285,294,295,304,305,314,315,324,325,334,335,344,345,354,355,364,365,374,375,384,385,394,395,404,405,414,415,424,425,434,435,444,445,454,455,464,465,474,475,484,485,494,495,504,505,514,515,524,525,534,535,544,545,554,555,564,565,574,575,584,585,594,595,604,605,614,615,624,625,634,635,644,645,654,655,664,665,674,675,684,685,694,695,704,705,714,715,724,725,734,735,744,745,754,755,764,765,774,775,784,785,794,795,804,805,814,815,824,825,834,835,844,845,854,855,864,865,874,875,884,885,894,895,933,934,964,965,985,986,995,996,1005,1006,1015,1016,1025,1026,1035,1036,1045,1046,1055,1056,1065,1066,1075,1076,1085,1086,1095,1096],"about",{"id":11,"data":13,"body":21,"filePath":22,"digest":23,"deferredRender":15},{"title":14,"editUrl":15,"head":16,"template":17,"sidebar":18,"pagefind":15,"draft":19},"About",true,[],"doc",{"hidden":19,"attrs":20},false,{},"## 정보석\n\n## Frontend Developer\n\n강점을 최대한 살려 효율적인 성과를 내는 데 집중합니다.\n\n솔직하고 능동적인 커뮤니케이션을 통해 협업의 시너지를 만드는 것을 중요하게 생각합니다.\n\n글로벌 환경에서의 협업을 위해 영어 실력을 지속적으로 향상시키고 있습니다.\n\n책임감이 보장된 자율적인 환경에서 높은 몰입도로 일합니다.\n\n비용과 효율을 함께 고려한 합리적인 엔지니어링을 지향합니다.\n\n제한된 일정 속에서도 품질과 생산성의 균형을 중시합니다.\n\n완벽한 코드보다 비즈니스 목표에 맞는 현실적인 엔지니어링을 추구합니다.\n\n## Contact\n\n- [LinkedIn](https://www.linkedin.com/in/%EB%B3%B4%EC%84%9D-%EC%A0%95-9b7b49172/)\n- [boseokjung@gmail.com](mailto:boseokjung@gmail.com)\n- [https://github.com/jewelism](https://github.com/jewelism)\n\n## Career\n\n### 휴식중 (2023.05 ~ )\n- 낭만 가득한 인디게임 개발 중\n- Godot4\n\n### \u003Cb>카카오스타일\u003C/b>\n\n- 기간: 2022.09.13 ~ 2023.05.12\n- 소속: 커머스플랫폼FE(주문, 결제) / 사원\n\n#### 기존 서비스&기능 개선 및 버그 수정\n- 결제수단 저장안되는 버그 수정\n- 결제수단 미노출 버그 수정\n- 결제 실패시 주문서로 재이동하는 로직 개선(기존 history.back)\n- 간헐적 백화현상 원인 파악 및 수정\n- 스토리북 추가를 위한 컴포넌트 리팩토링&개선\n- 파트너센터 판매채널 hover 툴팁 추가\n\n#### 지그재그 - 기본배송지 개선\n- react, ts, hook API\n- 기본배송지 미설정으로 인해 결제시 사용자이탈 가능성이 있음\n- 기본배송지 미설정시 기본배송지 설정페이지로 자연스럽게 이동시켜 사용자가 기본배송지를 설정하도록 유도\n\n#### 지그재그 - 한국 편의점 결제\n- react, ts, hook API\n- 12자리 수납번호로 클라이언트에서 바코드를 생성하여 결제하는 기능\n- 결제가 어려운 10대들을 위한 결제수단 추가\n#### 지그재그 - 일본 편의점 결제 non-ui 전환\n\n- react, ts, hook API\n- 글로벌 일본 편의점 결제 편의성 개선\n  - 타 서비스(엑심베이)로 이동하여 휴대폰번호와 이메일 주소를 유저가 직접 입력해야했는데, 페이지 이동 없이 사용자 정보를 가져와 input field에 자동으로 입력\n  - 결제시 사용자 불편함을 개선하여 결제유도\n\n#### 지그재그 파트너센터 - 멀티스토어 정산 통합 관리\n- react, ts, hook API\n- 부모 스토어에서 정산을 통합으로 관리하는 기능 추가\n#### 지그재그 백오피스 - 멤버십 쿠폰팩\n\n - react, ts, hook API\n - 지그재그 멤버십 혜택으로 멤버십 쿠폰팩을 발급 & 관리하는 기능 추가\n   - 기존 쿠폰팩 생성에 멤버십 타입 추가\n   - 멤버십 쿠폰팩을 조회하고 수정 & 삭제하는 관리페이지 추가\n   - 백오피스 최초의(ㅎㅎ) FE 테스트코드 추가\n\n### \u003Cb>[SK11번가](https://www.11st.co.kr/)\u003C/b>\n\n- 기간: 2019.11.25 ~ 2022.09.06\n- 소속: FE개발2팀 / 사원\n\n#### PC 개편\n\n- Preact, Typescript, hook API, context API\n- 검색창 (예약 키워드 검색 포워딩, 검색창 텍스트 광고)\n- 실시간 쇼핑 검색어 (애니메이션, 레이어)\n- GNB, main 공통 모듈\n\n{/* \u003Cimg src=\"/images/search_bar.png\" width=\"70%\" alt=\"search bar\" />\n\u003Cimg src=\"/images/search_layer.png\" width=\"70%\" alt=\"search layer\" /> */}\n\n#### 아마존 상품상세 모바일 페이지\n\n- Preact, Typescript, hook API, context API\n- 모바일 앱 일부분(각종 팝업과 상품설명, Q&A, 판매자정보)을 웹뷰로 구현\n- 컴포넌트를 독립적으로 또 다른 window로 띄울 수 있도록 설계 - 팝업, 웹뷰로 활용\n- 웹뷰를 호출할 때 필요없는 API는 호출하지 않도록 설계\n- 옵션 변경시 변경된 상품번호로 API만 재호출하여 페이지 일부분만 갱신\n- 처음 도입하는 FE test code - ui는 테스트하지않고, 비즈니스 로직만 테스트\n\n{/* \u003Cimg src=\"/images/acme-pdp-mw.png\" width=\"70%\" alt=\"amazon pdp mobile\" /> */}\n\n### (주)인데이터랩\n\n- 기간: 2018.10.01 ~ 2019.10.11\n- 직급: 임원\n- 역할: 기획, FE 리딩, BE 개발\n- 기술: Vue, React, node.js, aws ec2, s3, dynamoDB, next.js\n\n#### MOQA 관리자 페이지\n\n- Vue\n- 리워드 설문 작성 기능\n- 작성한 설문 미리보기 & 테스트, 공유 기능\n- 회원관리, 공지사항 등의 게시판\n- 대시보드와 차트\n\n#### MOQA 앱 튜토리얼\n\n- React\n- MOQA앱의 튜토리얼 웹뷰 구현\n- 객관식 선택과 애니메이션 구현\n\n{/* \u003Cimg src=\"/images/moqa.png\" width=\"70%\" alt=\"moqa\" />\n\u003Cimg src=\"/images/moqa2.png\" width=\"70%\" alt=\"moqa2\" /> */}\n\n~~폐업으로 인한 강제 이직~~\n\n{/* ### 스마일게이트 스토브\n\n- 소속: 인턴 - 웹개발실 웹프론트개발팀\n- 기간: 2018.05.02 ~ 2018.07.21\n- 기술: vue.js\n\n기능구현 - ~~지금은 사라진~~ onstove.com의 타임라인을 개편\n\n1. 마이홈 프로젝트의 메인화면\n2. 단문형 리스트 */}\n\n## Tech\n\n### React, Vue\n\n- SPA 뿐만 아니라 프로젝트 일부분에 점진적으로 도입해본 경험이 있습니다.\n- 함수형 컴포넌트로 개발하는것을 좋아하며,\ncustom hook으로 공통 비즈니스 로직을 모듈화할 수 있습니다.\n- ssr에 대해 잘 이해하고 있습니다.\n\n### Typescript\n\n- React + ts 실무 개발 경험이 있습니다. (11st~)\n\n### Jest\n\n- unit test, react hook test, component test, snapshot test 경험이 있습니다.\n\n### Node\n\n- 프론트엔드뿐만 아니라 백엔드 어플리케이션을 개발 경험이 있습니다. (express)\n\n### DevOps\n\n- gcp, aws (ec2, s3, dynamoDB, NLB 등등..) 경험이 있습니다.\n- 프론트 어플리케이션 배포를 위한 nginx, pm2 경험이 있습니다.\n- 서버 (on-premise and public cloud) 구성부터 애플리케이션 배포까지 경험이 있습니다.\n\n~~### react-native~~\n\n~~- 하고 싶진 않지만 react-native 개발 경험 있습니다. (안드로이드 배포까지)~~\n\n~~### project cooperation tools~~\n\n~~- 협업을 위한 git, jira, wiki, slack, discord 등 툴 활용~~\n\n\n\n## Open Source Contribute\n\n아직 오픈소스 기여 경험이라고 소개하긴 조금 민망한 수준이지만 ^^;;\n\n- [rxjs 문서 오탈자 수정](https://github.com/ReactiveX/reactivex.github.io/pull/377)\n- [vue.js 공식문서 번역 참여](https://github.com/vuejs-kr/kr.vuejs.org/pull/138)\n\n## RESUME PDF Link\n\n- [RESUME.pdf](https://jewelism.github.io/doc/RESUME.pdf)\n\n### 재미로 더 알아보실래요?\n\n- [나의 특성 5개 - Gallup Top 5 CliftonStrengths](../secret/gallup_top5/)","src/content/docs/about.mdx","16337c0094f957ad","index",{"id":24,"data":26,"body":31,"filePath":32,"digest":33,"deferredRender":15},{"title":27,"editUrl":15,"head":28,"template":17,"sidebar":29,"pagefind":15,"draft":19},"쥬얼리 개발 블로그",[],{"hidden":19,"attrs":30},{},"##### ~~내가 다시 보려고 만든 블로그~~\n\n##### 최근엔 Godot4를 이용한 게임개발을 하고있습니다.\n\nfe개발자입니다. js에 관련된 내용들이 대부분입니다.\n\n환경은 대부분이 Mac 기반입니다. ~~서버 설정 or linux의 경우 ubuntu 18 LTS 기준입니다.~~\n\n~~존댓말과 반말이 섞여있습니다.~~\n\n~~반말이 불편하시면 뒤로가기하세요!~~\n\n틀린 부분이나 오타 등의 지적을 알려주세요!\n\n댓글, 혹은 깃헙 이슈나 이메일 등 아무거나 다 좋습니다!!\n\n---","src/content/docs/index.mdx","b338e62e5387966e","browser/cache",{"id":34,"data":36,"body":41,"filePath":42,"digest":43,"deferredRender":15},{"title":37,"editUrl":15,"head":38,"template":17,"sidebar":39,"pagefind":15,"draft":19},"브라우저 캐시",[],{"hidden":19,"attrs":40},{},"당연히 크롬 기준..\n\n```\nCaching\nChrome employs two caches — an on-disk cache and a very fast in-memory cache.\nThe lifetime of an in-memory cache is attached to the lifetime of a render process,\nwhich roughly corresponds to a tab. \nRequests that are answered from the in-memory cache are invisible to the web request API. \nIf a request handler changes its behavior (for example, the behavior according to which requests are blocked),\na simple page refresh might not respect this changed behavior. \nTo make sure the behavior change goes through, \ncall handlerBehaviorChanged() to flush the in-memory cache. \nBut don't do it often; flushing the cache is a very expensive operation. \nYou don't need to call handlerBehaviorChanged() after registering or unregistering an event listener.\n```\n\n구글 번역의 도움을 받으면..\n\n```\n캐싱\nChrome은 온 디스크 캐시와 매우 빠른 인 메모리 캐시라는 두 가지 캐시를 사용합니다.\n인 메모리 캐시의 수명은 렌더링 프로세스의 수명에 연결되며 이는 대략 탭에 해당합니다.\n인 메모리 캐시에서 응답 한 요청은 웹 요청 API에 표시되지 않습니다.\n요청 처리기가 동작을 변경하면 (예: 요청이 차단 된 동작)\n간단한 페이지 새로 고침으로 인해 변경된 동작을 고려하지 않을 수 있습니다.\n동작 변경을 확인하려면 handlerBehaviorChanged ()를 호출하여 메모리 내 캐시를 플러시하십시오.\n그러나 자주하지 마십시오.\n캐시 플러시는 비용이 많이 드는 작업입니다.\n이벤트 리스너를 등록 또는 등록 해제 한 후\nhandlerBehaviorChanged()를 호출 할 필요가 없습니다.\n```\n\n[handlerBehaviorChanged 참고자료](https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/webRequest/handlerBehaviorChanged)","src/content/docs/browser/cache.mdx","9023c0a9aa54a721","browser/chromium-bug",{"id":44,"data":46,"body":51,"filePath":52,"digest":53,"deferredRender":15},{"title":47,"editUrl":15,"head":48,"template":17,"sidebar":49,"pagefind":15,"draft":19},"Chromium 기반 브라우저 버그",[],{"hidden":19,"attrs":50},{},"## 크로미움 기반 브라우저(크롬, 오페라) 버그!\n\n최근 사이드 프로젝트를 하면서 nestjs를 써보고 싶어서, ios개발하는 친구와 채팅을 만들어보기로했다.\n\n서버개발 속도가 좀 빨라서 react+ts로 스타일코드는 1개도 없이 기능만 구현해봤다.\n\n채팅은 문자를 입력하고 엔터를 누르는게 기본 기능인데, 그것을 구현하다가 발견한 버그이다. \n\nreact에서 키보드입력을 감지하는 이벤트 => onKeyPress \n\n맥에서는 한글입력하면 제일 마지막글자가 블럭쌓인것처럼 검은 밑줄?같은게 쳐지는데,\n\n이상태에서 엔터를 눌러서 onKeyPress 에 바인딩된 함수를 호출하면\n\n해당 마지막글자가, 한번 더 전달된다.\n\n예를들어, 'ㅁㄴㅇㄹ'을 쓰고 엔터를 누르면 [ㅁㄴㅇㄹ, ㄹ] 이렇게 전송된다.\n\n띠용???????\n\n그런데 onkeydown을 쓰면 문제없다. 근데 deprecated 됐다. \n\n결국 저런 경우 때문에라도, onkeypress를 쓰되, setTimeout같은걸로 연속입력을 빠르게 못하도록 컨트롤하는 방법을 써야함. 뭐 어차피 해야하는 작업이었지만..","src/content/docs/browser/chromium-bug.mdx","681ca23f70fcf361","browser/chrome",{"id":54,"data":56,"body":61,"filePath":62,"digest":63,"deferredRender":15},{"title":57,"editUrl":15,"head":58,"template":17,"sidebar":59,"pagefind":15,"draft":19},"Chrome 브라우저",[],{"hidden":19,"attrs":60},{},"크롬 브라우저는 구글에서 개발한 크로미움기반 브라우저이다.\n\njavascript 엔진으로 v8을 사용하고 있다.\n\n레이아웃 엔진으로는 블링크(웹킷기반)를 사용하고 있다.\n\n크롬은 멀티프로세스 아키텍쳐이다.\n\n각 크롬 프로세스는 몇 개의 스레드로 구성된 스레드풀이 있다.\n\n대표적으로 main thread(UI thread), IO thread(handling IPC)로 구분된다.\n\n그래서 기본적으로 내부적인 멀티스레드다.\n\n비동기처리를 위한 태스크큐(혹은 이벤트큐)가 구현되어있다.\n\n-----------------------\n\nthread간 shared resource의 synchronize access를 위해서는 Lock이라는 방법도 있지만\n\nSequencedTaskRunner를 사용한 sequences to locks이 강력하게 권장된다.\n\n-----------\n\n레퍼런스: https://chromium.googlesource.com/chromium/src/+/master/docs/threading_and_tasks.md","src/content/docs/browser/chrome.mdx","df58a344e7af128a","browser/cookie",{"id":64,"data":66,"body":71,"filePath":72,"digest":73,"deferredRender":15},{"title":67,"editUrl":15,"head":68,"template":17,"sidebar":69,"pagefind":15,"draft":19},"Cookie",[],{"hidden":19,"attrs":70},{},"HTTP는 stateless하다. 이 말은 상태를 유지않는다는건데\n\n예를 들면 사용자정보 같은게 있다.\n\nHTTP통신을 하는 웹페이지는 상태가없으므로 사용자정보를 갖고있지않은데,\n\n매 http 커넥션마다 로그인을 해야한다는건 말이 안된다.\n\n이러한 것을 보안하기위해 Cookie라는게 등장했다. [사실 여기서 Session도 등장한다.](/browser/session)\n\n---\n\n쿠키라는것은 클라이언트단에 저장되는 key-value 저장소이다. (4KB)\n\n쿠키에는 key, value, 만료시간 등의 정보가 포함된다.\n\n기본적으로 서버와 통신할때 쿠키정보를 주고 받는다.\n\n단, ES6의 fetch에는 cookie를 주고받는게 기본적으로 false이다.","src/content/docs/browser/cookie.mdx","52a3070d43c54ebc","browser/cross-browsing",{"id":74,"data":76,"body":81,"filePath":82,"digest":83,"deferredRender":15},{"title":77,"editUrl":15,"head":78,"template":17,"sidebar":79,"pagefind":15,"draft":19},"크로스 브라우징 이슈",[],{"hidden":19,"attrs":80},{},"여러 브라우저에서 같은 시각적 표현과 기능을 제공해야함을 뜻한다.\n\n브라우저마다 자바스크립트의 버전이 다를 수 있고, html, css도 마찬가지다.\n\n모던웹은 IE9이상을 지원하는게 일반적이다.\n\n마크업 개발자 하는 친구가 reset.css를 작성하는 것을 봤는데,\n\n이게 왜 하는지 궁금해서 검색해봤더니,\n\n브라우저마다 같은 태그도 렌더링하고나면 생김새가 조금씩 다르다.\n\n이것을 초기화해서 같게 만들어주는 것이라고 한다.\n\nreset.css보단 https://necolas.github.io/normalize.css 가 선호된다.\n\nreset과는 다르게 무조건 덮어쓰기하는게 아니라, 다른 부분만 변경해준다. npm패키지로 쓸수있는건 덤.\n\npolyfill이라는 개념도 있다.\n\n하위브라우저에서도 최신스펙을 사용할 수 있게 해준다. ex) ES6 Map, Set\n\n폴리필이 불가능한 기능도 있다. 예를 들어 ES6의 Proxy\n\n크로스브라우징을 위해 ES6+ 문법을 es5문법으로 변환시켜주는 일을 하기도 하는데,\n\n그것은 [babel](/fe/webpack-babel#babel)이라는 트랜스파일러가 해준다.\n\n아래는 뷰 슬랙방에서 슬쩍한 이미지이다.\n\nie checker라고 한다..ㅋㅋ\n\n이런식으로 ie의 버전을 확인한다고 한다.\n\n\u003Cimg src=\"/images/ieChecker.png\" />\n\n# 크로스 브라우징 이슈들\n\n## 스크립트 동적로드시 인코딩 이슈\n\n캐싱된 js가 인코딩이 깨지는 경우가 있다.\n\n예를 들어, 다른페이지를 갔다가 뒤로가기로 되돌아오는경우 script는 캐싱된다.\n\n그런데 이때 IE, 레거시엣지에서 인코딩이 깨진다. (레거시 엣지는 첨부터 깨진다.)\n\n스크립트로드 뒤에 sessionStorage를 이용해 version처럼 쿼리스트링을 붙여서 캐싱을 해제시켜도 레거시엣지에서는 여전히 해결되지않는다.\n\nscript를 동적으로 로드시, src를 지정하기 전에 charset을 먼저 지정해주어야 캐싱이 된 js에서도 정상작동한다고 한다.\n\n```js\nconst script = document.createElement(\"script\");\nscript.charset = charset;\nscript.src = url;\n```\n\n순서가 중요하다. 무조건 charset을 먼저 세팅해야한다.\n\n그래야 모든 브라우저에서 인코딩 이슈가 안 생긴다.\n\n## 모바일 삼성브라우저 디버깅\n\nhttps://hub.samsunginter.net/docs/remote-debugging/","src/content/docs/browser/cross-browsing.mdx","f668a4d366f45601","browser/doctype",{"id":84,"data":86,"body":91,"filePath":92,"digest":93,"deferredRender":15},{"title":87,"editUrl":15,"head":88,"template":17,"sidebar":89,"pagefind":15,"draft":19},"DOCTYPE",[],{"hidden":19,"attrs":90},{},"[웹표준](/browser/web-standard)에 대한 내용의 일부이다.\n\n요즘 개발된 웹페이지 상단을 보면\n\n```html\n\u003C!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">\n```\n\n이런 태그를 본적있을 것이다.\n\n저 태그를 DTD(document type definition)라고 한다.\n\n태그를 삽입하지않아도 페이지가 작동하지만 중요한 이유가 있다.\n\n기본적으로는 문서 형식 선언을 이용해서 어떤 웹 페이지가 모든 웹 브라우저에서 같은 레이아웃으로 제공되도록 할 수 있다.\n\n### 표준모드(standards mode)와 쿽스모드(quirks mode)\n\n브라우저는 선언된 doctype에 따라 렌더링할 모드를 선택하게 되는데 이 과정을 doctype sniffing 또는 doctype switching이라고 한다.\n\nDOCTYPE 선언 내의 URL이 생략된 경우, 브라우저는 document를 quirks mode로 해석한다.\n\n위에서 말했던것처럼, 표준모드라는 것은 모든 웹 브라우저에서 같은 레이아웃으로 제공될수있도록 함이다.\n\nDTD을 제대로 선언하지않으면, quirks mode로 렌더링하는데 브라우저마다 레이아웃이 달라질 수 있다.\n\nSEO에도 중요하다. 웹사이트의 점수가 낮으면, 나의 웹사이트 순위는 점점 내려간다.","src/content/docs/browser/doctype.mdx","bf2a582d03ba81a6","browser/dom",{"id":94,"data":96,"body":101,"filePath":102,"digest":103,"deferredRender":15},{"title":97,"editUrl":15,"head":98,"template":17,"sidebar":99,"pagefind":15,"draft":19},"DOM",[],{"hidden":19,"attrs":100},{},"DOM은 HTML과 XML의 인터페이스다.\n\n웹 페이지를 스크립트 또는 프로그래밍 언어들에서 사용될 수 있게 연결시켜주는 역할을 담당\n\n웹 페이지는 일종의 문서같은 것인데,\n\n웹 브라우저는 그 문서를 해석하여 화면에 그려준다.\n\nW3C DOM는 대부분의 브라우저에서 DOM을 구현하는 기준이다. [\\(웹표준\\)](/browser/web-standard)\n\n많은 브라우저들이 표준 규약에서 제공하는 기능 외에도 추가적인 기능들을 제공하기 때문에\n\n사용자가 작성한 문서들이 각기 다른 DOM 이 적용된 다양한 브라우저 환경에서 동작할 수 있다는 사실을 항상 인지하고 있어야 한다.\n\n## 오해할 수 있는 부분\n\nDOM과 자바스크립트는 별개다.\n\n초창기에는 밀접한 관련이 있지만,\n\n요즘은 js의 많은 발전으로\\(node.js등과 같은 서버사이드 스크립트\\) 독립되었다.\n\n페이지 컨텐츠는 DOM으로 표현되고, 자바스크립트를 통해 접근하거나 조작할 수 있다.\n\n웹페이지 = DOM + js\n\nreference: https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction","src/content/docs/browser/dom.mdx","d5c7fd4526f8e25f","browser/element-text",{"id":104,"data":106,"body":111,"filePath":112,"digest":113,"deferredRender":15},{"title":107,"editUrl":15,"head":108,"template":17,"sidebar":109,"pagefind":15,"draft":19},"element에서 text추출",[],{"hidden":19,"attrs":110},{},"# HTML Element get Text\n\n어떤 웹사이트의 테이블에서 데이터를 크롤링하다가 공부하게 됐다.\n\nHTML Element에서 text를 가져오려면 innerText 프로퍼티를 사용하면되는데,\n\nundefined가 뜨는경우가 간혹있더라. 텍스트노드가 또다른 노드안에 있다던지.\n\n그것을 해결하는것이 아래 코드이다.\n\n```javascript\nconst text = el['innerText' in el ? 'innerText' : 'textContent'];\n```\n\n이렇게 텍스트를 가져오게되면, 편하다.","src/content/docs/browser/element-text.mdx","c31f86b0b70ca1a0","browser/element",{"id":114,"data":116,"body":121,"filePath":122,"digest":123,"deferredRender":15},{"title":117,"editUrl":15,"head":118,"template":17,"sidebar":119,"pagefind":15,"draft":19},"Element, Node, EventTarget",[],{"hidden":19,"attrs":120},{},"```\nEventTarget \u003C= Node \u003C= Element\n```\n\n위 문장(?)은 EventTarget는 Node의 부모인터페이스이고, Node는 Element의 부모인터페이스임을 나타낸다.\n\n### Element\n\nElement는 Document안의 모든 객체가 상속하는 제일 범용적인 기반 클래스이다.\n\n공통적인 프로퍼티(메소드)들이 있다.\n\n### Node\n\nNode는 다양한 DOM 타입들이 상속하는 인터페이스이다.\n\n대표적으로 Document, Element, CharacterData(문자를 포함하는 Node객체 - Text, Comment(주석)) 등이 있다.\n\n### EventTarget\n\nEventTarget은 이벤트를 받고 해당 listener를 가질 수 있는 객체에 의해 구현된 인터페이스이다.\n\nElement, document 및 window는 가장 흔한 이벤트 대상(target)이지만,\n\n예를 들어 XMLHttpRequest, AudioNode, AudioContext 및 나머지 다른 객체들도 이벤트 대상이 될 수 있습니다.\n\nmethods\n\n```js\nEventTarget.addEventListener()\n// EventTarget에 특정 이벤트 유형의 이벤트 처리기를 등록.\nEventTarget.removeEventListener()\n// EventTarget에서 이벤트 수신기를 제거.\nEventTarget.dispatchEvent()\n// 이 EventTarget에 이벤트를 디스패치.\n```\n\nref: https://developer.mozilla.org/ko/docs/Web/API/EventTarget","src/content/docs/browser/element.mdx","e4e69404ba0beb1f","browser/event",{"id":124,"data":126,"body":131,"filePath":132,"digest":133,"deferredRender":15},{"title":127,"editUrl":15,"head":128,"template":17,"sidebar":129,"pagefind":15,"draft":19},"Event",[],{"hidden":19,"attrs":130},{},"이벤트는 사용자 행위나 비동기적 작업의 진행을 나타내기 위해 API가 생성할 수도 있습니다.\n\n'click' 이벤트를 발생시키기 위해서는 사용자가 버튼을 클릭한다던지, HTMLElement.click() 을 이용한다던지,\n\n이벤트를 정의한 후 EventTarget.dispatchEvent()를 이용하여 프로그래밍으로 만들어낼수도 있습니다.\n\n부모 엘리먼트와 자식 엘리먼트의 위치가 겹쳐있을때 이벤트는 양쪽 모두에서 일어나는데, 이벤트 처리 순서는\n\n이벤트 확산, 캡쳐의 설정에 따라 달라집니다.\n\n## 이벤트 버블링 (Event Bubbling)\n\n이벤트가 발생됐을때 그 이벤트가 상위 엘리먼트로 퍼져나가는 현상을 말합니다.\n\n이벤트는 기본적으로 버블링됩니다.\n\ndiv내부에 button이 있고, button을 클릭하면 button의 click이벤트가 발생하고,\n\ndiv 또한 click이벤트가 발생합니다. div의 click을 막고싶다면 아래에서 설명할\n\nstopPropagation을 사용하세요\n\n## 이벤트 캡쳐 (Event Capture)\n\n이벤트 캡쳐는 이벤트 버블링의 반대방향으로 퍼져나가는 것을 뜻합니다.\n\n## 이벤트 위임 (Event Delegation)\n\n이벤트 위임은 단순히 상위 엘리먼트에 이벤트를 붙인걸 의미합니다.\n\n```html\n\u003Ctbody>\n  \u003Ctr>\n    \u003Ctd>\u003C/td>\n    \u003Ctd>\u003C/td>\n    \u003Ctd>\u003C/td>\n  \u003C/tr>\n\u003C/tbody>\n```\n\ntd를 클릭했을때의 이벤트를 등록할때 td에 등록하지않고, tr이나 tbody에 이벤트를 붙이고 활용하는것을\n\n단순히 이벤트 위임이라고 표현합니다.\n\n상위에서 이벤트를 감지하면, 하위 요소들이 바뀌는것에 조금 더 유연한 설계를 할 수 있죠.\n\n대신 상황에 따라 분기처리가 필요합니다.\n\n=> 의도한 EventTarget이 맞는지, 자식 요소가 있다면 자식요소를 포함하고 있는지 contains로 검사\n\n## 이벤트 등록, 삭제\n\n이벤트리스너는 등록하고 사용후 적절한 타이밍에 삭제해줘야합니다 => 메모리릭\n\n```js\nEventTarget.addEventListener(type, listener, useCapture);\nEventTarget.removeEventListener(type, listener, useCapture);\n```\n\n3가지 파라미터의 레퍼런스가 일치해야 삭제에 성공합니다.\n\nuseCapture는 버블링 대신 캡쳐를 선택할 수 있습니다.\n\n### 이벤트의 주요 프로퍼티\n\n```js\nEvent.target // 이벤트가 처음에 발생했던 대상의 참조입니다.\nEvent.stopPropagation() // 이벤트의 DOM 내 추가 확산을 방지합니다.\nEvent.preventDefault() // 취소 가능한 경우 이벤트를 취소합니다.\n```","src/content/docs/browser/event.mdx","c1b13c2abb56bd1c","browser/fetch",{"id":134,"data":136,"body":141,"filePath":142,"digest":143,"deferredRender":15},{"title":137,"editUrl":15,"head":138,"template":17,"sidebar":139,"pagefind":15,"draft":19},"Fetch API",[],{"hidden":19,"attrs":140},{},"[Promise](/js/promise) 기반의 사용하기편한 XHR\\(XmlHttpRequest\\)이라고 생각하면 됩니다.\n\n하지만 기본적으로 fetch는 쿠키를 보내거나 받지 않습니다. (option.credential)\n\n또한 에러코드를 리턴받더라도, Promise는 http error status를 reject 하지 않습니다.\n\n대신 `response`객체의 `ok`프로퍼티로 확인이 가능하며\\(true or false\\), 네트워크 장애등의 에러는 reject를 반환합니다.\n\nPromise기반이므로 ES6이상의 환경에서 동작하며,\n\n그 이하의 환경을 위해 polyfill도 존재합니다.\n\npolyfill: https://github.com/github/fetch\n\n## 사용 방법\n\n```javascript\nfetch(url, option?)\n```\n\nPromise를 리턴하므로 thenable합니다.\n\n```javascript\nfetch(...)\n  .then(...)\n```\n\n```javascript\nfunction parseJson(res){\n  return res.json()\n}\n\nfunction parseHtml(res){\n  return res.text()\n}\n\nfetch(...)\n  .then(parseJson)\n  .then(json => {\n    ...some logic\n  })\n  .catch(err => {\n    console.error(err);\n  })\n  .then()\n```\n\n위의 예제에서 res.json\\(\\)의 리턴값은 Promise객체입니다.\n\n그래서 다시 then으로 체이닝하여 해당 리턴값을 받아서 처리할수있으며\n\n또한 catch로 체이닝하여, 에러핸들링을 할수있고, catch 뒤에 then을 다시 체이닝하여 finally에 해당하는 구문을 작성할 수 있습니다.\n\n현재 TC39 proposal Stage 4 에 해당하는.. 사실상 표준이 된 Promise.prototype.finally 메소드를 사용할 수도 있습니다.\n\n```javascript\nconst BASE_URL = 'http://...';\n\nfunction post(uriParams, body) {\n    return fetch(`${BASE_URL}/${uriParams}`, {\n        method: 'POST',\n        headers: {'Content-Type': 'application/json'},\n        body: JSON.stringify(body)\n      }).then(res => res.json())\n        .then(res => resolve(res))\n        .catch(err => reject(err));\n  }\n```\n\n간단한 post 요청을 하는 예제입니다.\n\npromise객체로 wrapping하여 리턴하고 있습니다.\n\nfetch의 두번째 파라미터에 여러가지 옵션을 설정할수있습니다.\n\nJson을 전송할 때, stringify해서 보내는게 특징입니다.","src/content/docs/browser/fetch.mdx","cbd87399ce6b41ad","browser/get-size",{"id":144,"data":146,"body":151,"filePath":152,"digest":153,"deferredRender":15},{"title":147,"editUrl":15,"head":148,"template":17,"sidebar":149,"pagefind":15,"draft":19},"window height",[],{"hidden":19,"attrs":150},{},"# get-size\n\nclientHeight - padding을 포함합니다.\n\noffsetHeight - padding, 스크롤바, border 사이즈를 포함합니다.","src/content/docs/browser/get-size.mdx","0e539a2d2d4b6729","browser/history-api",{"id":154,"data":156,"body":161,"filePath":162,"digest":163,"deferredRender":15},{"title":157,"editUrl":15,"head":158,"template":17,"sidebar":159,"pagefind":15,"draft":19},"History API",[],{"hidden":19,"attrs":160},{},"# History API\n\n브라우저에 내장된 히스토리는 스택의 형태로 구현되어있습니다.(history stack이라고 표현)\n\nDOM의 window객체를 통해 history객체에 접근할 수 있습니다.\n\n```js\nwindow.history.back(); //뒤로가기\nwindow.history.forward(); //앞으로가기\nwindow.history.go(index); //특정 index로 이동\n/*\nhistory.go() 의 경우, index는 현재 페이지가 0입니다.\n이전페이지로 가려면, history.go(-1) 입니다.\n*/\nwindow.history.length; //히스토리 스택 갯수\n```\n\n## pushState, replaceState\n\n```js\nwindow.history.pushState(stateObj, title, URL)\nwindow.history.replaceState(stateObj, title, URL)\n```\nstateObj: 직렬화할 수 있는 어떤것도 가능합니다. 사용자의 디스크에 저장되며, 최대 640kb로 제한됩니다. 더 크면 예외가 발생합니다.\n\ntitle: 사용하지않는 예약된 변수입니다. 나중에 사용될 수 있으므로 빈문자열이나 간단한 명칭을 지어주면 좋습니다.\n\nURL: 새로운 히스토리 엔트리의 URL입니다. 새롭게 할당되는 URL은 현재 URL에 기준이므로 절대 경로일 필요는 없습니다. 명시하지않으면 현재 URL로 지정되며, URL이 현재 URL에서 유추될 수 없다면 예외가 발생합니다.\n\npushState 메소드를 실행하면 주소창에 새롭게 할당된 URL이 표시됩니다.\n\n예를 들어,\n\n```js\nconst stateObj = {name:'boseokjung'};\nhistory.pushState(stateObj, '', 'boseok.html');\n```\n\n이런 코드를 실행하면, boseok.html에 해당하는 주소로 변경되고, popstate 이벤트를 발생시켜 첫번째 파라미터로 지정한 stateObj의 복사본을 가져옵니다. (history.state로 접근)\n\n짧게 설명하자면 기존 API와는 다르게 너무 크지않은 상태를 저장할 수 있고 실제 페이지가 변경되지않더라도 주소를 변경하고 히스토리 스택을 쌓을 수 있습니다.\n\nreplaceState는 히스토리 스택을 쌓는대신 현재의 히스토리 엔트리를 변경합니다.\n\nSPA에서 이 API가 유용할 수 있는데, 실제로 react, vue-router가 이 API를 활용해서 라우팅을 구현했습니다.\n\n\n## popstate\n\npopstate 이벤트는 현재 활성화된 히스토리 엔트리에 변화가 있을 때 마다 실행됩니다.\n\n```js\nwindow.onpopstate = function(event) {\n  alert(\"location: \" + document.location + \", state: \" + JSON.stringify(event.state));\n};\n\nhistory.pushState({page: 1}, \"title 1\", \"?page=1\");\nhistory.pushState({page: 2}, \"title 2\", \"?page=2\");\nhistory.replaceState({page: 3}, \"title 3\", \"?page=3\");\nhistory.back(); // alerts \"location: http://example.com/example.html?page=1, state: {\"page\":1}\"\nhistory.back(); // alerts \"location: http://example.com/example.html, state: null\nhistory.go(2);  // alerts \"location: http://example.com/example.html?page=3, state: {\"page\":3}\n```\n\n---\n\nref\n\nhttps://developer.mozilla.org/ko/docs/Web/API/History_API\n\nhttps://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate","src/content/docs/browser/history-api.mdx","30421e25686d0e54","browser",{"id":164,"data":166,"body":171,"filePath":172,"digest":173,"deferredRender":15},{"title":167,"editUrl":15,"head":168,"template":17,"sidebar":169,"pagefind":15,"draft":19},"Web Browser",[],{"hidden":19,"attrs":170},{},"브라우저는 입력된 URI에 따라 자원을 가져오고, 해당 자원을 브라우저내에 표시한다.\n\n보통은 HTML이지만 다른 확장자들도 많이 지원한다. (이미지, js, json, PDF등등..)\n\n주소표시줄, 뒤로가기, 앞으로가기, 새로고침등.. 브라우저의 UI와 [렌더링 엔진](#렌더링엔진) 사이의 동작을 제어하는게 브라우저 엔진이라고 한다.\n\n### how web works\n\nhttps://github.com/vasanthk/how-web-works\n\n### 렌더링 엔진\n\nURI로 요청한 자원을 표시한다.\n\nHTML과 CSS를 파싱한다.\n\nHTML 태그들을 DOM노드로 변환한다 => DOM tree 생성\n\n\u003Cimg src=\"https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/image017.png\" alt=\"parse html\" />\n\nCSS 파싱 => CSSOM tree 생성\n\nDOM tree, CSSOM tree의 혼합 => rendering tree(frame tree) => 비 시각적 DOM은 제외\n\n렌더링 트리 생성이 끝나면 리플로우(배치)가 발생한다. => 각 노드가 화면의 정확한 위치에 표시되는 것을 의미한다.\n\nDOM이나 스타일이 변경되면 [reflow, repaint](/browser/reflow-repaint)가(혹은 둘다) 또 일어난다.\n\n\u003Cimg src=\"https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/webkitflow.png\" alt=\"webkit flow\"/>\n\n### 자바스크립트 엔진\n\n자바스크립트 엔진(크롬에선 V8)은 자바스크립트 코드를 해석하고 실행한다.\n\nHTML태그를 파싱하다가 script 태그를 만나면 스크립트를 가져오고 실행이 끝날때까지 블로킹된다.\n\ndefer옵션이 있다면 자바스크립트를 나중에 실행한다.\n\nasync 옵션이 있다면 다른 스레드에서 실행한다.\n\n## 웹브라우저 동작과정 요약\n\nurl을 입력하고 엔터를 누르면...\n\n1. 요청하는 리소스가 브라우저 캐시에 있는지 확인합니다.\n2. 없으면 요청한 호스트정보를 로컬에서 먼저 찾고, 없으면 dns에서 찾아 ip를 얻습니다.\n3. 얻은 ip를 기반으로 TCP/IP 커넥션을 맺고 리소스를 다운받습니다.\n4. 다운받은 리소스를 기반으로 화면에 그립니다.\n5. 요청한 리소스가 html이라면, 렌더링 엔진이 html, css를 파싱하여 html은 dom tree, css는 cssom tree를 생성하고, 둘을 합쳐서 render tree를 생성합니다.\n6. 뷰포트 내에서 각 노드의 정확한 위치와 크기를 정확하게 계산하는 리플로우가 일어나며,\n7. 렌더링 트리의 각 노드를 화면의 실제 픽셀로 변환하는 페인팅과정이 일어나고\n8. 사용자가 화면을 볼 수 있게 됩니다.\n---\n\nref: https://d2.naver.com/helloworld/59361","src/content/docs/browser/index.mdx","8b7d60d0f348cc50","browser/reflow",{"id":174,"data":176,"body":181,"filePath":182,"digest":183,"deferredRender":15},{"title":177,"editUrl":15,"head":178,"template":17,"sidebar":179,"pagefind":15,"draft":19},"reflow (layout)",[],{"hidden":19,"attrs":180},{},"리플로우라는것은 렌더링 트리의 일부\\(또는 전부\\)의 변경이 있을때 발생한다.\n\n한마디로 리플로우는 배치를 뜻한다. 다른말로 레이아웃이라고도 한다.\n\n렌더러가 생성되어 트리에 추가될 때 노드의 크기와 위치 정보는 없는데 이런 값을 계산하는 것이다.\n\n그래서 첫 페이지의 레이아웃이 표시될때 리플로우가 일어난다.\n\n렌더링 트리를 구성하는데 사용된 입력 정보의 어떤 변경도 리플로우와 리페인트를 발생시킨다. 구체적으로는 다음과 같은 경우이다.\n\n```\nDOM 노드의 추가, 삭제 및 업데이트\ndisplay: none(리플로우와 리페인트) 또는 visibility: hidden(위치 변경은 일어나지 않기 때문에, 리페인트만) 등과 같은 DOM 노드 숨김\n페이지상에서 DOM 노드의 위치 이동 및 애니메이션\n스타일 속성의 약간의 변화를 위해 스타일 시트 추가\n윈도우 크기를 변경하거나 폰트 크기 변경, 그리고 스크롤 등 사용자의 액션\n```\n\n이러한 일들이 자주 일어나기때문에, 브라우저는 작업을 큐에 밀어넣고 업데이트가 필요할때 큐를 플러시하여 리플로우를 최소화한다.\n\n아래와 같은 작업의 get set은 큐를 플러시해야하는 작업들이다. 그러므로 for루프등 내부에 사용하게되면 루프를 돌때마다 리플로우가 일어나기때문에,\n\n루프 바깥 블록에 할당해놓고 사용하는것이 유리하다.\n\n```\noffsetTop, offsetLeft, offsetWidth, offsetHeight\nscrollTop, scrollLeft, scrollWidth, scrollHeight\nclientTop, clientLeft, clientWidth, clientHeight\ngetComputedStyle() 또는 IE의 currentStyle\n```\n\n리플로우가 크기 변경 또는 렌더러 위치 변화때문에 실행되는 경우 렌더러의 크기는 다시 계산하지 않고 캐시로부터 가져온다.\n\n큐나 캐싱으로 무거운 렌더링 작업을 최적화한다.\n\n[리플로우를 유발하는 것들을 정리한 링크(?)](https://gist.github.com/paulirish/5d52fb081b3570c81e3a)\n\n### reference\n\nhttp://www.mimul.com/pebble/default/2013/07/07/1373183724195.html\n\nhttps://github.com/wonism/TIL/blob/master/front-end/browser/reflow-repaint.md\n\nhttps://d2.naver.com/helloworld/59361","src/content/docs/browser/reflow.mdx","c30bff755007b170","browser/render-tree",{"id":184,"data":186,"body":191,"filePath":192,"digest":193,"deferredRender":15},{"title":187,"editUrl":15,"head":188,"template":17,"sidebar":189,"pagefind":15,"draft":19},"렌더 트리(Render Tree)",[],{"hidden":19,"attrs":190},{},"[DOM](dom) 및 [CSSOM](/browser/cssom) 트리는 결합되어 렌더 트리를 형성합니다.\n\n![](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png?hl=ko)\n\n렌더 트리에는 페이지를 렌더링하는 데 필요한 노드만 포함됩니다.\n\n레이아웃(reflow)은 각 객체의 정확한 위치 및 크기를 계산합니다.\n\n마지막 단계는 최종 렌더링 트리에서 수행되는 페인트이며, 픽셀을 화면에 렌더링합니다.\n\n여기에서 reflow와, repaint라는 용어가 등장하는데,\n\n[그 설명은 여기에서..](/browser/reflow-repaint)\n\nreference: https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=ko","src/content/docs/browser/render-tree.mdx","279cd070434ac794","browser/session",{"id":194,"data":196,"body":201,"filePath":202,"digest":203,"deferredRender":15},{"title":197,"editUrl":15,"head":198,"template":17,"sidebar":199,"pagefind":15,"draft":19},"session",[],{"hidden":19,"attrs":200},{},"세션이란 일정 시간(default 30분 혹은 브라우저 종료)동안 같은 클라이언트로부터 들어오는 일련의 요구를 하나의 상태로 보고 그 상태를 일정하게 유지시키는 기술.\n\n클라이언트가 서버로 request를 보내면, 서버에서 클라이언트를 구분하기위해 UID를 발급해준다.\n\n발급한 세션ID를 쿠키를 이용하여 클라이언트에도 저장한다.\n\n쿠키는 서버와 통신할때 같이 전송되므로 세션ID를 활용할 수 있다.\n\n[sessionStorage는 여기서..](/browser/storage)","src/content/docs/browser/session.mdx","28611bcc3540321b","browser/storage",{"id":204,"data":206,"body":211,"filePath":212,"digest":213,"deferredRender":15},{"title":207,"editUrl":15,"head":208,"template":17,"sidebar":209,"pagefind":15,"draft":19},"storage",[],{"hidden":19,"attrs":210},{},"window객체에 localStorage, sessionStorage 라는 두개의 key value 저장소가 있다.\n\n~~react-native\\(이하 rn\\)의 AsyncStorage와 같은 인터페이스이다. \\(사용방법이 같다. 리턴은 조금 다르지만\\)~~\n\nvalue에는 문자열이나 숫자가 들어갈수있다\\(숫자도 문자열로 자동변환됨 =&gt; getItem하면 문자열로 리턴\\)\n\n이때 object를 저장하고싶다면 value에 object를\n\n```javascript\nJSON.stringify(object)\n```\n\n이런식으로 문자열로 변환하여 넣고,\n\ngetItem할때\n\n```javascript\nJSON.parse(localStorage.getItem('someKey'))\n```\n\n해서 사용하면된다.\n\n사용자에 하드디스크에 저장되므로 탭을 여러개 띄워도 공유가 가능하다.\n\n당연히 브라우저나 컴퓨터를 종료했다가 다시 실행해도 값이 남아있다.\n\n하지만 브라우저끼리의 호환은 안된다.\n\nsessionStorage은 페이지세션이 종료되면 사라진다.\n\n\\(해당 탭 종료하거나.. 탭을 여러개 띄워놓고 공유가 안됨. 각각의 세션 스토리지가 생김\\)\n\n```javascript\nlocalStorage.setItem('boseok', 'boseok`s message!!!') \n\nconsole.log(localStorage.getItem('boseok')) //boseok's message!!!\n```\n\n위와같은 결과를 얻을수있다\n\nrn에서는 getItem과 setItem이 Promise를 리턴한다. \\(비동기\\)\n\n하지만 js의 window객체- 에서는 동기적으로 리턴한다\n\n정리-\n\nlocalStorage, sessionStorage 키값 저장소가 있음.\n\n같은 인터페이스임 - 사용법(메소드)이 같음\n\n비동기api가 아니라서 큰 값 저장하기에는 무리가 있음 - blocking\n\n큰 값을 저장하고 싶다면 indexedDB등의 DB를 사용\n\ngetItem\\(문자열키\\)\n\nsetItem\\(문자열키, 저장할문자열값\\)\n\n그외의 메소드들\n\nremoveItem\\(key\\) =&gt; 아이템 한개 삭제\n\nclear\\(key\\) =&gt; this storage 모두 삭제","src/content/docs/browser/storage.mdx","3bcbe4c0dfee1fb7","browser/web-standard",{"id":214,"data":216,"body":221,"filePath":222,"digest":223,"deferredRender":15},{"title":217,"editUrl":15,"head":218,"template":17,"sidebar":219,"pagefind":15,"draft":19},"웹표준, 웹접근성",[],{"hidden":19,"attrs":220},{},"## 웹표준\n\nWorld Wide Web\\(www\\)의 측면을 서술하고 정의하는 공식 표준이나 다른 기술 규격을 가리키는 일반적인 용어이다.\n\n웹 사이트나 웹 페이지가 웹 표준을 준수한다는 것은 일반적으로 올바른 HTML, CSS, 자바스크립트를 사이트나 페이지가 가지고 있다는 것을 뜻한다. HTML은 접근성과 시맨틱 HTML의 가이드라인을 충족해야 한다.\n\nHTML, XHTML, SVG, XForms와 같은 마크업 언어의 W3C 권고\n\n스타일시트, 특히 CSS의 W3C 권고\n\n흔히 자바스크립트나 ECMA스크립트로 불리는 Ecma 인터내셔널 표준\n\n문서 객체 모델의 W3C 권고\n\n[DOCTYPE에 대한 내용은 여기서](/browser/doctype)\n\n**_과거에는 각 브라우저들이 웹표준을 일부만 구현하는 바람에 웹 개발자가 호환성문제를 심각하게 겪었다_**\n\n## 웹접근성\n\n웹 접근성\\(web accessibility\\)은 장애를 가진 사람과 장애를 가지지 않은 사람 모두가 웹사이트를 이용할 수 있게 하는 방식을 가리킨다.\n\n사이트가 올바르게 설계되어 개발되고 편집되어 있을 때 모든 사용자들은 정보와 기능에 동등하게 접근할 수 있다.\n\n웹 접근성에는 다음의 사항들을 고려하여야 한다:\n\n시각: 실명, 색각 이상, 다양한 형태의 저시력을 포함한 시각 장애\n\n운동성: 파킨슨병, 근육병, 뇌성마비, 뇌졸중과 같은 조건으로 인한 근육 속도 저하, 근육 제어 손실로 말미암아 손을 쓰기 어렵거나 쓸 수 없는 상태\n\n청각: 청각 장애\n\n발작: 깜박이는 효과나 시각적인 스트로보스코프를 통해 일어나는 뇌전증성 발작\n\n인지: 문제 해결과 논리 능력, 집중력, 기억력에 문제가 있는 정신 지체 및 발달 장애, 학습 장애 \\(난독증, 난산증 등\\)\n\nreference:\n\nhttps://ko.wikipedia.org/wiki/웹_표준\n\nhttps://ko.wikipedia.org/wiki/웹_접근성","src/content/docs/browser/web-standard.mdx","42cabc83a3b3e078","browser/web_api",{"id":224,"data":226,"body":231,"filePath":232,"digest":233,"deferredRender":15},{"title":227,"editUrl":15,"head":228,"template":17,"sidebar":229,"pagefind":15,"draft":19},"Web API",[],{"hidden":19,"attrs":230},{},"DOM\\(Document\\)\n\nXHR\\(XmlHttpRequest\\) - ajax, fetch, axios\n\ntimeout - setTimeout, setInterval\n\n이것들은 개발자가 접근할수없는, 호출만 가능한 스레드이다. \\(노드의 경우 C++ API\\)\n\n```js\nfunction sleep(delay) {\n  var start = Date.now();\n  while (Date.now() \u003C start + delay);\n}\n\nsetTimeout(() => {\n  console.log(\"start\");\n  sleep(10000);\n  console.log(\"end\");\n}, 10);\n```\n\n위의 코드를 보면, setTimeout이 별도스레드에서 실행된다고 가정하면,\n\n브라우저 콘솔에 이 코드를 붙여넣고 기능을 작동시켜보자.\\(버튼을 누른다던지\\)\n\nend가 콘솔에 찍히기전에는 어떠한 동작도 실행되지않는다.\n\n이것은 별도스레드에서 작동하는게 아니라,\n\n싱글스레드인 이벤트루프와 큐를 통해 작동하고 있는 것을 확인할 수 있다.\n\n하지만 fetch, XHR, worker API는 백그라운드 스레드에서 동작한다.\n\n나머지 setTimeout, setInterval, RequestAnimationFrame, Promise는 메인 스레드 이벤트 루프다.\n\n어차피 나중에 코드가 실행되는 것이므로, web api에 무거운 로직이 들어가서\n\n오래걸리는게 싫다면 아래의 워커 api를 사용하면 된다.\n\n[worker API](/browser/worker-api)\n\n이것은 js의 싱글스레드의 한계를 극복할수있게 도와주는 api이다.\n\n별도의 워커스레드에서 스크립트를 실행한다.\n\n---\n\n## setTimeout, setInterval\n\nsetTimeout, setInterval은 비동기로 함수를 실행시킬 수 있다.\n\nsetTimeout(callback, N)은 타이머id를 반환하고 대략(일반적으로 +4ms) \\{N}ms 후에 callback을 실행시킨다.\n\nsetInterval은 setTimeout과 유사하지만 함수호출을 쌓는다.\n\n지정한 시간마다 함수를 실행시켜준다.\n\n실행하는 코드가 일정시간 동안 블럭되도 계속 함수를 호출하기때문에 계속 쌓인다.\n\n따라서 의도했던 실행주기를 보장할 수 없다.\n\n블럭되는 코드를 해결하려면 recursive를 이용하자.\n\n```js\nfunction somefunc() {\n  setTimeout(somefunc, 1000);\n}\n```\n\n이렇게하면 함수 호출이 쌓이지도 않고, 제어하기도 쉽다.\n\n마지막으로, 타이머를 모두 쓰고나면 리턴받은 타이머id로 clearTimeout을 해주자.","src/content/docs/browser/web_api.mdx","888f93f2bad5d7a5","browser/worker-api",{"id":234,"data":236,"body":241,"filePath":242,"digest":243,"deferredRender":15},{"title":237,"editUrl":15,"head":238,"template":17,"sidebar":239,"pagefind":15,"draft":19},"Worker API",[],{"hidden":19,"attrs":240},{},"웹워커 API는 메인스레드외에 별도의 워커스레드에서\\(백그라운드\\) 스크립트를 실행할 수 있게 해준다.\n\nui를 위한 메인스레드에서 무거운 동작을 하게되면 ui의 멈춤이나 속도 저하가 발생하는데, 그것을 위해 탄생했다.\n\n앞으로 클라이언트에서 동작하는 코드가 점점 많아질텐데, 그것을 대비해서 사용법을 알아두면 좋을 것 같다.\n\n워커스레드에서 작동하는 코드들은 모든 메소드를 사용할 수 있는 것이 아니다.\n\n아래 링크는 사용가능한 함수들이 정리되어있다.\n\n[https://developer.mozilla.org/en-US/docs/Web/API/Web\\_Workers\\_API/Functions\\_and\\_classes\\_available\\_to\\_workers](https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Functions_and_classes_available_to_workers)\n\n## 서비스워커 \\(Service Worker\\)\n\n웹 어플리케이션 사이의 Proxy Server와 브라우저로서 역할을 하며 \\(만약 가능하다면\\)통신을 구축합니다. 이를 통해 효율적인 오프라인 경험을 구축하고, 네트워크 요청을 가로채어 통신이 가능한지 여부에 따라 적절한 동작을 수행하며, 서버에 존재하는 자원들을 갱신할 수 있습니다. 또한 푸시 알림이나 백그라운드 동기화 API에 접근을 허용합니다.\n\n## Channel Messaging API\n\n### 이 API는 웹 워커안에서만 동작합니다\n\n채널 메시징 API는 동일한 문서에 첨부 된 서로 다른 브라우징 컨텍스트에서 실행되는 두 개의 개별 스크립트가 양방향 포트 \\(또는 파이프\\)를 통해 양 끝의 포트를 통해 메시지를 직접 전달할 수 있도록합니다.\n\n---\n\nReference\n\nhttps://developer.mozilla.org/ko/docs/Web/API/Web_Workers_API\n\nhttps://developer.mozilla.org/ko/docs/Web/API/Worker\n\nhttps://developer.mozilla.org/ko/docs/Web/API/Channel_Messaging_API","src/content/docs/browser/worker-api.mdx","2e7a29935dfcfa0a","fe/charles-proxy",{"id":244,"data":246,"body":251,"filePath":252,"digest":253,"deferredRender":15},{"title":247,"editUrl":15,"head":248,"template":17,"sidebar":249,"pagefind":15,"draft":19},"찰스 프록시 사용하기",[],{"hidden":19,"attrs":250},{},"## charlesproxy\n\nhttps://www.charlesproxy.com/\n\n네트워크 패킷들을 감시할 수 있고, 프록시 할 수도 있는 좋은 유료툴이다.\n\n상용에 배포된 페이지에서 자바스크립트 파일을 내 로컬의 (빌드된) 자바스크립트 파일로 바꿔치기할때 사용했다.\n\n내가 수정했던 사항이 라이브에서도 원하는대로 정확하게 동작하는지 눈으로 확인하고 싶었다.\n\n---\n\n## SSL 인증서\n\n감시하거나 프록시할 리소스가 https로 서빙된다면 당연히 인증서가 필요하다.\n\ncharles 메뉴 => Help => SSL Proxing => install charles Root Certificate 를 순서대로 선택한다\n\n그러면 이제 맥의 키체인 접근에 Charles Proxy...이 추가된걸 확인할 수 있고, 더블클릭하여\n\n신뢰 => 이 인증서 사용시: ```항상 신뢰``` 로 변경해준다.\n\n---\n\n찰스와 브라우저를 종료했다가 재시작한다.\n\n브라우저가 캐싱된 js를 불러올 확률이 높으므로, 시크릿모드에서 하거나\n\n개발자도구를 켜서 강제 리프레시 & 캐시삭제를 해주자.\n\n그러면 이제 찰스의 목록에서 바꿔치기 원하는 리소스를 선택하고, 우클릭 -> Map Local 선택한다.\n\nMap From은 자동으로 채워질것이고, Map To에서 Choose를 선택하여 내가 바꿔치기할 리소스를 선택한다.\n\n브라우저를 강제새로고침하면 바꿔치기된 결과를 확인할 수 있다.","src/content/docs/fe/charles-proxy.mdx","890e32f267c8d00f","fe/component",{"id":254,"data":256,"body":261,"filePath":262,"digest":263,"deferredRender":15},{"title":257,"editUrl":15,"head":258,"template":17,"sidebar":259,"pagefind":15,"draft":19},"컴포넌트와 컴포넌트 설계",[],{"hidden":19,"attrs":260},{},"# 시작하기 앞서\n\n우선, react 함수형 컴포넌트 기준으로 설명합니다.\n\nreact, vue 같은 ui 'library'의 역할이 무엇인지 생각해봐야합니다.\n\n왜 이들이 라이브러리라고 불리는지, 무엇을 하는지 정확하게 알고 넘어가야합니다.\n\nui library는 ui 데이터(상태, 속성)가 변경되면 ui를 갱신해줍니다.\n\n직접 DOM에 접근하여 ui를 갱신하는 것은 상당히 피곤한 일 입니다. 크로스브라우징 이슈를 신경써야하며, 비즈니스 로직과 ui를 갱신하는 로직이 섞여서 유지보수가 힘들어집니다.\n\n위에서도 언급했던 것처럼 브라우저 API마다 다른 동작을 할 수 있는 가능성을 사전에 차단합니다. => 크로스 브라우징\n\n라이브러리의 지원범위내의 브라우저라면, 브라우저에는 개발자가 의도하는대로 렌더링됩니다.\n\n라이브러리에 버그가 있다면 라이브러리측에서 수정해주길 기다리거나, 직접 수정해서 사용하면 됩니다. => 제어역전\n\nui library 자체는 결국 단순 '렌더링'만 하기때문에 router 라던지 상태관리 등 다른 기능은 써드파티 라이브러리를 사용해야합니다.\n\n# 컴포넌트\n\n이해하기쉽게 **'html 엘리먼트의 집합체'** 혹은 블럭이라고 표현할 수 있겠습니다.\n\n마치 레고 블럭처럼 컴포넌트들을 조합하여 앱을 개발합니다.\n\nvue에서는 vue 객체, react에서는 일반적으로 React Element tree를 리턴하는 자바스크립트 함수입니다.\n\n아무것도 렌더링하지않으려면 null을 리턴해야합니다. (react에서는 컴포넌트가 undefined를 리턴하면 에러입니다.)\n\n요약하면 리액트 컴포넌트는 react element tree or null을 반환하고 함수 이름이 PascalCase인 자바스크립트 함수입니다.\n\n리액트 공식문서에서는 아래와 같이 설명하고 있습니다.\n\n```\n개념적으로 컴포넌트는 JavaScript 함수와 유사합니다.\n“props”라고 하는 임의의 입력을 받은 후,\n화면에 어떻게 표시되는지를 기술하는 React 엘리먼트를 반환합니다.\n```\n\n# 컴포넌트 설계\n\njs숙련도가 있다면 컴포넌트를 잘 설계하는게 FE개발 실력의 핵심이라고 할 수 있습니다.\n\n같은 기능을 가진 컴포넌트라도 설계는 사람마다 달라질 수 있죠.\n\n그래서 아래에서 설명하는 컴포넌트 설계방법은 꽤 주관적이며 관점에 따라 다를 수 있습니다. 어찌보면 당연한 내용도 포함되어있고요.\n\n```\n좋은 컴포넌트 개발의 핵심은 재활용 가능한 컴포넌트입니다.\n\n컴포넌트는 기본적으로 StateSetter(StateUpdater)가 호출되면 리렌더됩니다.\n\n성능관점에서 state와 props는 최대한 변경되지 않을수록 유리합니다.\n\nprops만 받아서 렌더만하는 컴포넌트는(프레젠테이션 컴포넌트) storybook을 활용하기 좋으며 쉽게 테스트하고 재활용 할 수 있습니다.\n\n모델렌더를 실현하기도 쉬워지고요. 모델렌더는 아래에서 다시 설명합니다.\n\n```\n\n```\n최근 react에서는 함수형 컴포넌트를 작성하면서 hook API을 사용하게되는데, custom hook을 적극 활용하는게 좋습니다.\n\n마치 클래스 컴포넌트를 사용할때, 프레젠테이션과 컨테이너를 분리했던 것처럼요. \n\n프레젠테이션 컴포넌트 + 모델(hook)을 조합하면 이상적인 컴포넌트 구현입니다.\n\n컴포넌트에서 로직을 깔끔하게 분리해낼 수 있으며 로직의 재활용성과 가독성을 향상시킵니다. (관심사 분리)\n\n훅만 테스트하는건 거의 로직만 테스트하는거라, 테스트코드 작성도 상대적으로 매우 간편해집니다.\n\n상태와 로직, 템플릿이 마구 섞여져있을 수 있는데,\n\n상태를 관리하는 hook - props, state, ref, useMemo를 사용한 computed variable 등..\n\n로직을 관리하는 hook - useCallback을 이용한 메모이제이션된 함수들\n```\n\nhook에 대한 자세한 내용은 [여기를 참고](/fe/react)하세요\n\n## 모델렌더 model render\n\n뷰가 상태를 갖는것이 아닌, 순수 js 객체가 상태를 가져야합니다.\n\n같은 데이터라면 같은 렌더링이 되어야한다는 것입니다.\n\n뷰를 직접 제어하지 않으므로 버그를 발생시키지않고 단순히 모델을 갱신해서 렌더를 발생시켜야합니다.\n\n= DOM을 직접 조작하지말고 setState를 사용해라.\n\n그래야 테스트코드도 작성하기 쉬워집니다.\n## props\n\n극단적으로 표현하면...\n\nstate만 있더라도 컴포넌트를 개발할 수 있습니다.\n\nprops의 존재 이유는 사실 컴포넌트 재활용 말고는 없다고 봐도 됩니다.\n\n무분별하게 컴포넌트를 나누기보단, 컴포넌트가 재활용될 가능성을 생각해보고 컴포넌트를 나누는게 좋습니다.\n\n기본적으로 함수형 리액트 컴포넌트에서는 상위 컴포넌트를 리렌더할때 하위 컴포넌트들을 다시 호출하기 때문이죠.\n\n물론 재활용을 안하더라도, 가독성이나 storybook등 다른 이유로 컴포넌트를 나눌수는 있겠지만, 본질에 대해 다시 생각해볼 필요는 있습니다.\n\n그렇다고 극단적으로 성능관점에서 설계를 하라는 말은 아닙니다. 역할을 분리하는게 더 중요하죠.\n\n## 템플릿\n\n템플릿 - 함수형 컴포넌트에서 리턴하는 React Element tree\n\n```\n템플릿에는 expression을 최소화합니다. - useMemo나 useCallback을 사용하여 변수나 함수만 바인딩하도록 합니다.\n\n템플릿에 로직을 직접 작성하지마세요.\n\nstatic markup에 해당하는 부분들은 가독성을 위해 기능별로 컴포넌트로 분리합니다.\n\n자주 렌더를 수행하는 구간에 필요하다면 React.memo를 활용해도 좋고요.\n```\n\n## 안티패턴\n\n### 템플릿내 로직\n\n위에서도 언급했지만, 템플릿엔 로직을 작성하지마세요.\n\n테스트를 어렵게 만들고 가독성을 해칩니다.\n\n1component 1hook 을 달성하려면 템플릿내 로직이 없어야합니다.\n\n### 렌더링 간섭\n\n위에서 컴포넌트는 state, props가 변경되면 리렌더되어야한다고 했습니다.\n\n반대로 state, props외에 다른 요소들이 렌더에 영향을 주게되면 안티패턴이라고 할 수 있습니다.\n\n대표적으로 DOM조작을 직접(ref를 사용하여 element를 조작하는것 또한 마찬가지입니다.)하거나, key를 사용해서 리렌더하는 방식입니다.\n\nref를 사용하는 자체가 나쁜게 아니라 react 역할인 DOM조작을 개발자가 직접 할필요가 없고, 방해해서는 안됩니다.\n\n## 가독성?\n\n### 조건부 렌더링\n\n템플릿에서 조건부 렌더링을 구현할때 가능하면 if 구문을 쓰지말고 삼항연산자나 && 연산자를 사용하는게 좋다고 생각합니다.\n\n잠깐 &&을 짚고 넘어가면, falsy한 값이 있다면 그것을 먼저 반환한다. 그 뒤의 expression은 무시되며 연산하지도 않는다.\n\n연산중에 truthy값이 있다면 그것을 반환한다.\n\n그러므로 조건에 falsy한 값이 있는지 잘 확인해야한다.\n\n예를 들면, 어떤 회원의 포인트를 렌더링한다고 하자. 포인트는 number형이다.\n\n```js\n\u003Cdiv>{point && \u003Cspan>회원님의 포인트는 {point}점 입니다.\u003C/span>}\u003C/div>\n```\n\n회원의 포인트가 0일때 단순히 0을 렌더링할것이고, '회원님의 ~' 부분은 렌더링되지 않을 것이다.\n\n의도하는게 아니라면, 조건을 boolean형으로 적절히 변형하자.\n\n이런 코드에서 문제점을 한눈에 발견하기 어려울 수도 있다.\n\n조건이 복잡하다면 별도 변수로 추출하여(useMemo) 보기좋게 해주면 된다.\n\n삼항연산자는 2개 이상 중첩하여 사용하면 상대적으로 가독성이 떨어지는 것 같다.\n\n그리고 조건은 boolean형으로 명시적으로 변환해주는게 좋은데,\n\n이유는.. 렌더링 테스트를 작성한다고 했을때, 아래와 같은 간단한 컴포넌트가 있다고 가정하면..\n\n```js\nconst App = () => {\n  const [input, setInput] = useState\u003Cstring>('');\n\n  const onChangeInput = e => setInput(e.target.value);\n\n  return (\n    \u003Cdiv className=\"wrapper\">\n      \u003Cdiv className=\"title\">App\u003C/div>\n      \u003Cdiv className=\"control\">\n        \u003Cinput value={myInput} onChange={onChangeInput}/>\n      \u003C/div>\n      {myInput && \u003Cdiv className=\"result\">{myInput}\u003C/div>}\n    \u003C/div>\n  );\n}\n```\n\n초기렌더링은, wrapper 내부에, title, control, input 필드 이렇게 나타난다.\n\n하지만.. 조건을 보면 myInput이 string이다.\n\n그러면 빈문자열이 당연히 렌더되는것이라고 생각하고, 테스트 프레임워크에서는 output을\n\n```js\nwrapper : ['\u003Cdiv className=\"title\">App\u003C/div>', '\u003Cdiv className=\"control\">\u003Cinput value={myInput} onChange={onChangeInput}/>\u003C/div>', '']\n```\n이런식으로 나타나게된다. (예시임)\n\n그러면 wrapper는 2개의 element가 있어야하는데, 보이지 않지만 빈 문자열이 렌더링됐으므로 마치 3개가 있는것처럼 보인다.\n\n에러가 아닌데 에러처럼 보인다.\n\n위에서 언급한것처럼 0을 렌더링한다던지.. 이런 문제를 해결하기위해\n\nmyInput => !!myInput 이런식으로 변경하도록 하자.\n\n---\n\nref: 머릿속에 있던 내용과 실전 리액트 프로그래밍이라는 책\n\n그리고 https://www.bsidesoft.com/8267 의 저자(선생님)의 가르침","src/content/docs/fe/component.mdx","1853008702295a35","fe/cors",{"id":264,"data":266,"body":271,"filePath":272,"digest":273,"deferredRender":15},{"title":267,"editUrl":15,"head":268,"template":17,"sidebar":269,"pagefind":15,"draft":19},"cors",[],{"hidden":19,"attrs":270},{},"# cors\n\n브라우저에는 cors라는 정책이 있다.\n\n너무너무 유명하므로 링크로 대치한다.\n\nhttps://developer.mozilla.org/ko/docs/Web/HTTP/CORS\n\n이 포스트에선 cors관련 다소 특이한 이슈들만 정리한다.\n\n## 공인망 -> 사설망 http 요청시 에러\n\n로컬 개발시 크로스 도메인에서 호스트 설정을 통해 개발하는 것은 꽤 흔한 일이다.\n\nxxx.aaa 는 공인망, yyy.bbb가 사설망이라고 가정하자. (ip 클래스를 통해 확인하면 된다.)\n\n단순히 xxx.aaa에서 yyy.bbb의 js 리소스만 불러오는데도 크롬 최신버전에선 cors 이슈가 발생할 수 있다.\n\n크롬이 보안을 위해 업데이트된 것이 원인(?)이다.\n\nhttps://developer.chrome.com/blog/private-network-access-update/\n\n해결 방법으로는\n\n - https로 웹서빙을 하자.\n\n - 호스트를 사설망으로만 구성된 호스트로 변경하여 해결한다. (or 사설망 → 공인망 구성도 가능)","src/content/docs/fe/cors.mdx","c7815059c0fbf5ca","fe/csr-ssr",{"id":274,"data":276,"body":281,"filePath":282,"digest":283,"deferredRender":15},{"title":277,"editUrl":15,"head":278,"template":17,"sidebar":279,"pagefind":15,"draft":19},"CSR, SSR",[],{"hidden":19,"attrs":280},{},"# Client Side Rendering & Server Side Rendering (CSR, SSR)\n\ncreate-react-app이나 vue-cli로 프로젝트를 생성해보면, helloworld 컴포넌트가 자동으로 생성되고, 프로젝트를 빌드하고 실행하면 helloworld 컴포넌트가 보일 것이다. 그런데 프로젝트의 index.html을 찾아서 열어보자. 아마  이런 태그와 기본적인 태그들외에는 특별한 요소가 안보일것이다.. 그런데 어떻게 helloworld컴포넌트가 그려질까?\n\n프로젝트를 빌드하면 webpack과 같은 정적파일을 합쳐주고 관리하는등 여러가지 일을 자동으로 해주는 모듈번들러가 bundle.js를 생성해준다. 클라이언트가 배포된 프로젝트의 url로 접근하면, bundle.js와 index.html등 정적파일을 클라이언트의 웹브라우저가 전달받는다. 그리고 클라이언트의 웹브라우저의 js엔진이 bundle.js를 열심히 해석하여 화면을 렌더링한다. 이런방식이 CSR이다.\n\n\n위에서는 설명하기 편하도록 CSR로 SPA를 예로 들었는데, SPA가 CSR 방식이지, 같은 것은 아니다.\n\nnext.js같은 경우는 하이브리드다. 부분적으로만 ssr을 적용할수있다. 결국 CSR이라는 것은 서버에서 태그를 내려주는것이 아닌, 자바스크립트로 DOM을 생성하는것이다.\n\n첫페이지에서 js를 로드하고 동적으로 태그를 생성하기때문에 첫페이지로딩이 상대적으로 느리다. 하지만 그후로는 성능이 좋다. js파일내에 모든 페이지 정보가 있기 때문에.. 그래서 코드스플리팅개념이 등장했다. 처음부터 모든 페이지 정보를 불러오는게 아니라, 웹팩 설정을 통해 페이지 정보와 기능을 나눠서 로드할수있다. 그러면 당연히 처음에 로드되는 파일사이즈가 작아지므로 첫 페이지 로드 성능이 좋아진다.\n\ncsr에는 또 다른 중요한 단점이 존재한다. 번들링된 js에 모든 프론트정보가 담기므로, 보안에 신경써야한다. 그래서 결제모듈등을 구현할때, 해당 모듈의 시크릿 키는 프론트코드내에 있으면 절대로 안된다. 개인정보나 결제시스템이 있다면 ssr로 구현하는것이 당연히 보안적으로 유리하다.\n\n반대로 SSR은 클라이언트가 url을 요청하면, url에 해당하는 서버에서 태그들을 열심히 생성해서 클라이언트에 생성한 태그를 리턴한다. 그러면 클라이언트에서는 이미 생성된 html만 렌더링하면되므로, 초기 로딩속도가 빠르다. 네트워크를 통해서 가져오는 패킷크기도 작을것이다. js로 DOM을 handling하여 화면을 렌더링하는것보다 브라우저가 태그를 파싱해서 렌더링하는것이 빠르다. 하지만 서버에서 클라이언트들이 볼 페이지를 렌더링하므로 서버과부하를 막기위한 전략이 필요하다 좋은 전략은 역시 캐싱이고, 일부분은 클라이언트에서 렌더링하는방식이 좋다.\n\n제일 좋은 구현 방법은 보통 크롤링이 필요한 페이지와 빠른 로딩이 필요한 첫페이지에 SSR을 적용하고, 나머지 페이지들은 CSR로 구현하는것이 성능적으로는 바람직하다. 첫 페이지 로딩속도는 사용자 접속률에 중요한 영향을 끼치고\\(3초 이내\\), CSR을 크롤링 할 수 없는 검색엔진이 대부분이기 때문에\\(자바스크립트 엔진이 내장된 크롤러가 많지않다\\)이다. react를 선택했다면, next.js가 가장 무난하고 좋은선택이다. vue에는 nuxt.js가 있다.\n\n그렇다면 어떤때에 SPA, SSR을 결정하는가? 보통 이렇게 결론이 내려진다.\n\n대부분의 어드민페이지 =&gt; SPA 일반적인 웹사이트 대부분 =&gt; SSR\n\n위에서 설명했던 내용을 이해했다면, 대부분의 프로젝트가 이런식으로 결정된다.","src/content/docs/fe/csr-ssr.mdx","69a86632c08ed25a","fe/css",{"id":284,"data":286,"body":291,"filePath":292,"digest":293,"deferredRender":15},{"title":287,"editUrl":15,"head":288,"template":17,"sidebar":289,"pagefind":15,"draft":19},"CSS",[],{"hidden":19,"attrs":290},{},"# CSS\n\n# css layout\n\nBFC(Block Formatting Context)는 블록 박스가 배치된 웹 페이지의 시각적 CSS 렌더링의 일부입니다. \n\nfloat, absolute로 배치된 요소, inline-blocks, table-cells, table-caption 그리고 visible(그 값이 viewport에 전파되었을 때는 제외)이 아닌 overflow가 있는 요소들이 새로운 Block Formatting Context를 만듭니다.\n\nBFC는 다음 조건 중 하나 이상을 충족시키는 HTML 박스입니다:\n\nfloat의 값이 none이 아님.\nposition의 값이 static도 아니고 relative도 아님.\ndisplay의 값이 table-cell, table-caption, inline-block, flex, inline-flex임.\noverflow의 값이 visible이 아님.\nBFC에서 각 박스의 왼쪽 바깥 모서리는 포함하는 블록의 왼쪽 모서리에 닿습니다(right-to-left 포맷에서는, 오른쪽 모서리에 닿음).\n\nBFC collapse시에 인접한 블록 레벨 박스 사이의 수직 마진. collapsing margins에 대해 자세히 읽어보세요.\n\n\nref: https://github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Korean/questions/css-questions.md\n\n\n# Position\n\nrelative, fixed, absolute, static 요소의 차이점은 무엇인가요?\n\n위치가 정해진 요소는 계산된 position 속성이 relative, absolute, fixed, sticky 중 하나인 요소입니다.\n\nstatic - 기본 위치. 요소가 평소와 같이 페이지에 위치합니다. top, right, bottom, left, z-index 속성은 적용되지 않습니다.\n\nrelative - 요소의 위치가 레이아웃을 변경하지 않고, 자체에 상대적으로 조정됩니다. (따라서 배치되지 않은 요소의 간격을 남겨 둡니다.)\n\nabsolute - 요소가 페이지의 평소 위치에서 제거되고, 가장 가까운 relative 부모 블록이 있는 경우 지정된 위치에 배치됩니다. 그렇지 않으면 최상위 블록에 의존됩니다. absolute로 배치된 박스는 margin을 가질 수 있으며 다른 margin과 충돌하지 않습니다. 이 요소는 다른 요소의 위치에 영향을 주지 않습니다.\n\nfixed - 요소는 페이지의 평소 위치에서 제거되고 뷰포트를 기준으로 지정된 위치에 배치되며 스크롤 할 때 이동하지 않습니다.\n\nsticky - sticky는 relative와 fixed의 하이브리드입니다. 요소는 지정된 임계값을 넘을 때까지 relative 위치로 처리되며, 특정 지점에서 fixed 위치로 처리됩니다.\n\n-------\n\n### absolute 포지셔닝 대신 translate()를 사용하는 이유가 무엇인가요? 또는 그 반대의 경우에 대해서는 어떻게 생각하시나요?, 그 이유는 무엇인가요?\n\ntranslate()은 CSS transform의 값입니다. transform이나 opacity를 변경해도 브라우저의 reflow나 repaint가 다시 발생하지 않고 컴포지션만 실행되는 반면, 절대 위치를 변경하면 reflow가 발생합니다. \n\ntransform을 사용하면 브라우저에서 이 요소를 위한 GPU 레이어가 생성되지만, 절대 위치 속성을 변경하는 것은 CPU를 사용합니다. 그러므로 translate()가 더 효율적이며, 매끄러운 애니메이션을 위한 페인트 시간이 짧아집니다.\n\ntranslate()을 사용할 때는 절대 위치를 변경할 때와 달리 원래 위치(일종의 position: relative)를 그대로 사용합니다.\n\n-----------\nref\n\nhttps://github.com/yangshun/front-end-interview-handbook/blob/master/Translations/Korean/questions/css-questions.md\n\nhttps://developer.mozilla.org/en/docs/Web/CSS/position\n\n# text-ellipse\n\n```css\n.some-class {\n  display: -webkit-box;\n  -webkit-box-orient: vertical;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: normal;\n  -webkit-line-clamp: 3;\n  height: 3.6rem;\n  line-height: 1.2rem;\n}\n```\n\n중요한건 웹킷이 아니면, line clamp를 처리못하므로,\n\n3줄이 넘어가도 작동합니다.\n\n그래서 height를 line height의 3배로 줘서, 3줄이 넘어가면\n\n자동으로 자르게 했습니다. 크기는 동적으로줘서 크기변경에 상관없이 작동하도록 구현.\n\n그리고 overflow속성을 없애면, 그냥 설정해놓은 태그영역을 벗어나므로 주의하세요!\n\n\n# white-space\n\ndiv의 width는 충분한데 내부의 텍스트가 의도치않게 개행될때가 있다.\n\n그럴땐 아래의 스타일 속성을 추가해주면 된다.\n\n```css\n  white-space: nowrap;\n```","src/content/docs/fe/css.mdx","376cb25a2f6613dc","fe/jest-snapshot-test",{"id":294,"data":296,"body":301,"filePath":302,"digest":303,"deferredRender":15},{"title":297,"editUrl":15,"head":298,"template":17,"sidebar":299,"pagefind":15,"draft":19},"Snapshot Test",[],{"hidden":19,"attrs":300},{},"# Jest Snapshot Test\n\n## 개요\n\nJest Snapshot Test는 UI가 예상치못하게 변경되지않도록 도와줍니다.\n\n코드의 일부분을 수정했을때, 해당 코드에 의존하고 있는 여러 컴포넌트가 변화될 수 있는데 그 변화를 정확하게 예측하긴 어렵습니다.\n\n스냅샷 테스트 코드를 작성하여\u001e컴포넌트의 변화를 알기 쉽게 합니다.\n\n## 활용\n\n먼저 스냅샷 테스트 코드를 작성합니다.\n\n```js\n// button.react.test.js\nimport React from \"react\";\nimport renderer from \"react-test-renderer\";\n\nit(\"button renders correctly\", () => {\n  const tree = renderer\n    .create(\n      \u003Cbutton type=\"button\" onClick={() => {}}>\n        OK\n      \u003C/button>\n    )\n    .toJSON();\n  expect(tree).toMatchSnapshot();\n});\n```\n\n테스트코드를 실행시키면 아래와같이 `__snapshot__` 디렉토리에 snap이라는 확장자로 된 파일이 하나 생성됩니다.\n\n(정확히는 toMatchSnapshot 메소드를 실행시키면 파일이 생성됩니다.)\n\n```js\n// __snapshot__/button.react.test.js.snap\n// Jest Snapshot v1, https://goo.gl/fbAQLP\n\nexports[`button renders correctly 1`] = `\n\u003Cbutton\n  onClick={[Function]}\n  type=\"button\"\n>\n  OK\n\u003C/button>\n`;\n```\n\ntemplate literal을 보시면 react component가 string형태로 생성되어 있습니다.\n\n여기서 의도적으로 button의 type을 submit으로 바꿔보겠습니다.\n\n```js\n// button.react.test.js\nimport React from \"react\";\nimport renderer from \"react-test-renderer\";\n\nit(\"button renders correctly\", () => {\n  const tree = renderer\n    .create(\n      \u003Cbutton type=\"submit\" onClick={() => {}}>\n        OK\n      \u003C/button>\n    )\n    .toJSON();\n  expect(tree).toMatchSnapshot();\n});\n```\n\n변경하면 아래와 같은 긴 테스트 실패 메시지가 콘솔에 출력됩니다\n\n```\n FAIL  src/components/common/__tests__/Button.react.test.tsx\n  ● button renders correctly\n\n    expect(received).toMatchSnapshot()\n\n    Snapshot name: `button renders correctly 1`\n\n    - Snapshot\n    + Received\n\n      \u003Cbutton\n        onClick={[Function]}\n    -   type=\"button\"\n    +   type=\"submit\"\n      >\n        OK\n      \u003C/button>\n\n      10 |     )\n      11 |     .toJSON();\n    > 12 |   expect(tree).toMatchSnapshot();\n         |                ^\n      13 | });\n      14 |\n\n      at Object.\u003Canonymous> (src/components/common/__tests__/Button.react.test.tsx:12:16)\n\n › 1 snapshot failed.\nSnapshot Summary\n › 1 snapshot failed from 1 test suite. Inspect your code changes or press `u` to update them.\n```\n\n+로 표시된 부분과 -로 표시된 부분을 보시면, 스냅샷과 현재상태를 비교해서 보여줍니다.\n\n어떤 부분이 변경됐는지 명확하게 파악할 수 있습니다.\n\n의도하지않은 변경이라면 코드를 수정하면 될 것이고\n\n의도한 변경이라면 스냅샷을 변경(업데이트)해주면 됩니다.\n\n콘솔에서(watch모드인 경우) 'u'를 누르면 자동으로 업데이트됩니다.\n\n혹은 테스트 커맨드에 jest라면 --updateSnapshot 옵션을, react-scripts test라면 -u 옵션을 주면 됩니다.\n\n### 인라인 스냅샷\n\n`__snapshot__/button.react.test.js.snap`\n\n이런식으로 파일과 디렉토리가 늘어나는게 별로 반갑지않다면 인라인 스냅샷을 하는 방법도 있습니다.\n\ntoMatchInlineSnapshot 을 사용하세요.\n\n테스트를 실행하고나면 해당 메소드 파라미터에 template literal이 자동으로 생성되어 추가됩니다.\n\n```js\nimport React from \"react\";\nimport renderer from \"react-test-renderer\";\n\nit(\"button renders correctly\", () => {\n  const tree = renderer\n    .create(\n      \u003Cbutton type=\"button\" onClick={() => {}}>\n        OK\n      \u003C/button>\n    )\n    .toJSON();\n  expect(tree).toMatchInlineSnapshot(`\n    \u003Cbutton\n      onClick={[Function]}\n      type=\"button\"\n    >\n      OK\n    \u003C/button>\n  `);\n});\n```\n\n## 마무리\n\n스냅샷 테스트가 오류를 뱉어낼때, 컴포넌트의 변경을 알기 쉽지만\n\n반대로 컴포넌트가 의도적으로 변경된 것 인지 판단할 수 있는 개발자의 역량이 필요합니다.\n\n만약 의도치않은 컴포넌트 에러가 났는데도 실수로 스냅샷 테스트를 업데이트하면 의도하지 않은 변경이라도 테스트에서 통과됩니다.\n\n복잡한 컴포넌트에는 적용하기가 귀찮다.\n\n공통으로 활용되는 컴포넌트들에 적용해놓으면 마음이 조금 더 편해질것같다.\n\n인라인 스냅샷의 경우 pr로 코드리뷰를 한다면, 스냅샷 업데이트를 pr에 올리지않게 하기위해.. 조금 더 손이 간다. 그래서 개인적으로 추천하진않는다.\n\nref: https://jestjs.io/docs/en/snapshot-testing","src/content/docs/fe/jest-snapshot-test.mdx","8e49871a01cbb96d","fe/optimizing",{"id":304,"data":306,"body":311,"filePath":312,"digest":313,"deferredRender":15},{"title":307,"editUrl":15,"head":308,"template":17,"sidebar":309,"pagefind":15,"draft":19},"최적화 관련",[],{"hidden":19,"attrs":310},{},"## 웹사이트 최적화\n\n1. url끝에 /를 붙인다. 안붙이면 리다이렉트함.\n\n2. 리다이렉트할때 메타태그로하면 좋지않다. 메타태그에 있는 페이지를 거쳐야 리다이렉트된다는점이다. 그리고 메타태그가 있는 페이지에 이미지, 스타일시트, 스크립트등의 링크가 존재한다면, 해당 리소스를 다운로드한다. 불필요한 파일들을 다운받는건 손해이다. Fiddler로 301, 302 코드가 발생하는 요소들을 찾아 의도치않게 리다이렉트되는 부분을 제거하자.\n\n3. 네트워크를 통해 무언가 가져오는 작업은 느리고, 비용도 많이 든다. 크기가 큰 응답은 클라이언트/서버 사이에 많은 왕복을 필요로한다. 그래서 http 캐싱은 중요하다.\n\n4. 웹페이지에서 동시에 많은 변수가 생성되고 처리되는 동안 브라우저에서 허용한 임계치를 넘었을때 GC가 동작하고, GC가 동작하면 스크립트 실행이 중단된다. GC가 완료되기 전까지 스크립트가 동작하지 못해 페이지가 느려진다.\n\n5. DOM의 생성과 삭제가 빈번한 페이지, 한페이지에 다수 ajax 통신이 필요한 페이지, 이벤트 바인딩 수가 많은 페이지, 사용자 체류시간이 긴 페이지를 개발할때는 필요없는 변수가 오브젝트 삭제, 이벤트 해제등을 활용하여 메모리 관리를 해야한다.\n\n---\n\n## FE 기법들\n\n- Image Lazy Load\n- dynamic import\n- windowing(virtual scroll)","src/content/docs/fe/optimizing.mdx","7233f4575e34fdb3","fe/pre-render",{"id":314,"data":316,"body":321,"filePath":322,"digest":323,"deferredRender":15},{"title":317,"editUrl":15,"head":318,"template":17,"sidebar":319,"pagefind":15,"draft":19},"Pre-render",[],{"hidden":19,"attrs":320},{},"# Pre-render\n\n기존 SPA에서 발생하는 문제가 크게는 2가지로 나타난다.\n\n1. 초기로딩속도문제\n\nspa에서는 껍데기만 갖고있는 html파일과 스타일시트(css), 상대적으로 큰 js파일이 하나 존재하는데,\n\n모든 페이지의 내용을 첫 로딩때 모두 불러오는것이다. (코드스플리팅이 안되어있다면)\n\n미리 보여질 필요도 없는 내용을 미리 불러오는 것이기 때문에, 첫 로딩이 상대적으로 길게 느껴집니다.\n\n극단적으로 앱이 너무 거대해져서 3초를 넘어가게되면 떠나가는 사용자들이 많이 생길텐데,\n\n한명 한명이 미래의 수입이 될 사용자를 놓쳐선 안됩니다.\n\n\n2. SEO\n\n서버에서 렌더링하는 방식과는 다르게, js가 로딩되고 난 후 js코드에 따라 dom이 생성됩니다.\n\njs엔진이 없는 크롤러는 빈껍데기만있는 템플릿을 크롤링하기때문에, spa는 검색에서 불리한 위치입니다.\n\n물론 구글같은 경우에는 크롤러에 js엔진이 내장되어있어서 문제없는데, 네이버는 js엔진이 없다고하네요.\n\n우리나라 특성상 네이버검색을 포기하기에는 아직 조금 이르기때문에, 서버렌더링을 고려해야합니다.\n\n위와 같은 문제를 해결하기 위해서는 pre-render, ssr이라는 두가지방법으로 해결할수있습니다.\n\n여기서는 pre-render를 먼저 소개하겠습니다.\n\n말 그대로 미리 렌더링하는 방식인데, 첫 페이지와 검색해서 나와야하는 페이지에 적용시키게되면, 앞선 2가지 문제를 해결할 수 있습니다.\n\n그리고 ssr보다 구현이 상대적으로 간편합니다.\n\nspa로 구현된 웹을 ssr방식으로 전환하려면, 굉장히 까다롭습니다.\n\n직접 ssr을 구현할수있겠지만, 개발자가 충분하지않다면 결국 또 다른 프레임워크를 도입해야하거든요.\n\n또 다른 프레임워크를 도입하면, 그 프레임워크의 api를 봐야하고..\n\n안정성있는지 확인하고 테스트해봐야하고.. 겉으로는 별로 바뀌는게 없어보이는데 시간이 꽤 소요되죠.\n\n그리고 정적파일 호스팅만 하면 되는 spa와는 달리 조금 더 복잡하고 귀찮은 서버환경도 필요하게 되죠.\n\n그리고 렌더링하는 서버측의 부하도 무시할 수 없습니다.\n\n요즘은 클라우드 서비스를 많이 사용하기때문에, 서버측 부하는 결국 돈으로 이어집니다.\n\npre-render는 그냥 웹팩에 플러그인을 추가하는 수준이라고 생각하시면 됩니다.\n\n그리고 아래는 실제로 웹팩에 플러그인을 적용하는 방법입니다.\n\n추천하는 사전렌더링 플러그인 prerender-spa-plugin\n\n아래는 커맨드\n\n> npm i -D prerender-spa-plugin \n\n\ntroubleshooting \\(ubuntu 18 lts\\)\n\n> sudo npm install puppeteer --unsafe-perm=true --allow-root\n\n\n> sudo apt-get install libpangocairo-1.0-0 libx11-xcb1 libxcomposite1 libxcursor1 libxdamage1 libxi6 libxtst6 libnss3 libcups2 libxss1 libxrandr2 libgconf2-4 libasound2 libatk1.0-0 libgtk-3-0\n\n> sudo wget https://dl.google.com/linux/direct/google-chrome-stable_current_amd64.deb\n\n> sudo dpkg -i ./google-chrome-stable_current_amd64.deb\n\n> sudo apt install gconf-service libasound2 libatk1.0-0 libc6 libcairo2 libcups2 libdbus-1-3 libexpat1 libfontconfig1 libgcc1 libgconf-2-4 libgdk-pixbuf2.0-0 libglib2.0-0 libgtk-3-0 libnspr4 libpango-1.0-0 libpangocairo-1.0-0 libstdc++6 libx11-6 libx11-xcb1 libxcb1 libxcomposite1 libxcursor1 libxdamage1 libxext6 libxfixes3 libxi6 libxrandr2 libxrender1 libxss1 libxtst6 ca-certificates fonts-liberation libappindicator1 libnss3 lsb-release xdg-utils wget\n\n> sudo apt update\n\n> sudo apt --fix-broken install","src/content/docs/fe/pre-render.mdx","ed544df3a2441b8e","fe/react-auto-batch",{"id":324,"data":326,"body":331,"filePath":332,"digest":333,"deferredRender":15},{"title":327,"editUrl":15,"head":328,"template":17,"sidebar":329,"pagefind":15,"draft":19},"React Auto Batching",[],{"hidden":19,"attrs":330},{},"# React18 Auto Batching\n\nReact18 에서 더 많은 배칭을 통해 별도의 수동 배칭을 하지 않고도 성능 개선을 바로 누릴 수 있다.\n\n이전에는 배칭이 어떻게 동작했는지, React 18에서 어떻게 개선됐는지 알아봅니다.\n\n## What is Batching? (배칭이란?)\n\nReact가 더 나은성능을 위해, 여러개의 state 업데이트를 하나로 묶는다.\n\n아래의 예시처럼, 하나의 클릭 이벤트 안에 두 개의 state 업데이트를 가지고 있다면, 이 작업을 배칭하여 하나의 리렌더링으로 만들었다.\n\n다음과 같은 코드를 실행해보면, 매 번 누를 때마다, state를 두 번 변경하였지만, 한 번의 렌더링만 한 것을 볼 수 있다.\n\n[Demo](https://codesandbox.io/s/spring-water-929i6?file=/src/index.js)\n\n\n```js\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [flag, setFlag] = useState(false);\n\n  function handleClick() {\n    setCount(c => c + 1); // Does not re-render yet\n    setFlag(f => !f); // Does not re-render yet\n    // React will only re-render once at the end (that's batching!)\n  }\n\n  console.log('render');\n\n  return (\n    \u003Cdiv>\n      \u003Cbutton onClick={handleClick}>Next\u003C/button>\n      \u003Ch1 style={{ color: flag ? \"blue\" : \"black\" }}>{count}\u003C/h1>\n    \u003C/div>\n  );\n}\n```\n\n\n이 과정은 불필요한 연산(리렌더링)을 줄이기때문에 성능에 이득이 있다.\n\n그리고 컴포넌트가 \"half-finished\" state를 렌더링하는 것을 방지할 수 있다.\n\n(위 예시에서, count가 +1 됐지만, flag는 아직 true로 바뀌지않은 상태)\n\n이것은 레스토랑 웨이터에 비유를 하면 더 쉽게 와닿을 수 있는데,\n\n주문을 할 때 하나 고를 때마다 주방으로 달려가지 않고, 오더를 완성시킬 때까지 대기하는 것과 비슷하다.\n\n기존에 React는 클릭과 같은 브라우저 이벤트에서만 업데이트를 배칭했었고,\n\n아래 경우에 fetch 콜백에서 이벤트 핸들링이 완료된 이후에 state를 업데이트하기 때문에 배칭이 적용되지 않는다.\n\n[Demo](https://codesandbox.io/s/trusting-khayyam-cn5ct?file=/src/index.js)\n\n```js\nfunction App() {\n  const [count, setCount] = useState(0);\n  const [flag, setFlag] = useState(false);\n\n  function handleClick() {\n    fetchSomething().then(() => {\n      // React 17 and earlier does NOT batch these because\n      // they run *after* the event in a callback, not *during* it\n      setCount(c => c + 1); // Causes a re-render\n      setFlag(f => !f); // Causes a re-render\n    });\n  }\n\n  return (\n    \u003Cdiv>\n      \u003Cbutton onClick={handleClick}>Next\u003C/button>\n      \u003Ch1 style={{ color: flag ? \"blue\" : \"black\" }}>{count}\u003C/h1>\n    \u003C/div>\n  );\n}\n```\n\n\nReact 18 이전까지, React 이벤트 핸들러 내부에서 발생하는 업데이트만 배칭을 하였다.\n\nPromise, setTimeout, native event handler 그리고 여타 모든 이벤트 내부에서 발생하는 업데이트들은 React에서 배칭되지 않았다.\n\n## What is automatic batching? (자동 배칭이란?)\n\nReact 18의 ```createRoot```를 통해, 모든 업데이트들은 어디서 왔는가와 무관하게 자동으로 배칭되게 된다.\n\n(React 18 + ```legacy render```는 여전히 auto batching을 수행하지 않는다.)\n\n이를 통해 렌더링 횟수를 줄이고, 앱의 성능을 조금 더 끌어올릴 수 있다.\n\n[React18 with ```createRoot``` Demo](https://codesandbox.io/s/morning-sun-lgz88?file=/src/index.js)\n\n[React18 with ```legacy render``` Demo](https://codesandbox.io/s/jolly-benz-hb1zx?file=/src/index.js)\n\n자동 배칭을 하고싶지않다면 ```ReactDOM.flushSync()```을 사용하면 된다.\n\n```js\nimport { flushSync } from 'react-dom'; // Note: react-dom, not react\n\nfunction handleClick() {\n  flushSync(() => {\n    setCounter(c => c + 1);\n  });\n  // React has updated the DOM by now\n  flushSync(() => {\n    setFlag(f => !f);\n  });\n  // React has updated the DOM by now\n}\n```\n### Hook을 사용할 때 이슈?\n\nhook을 사용한다면, 거의 모든 경우에 있어 자동 배칭은 아무 이슈 없을 것이다. (있으면 버그..?)\n\n### Class를 사용할 때 문제가 생길 수 있을까?\n\nReact의 이벤트 핸들러는 항상 배칭하므로 이러한 업데이트에는 변경 사항이 없다.\n\n하지만 문제가 생길 수 있는 예외 케이스가 존재하는데,\n\nClass Component에는 이벤트 내부에서 state 업데이트된 값을 동기적으로 읽을 수 있는 구현 특성이 있었다.\n\n그 뜻은.. setState 호출 사이에 state 변화 값을 읽을 수 있었다.\n\n```js\nhandleClick = () => {\n  setTimeout(() => {\n    this.setState(({ count }) => ({ count: count + 1 }));\n\n    // { count: 1, flag: false }\n    console.log(this.state);\n\n    this.setState(({ flag }) => ({ flag: !flag }));\n  });\n};\n```\n\nReact 18에서 이건 더 이상 동작하지 않는다. \n\n```setTimeout``` 안에 있는 모든 업데이트도 배칭되기 때문에 더 이상 첫 번째 setState의 결과를 동기적으로 렌더링하지 않는다.\n\n렌더링은 다음 브라우저 tick상에서 발생하게되기에 렌더가 아직 수행되지 않은 상태로 남는다.\n\n```js\n// { count: 1, flag: false } \n// React18 => { count: 0, flag: false }\n```\n\n이 케이스때문에 React18로 업그레이드를 못한다면 위에서 설명한 ```ReactDOM.flushSync()```를 쓰면 된다.\n\n물론 최대한 사용하지 않는 것을 추천.\n\nuseState에서 state 변경은 기존 값을 업데이트하지 않기에 Hooks를 가진 함수형 컴포넌트는 이 이슈에 영향을 받지 않는다.\n\n## unstable_batchedUpdates\n\nSome React libraries는 event handlers 바깥의 setState가 배칭되는 것을 강제하기 위해 도큐먼트에도 없는 API를 사용하고 있다.\n\n\n```js\nimport { unstable_batchedUpdates } from 'react-dom';\n\nunstable_batchedUpdates(() => {\n  setCount(c => c + 1);\n  setFlag(f => !f);\n});\n```\n\n이 API는 React 18에서도 존재할 것이지만, 배칭이 자동으로 동작하기에 사실 더 이상 필요는 없다.\n\n18 버전에서 없앨 예정은 아니고, 향후에 메이저 라이브러리들이 이 API 사용을 지우고난 뒤에 주요 버전 업데이트에서 없앨 예정이다.\n\n---\n\nref: https://github.com/reactwg/react-18/discussions/21\n\nhttps://immigration9.github.io/react/2021/06/12/automatic-batching-react.html","src/content/docs/fe/react-auto-batch.mdx","ac2cea84c04ba44b","fe/proxy",{"id":334,"data":336,"body":341,"filePath":342,"digest":343,"deferredRender":15},{"title":337,"editUrl":15,"head":338,"template":17,"sidebar":339,"pagefind":15,"draft":19},"proxy",[],{"hidden":19,"attrs":340},{},"# Proxy\n\n첫번째 예제\n\n```js\nvar arrayChangeHandler = {\n  get: function(target, property) {\n    // console.log('getting ' + property + ' for ' + target);\n    // property is index in this case\n    return target[property];\n  },\n  set: function(target, property, value, receiver) {\n    console.log('setting ' + property + ' for ' + target + ' with value ' + value);\n    target[property] = value;\n    // you have to return true to accept the changes\n    return true;\n  }\n};\n\nvar originalArray = [];\nvar proxyToArray = new Proxy( originalArray, arrayChangeHandler );\n\nproxyToArray.push('Test');\nconsole.log(proxyToArray[0]);\n\n// pushing to the original array won't go through the proxy methods\noriginalArray.push('test2');\noriginalArray.boseok = 'new val';\n\n// the will however contain the same data, \n// as the items get added to the referenced array\nconsole.log('Both proxy and original array have the same content? ' \n  + (proxyToArray.join(',') === originalArray.join(',')));\n\n  console.log(proxyToArray);\n```\n\n-----------------\n\n두번째 예제\n\n```js\nvar handler = {\n  get: function (target, property) {\n    // console.log('getting ' + property + ' for ' + target);\n    // property is index in this case\n    return target[property];\n  },\n  set: function (target, property, value) {\n    target[property] = value;\n    // you have to return true to accept the changes\n    return true;\n  }\n};\n\nthis.test = 'test old val';\nvar origin = { boseok: 'old val', test: this.test };\nvar proxy = new Proxy(origin, handler);\n\norigin.boseok = 'new val';\nthis.test = 'test new val';\n// proxyToArray.push('Test');\n// console.log(proxyToArray[0]);\n\n// // pushing to the original array won't go through the proxy methods\n// originalArray.push('test2');\n// originalArray.boseok = 'new val';\n\n// // the will however contain the same data, \n// // as the items get added to the referenced array\n// console.log('Both proxy and original array have the same content? ' \n//   + (proxyToArray.join(',') === originalArray.join(',')));\n\nconsole.log(proxy, 'origin', origin);\n```","src/content/docs/fe/proxy.mdx","67871c144d554fed","fe/react-hook-test-jest",{"id":344,"data":346,"body":351,"filePath":352,"digest":353,"deferredRender":15},{"title":347,"editUrl":15,"head":348,"template":17,"sidebar":349,"pagefind":15,"draft":19},"React Hook Test with Jest",[],{"hidden":19,"attrs":350},{},"# React Hook Test with Jest\n\nJest와 react-testing-library를 사용하여 비즈니스 로직이 포함된 훅을 간편하게(?) 테스트합니다.\n\nhook test code를 작성하여 앱 안정성을 보장하려면, 컴포넌트는 하나의 커스텀 훅을 가져야하며,\n\n그 커스텀훅에 해당 컴포넌트의 로직이 모두 포함되어있어야 합니다. 내부에서는 또 다른 훅이 존재하겠죠.\n\n(그리고 템플릿엔 로직이 없어야합니다.)\n\n커스텀 훅에서 리턴된 \"모델\"을 기반으로 컴포넌트 UI에 붙이기만하면, \"모델렌더\"를 달성할 수 있습니다.\n\n반대로 뷰모델이 분리 안됐다면 테스트코드를 작성하기 힘들어집니다.\n\nUI는 우리가 설계한 모델을 기반으로 동작할것이고, 모델과 UI가 확실히 분리되어있어 유지보수하기 좋은 구조입니다.\n\nUI는 따로 테스트하거나 스토리북으로 커버하세요.\n\n## 테스트할 hook\n\n테스트하려는 훅 내부에 useContext와 백엔드 API 호출이 섞여있는 경우를 가정하고 작성해봤습니다.\n\ndata는 가상의 App 컴포넌트가 렌더링되면 API를 통해 내려오는 좋아요 관련 데이터입니다.\n\n```js\nconst useProductLike = ({ data }) => {\n  const { prdNo } = useContext(ProductContext);\n  const [count, setCount] = useState\u003Cnumber>(0);\n  const [isLiked, setIsLiked] = useState(false);\n\n  const onClickLike = useCallback(() => {\n    setIsLiked((prev) => !prev);\n    likeProductAPI({\n      prdNo,\n      isRemove: isLiked,\n    }).then(({ likeCount }) => {\n      setCount(likeCount);\n    });\n  }, [isLiked, prdNo]);\n\n  useEffect(() => {\n    setCount(Number(data?.likeCount ?? 0));\n  }, [data?.likeCount]);\n  useEffect(() => {\n    setIsLiked(data?.like);\n  }, [data?.like]);\n\n  return { count, isLiked, onClickLike };\n};\n```\n\n## 테스트코드\n\n아래에서는 상품에 좋아요~ 하는 기능을 담당하는 훅을 테스트합니다.\n\n우선 훅 내부에서 호출하는 api를 포함하는 디렉토리를 import합니다.\n\n```js\nimport * as api from '~/apis';\n```\n\n그리고 그 디렉토리(user module)를 mocking합니다.\n\n```js\njest.mock('~/apis', () => ({\n  likeProduct: jest.fn(() => Promise.resolve({ likeCount: 100 })),\n}));\n```\n\n테스트코드에는 서버 API를 직접 호출하는 부분이 있으면 안됩니다.\n\n서버 API는 서버에서 테스트해야죠.\n\n우리의 테스트는 서버 API 결과와 상관없이 독립적으로 동작해야합니다.\n\n그리고 테스트할 훅에서 해당 API가 호출됐는지, 그 후에 훅이 의대로한대로 업데이트 됐는지 확인합니다.\n\n@testing-library/react 패키지를 import합니다.\n\n```js\nimport { renderHook } from '@testing-library/react-hooks';\n\nimport * as api from '~/apis';\n\njest.mock('~/apis', () => ({\n  likeProduct: jest.fn(() => Promise.resolve({ likeCount: 100 })),\n}));\n\nconst productMock = {\n  // ...생략\n  like: {\n    likeCount: 1,\n    like: false,\n  }\n}\n\ndescribe('hook testing', () => {\n  it('useProductLike hook', async () => {\n    // hook의 props는 아래와 같이 설정해야한다\n    const { result, waitForNextUpdate, rerender } = renderHook(\n      (initialProps: any) => useProductLike(initialProps),\n      { initialProps: { data: productDetailMock.like } },\n    );\n\n    // productMock.like의 데이터 => useProductLike에서 가공하여 반환된 결과들\n    expect(result.current?.isLiked).toEqual(false);\n    expect(result.current?.count).toEqual(1);\n\n    // hook 내부에서 likeProduct 함수를 호출하는지 감시할 수 있다.\n    const spy = jest.spyOn(api, 'likeProduct');\n    // 좋아요에 해당하는 함수 호출\n    result.current?.onClickLike();\n    // 렌더링 업데이트를 기다린다\n    await waitForNextUpdate();\n    // hook 내부에서 likeProduct 함수를 호출했는지 체크\n    expect(spy).toHaveBeenCalled();\n    // likeProduct 함수 호출 후 의도한대로 상태가 변경됐는지 확인\n    expect(result.current?.isLiked).toEqual(true);\n    expect(result.current?.count).toEqual(100);\n    // useEffect hook들을 테스트하기 위해 리렌더\n    rerender({ data: { like: true, likeCount: 10 } });\n    expect(result.current?.isLiked).toEqual(true);\n    expect(result.current?.count).toEqual(10);\n  });\n});\n```\n\n#### 마지막으로..\n\n이직했는데, 엄청 큰 프로젝트인데도 테스트코드가 하나도 없는 경우가 있어요... 제 얘기 맞습니다 ㅋㅋ\n\n잘 쪼개지지 않은 큰 모듈을 테스트할 때, 테스트코드에 필요없는 모듈들에게서 일어나는 황당한 에러들을 많이 겪을 수 있습니다.\n\n(큰 모듈엔 많은 import 구문이 있을텐데, 테스트코드에서 사용하지않는 친구들의 코드도 다 실행됩니다)\n\n이럴땐 모듈 내부에서 사용하지않는, 내가 테스트할 코드에서 쓸모없는 모듈들을 무시하기 위해 mocking 해버립니다.\n\n```\njest.mock('@/components/useless', () => null);\n```\n\n---\n## 또 다른 예제\n\n```ts\n// 테스트용도의 최소한의 useFetch hook 구현체\nexport const useFetch = \u003CT = any>({\n  url = '',\n  autoFetch = true,\n  method = 'get',\n}) => {\n  const [data, setData] = useState\u003CT | null>(null);\n  const [isLoaded, setIsLoaded] = useState\u003Cboolean>(false);\n\n  const fetchData = useCallback(() => {\n    if (url) {\n      httpRequest(url)\n        [method]()\n        .then((res) => {\n          setData({ ...res, isLoaded: true });\n        })\n        .finally(() => {\n          setIsLoaded(true);\n        });\n    }\n  }, [url, method]);\n\n  useEffect(() => {\n    if (autoFetch && !data) {\n      fetchData();\n    }\n  }, [autoFetch, data, fetchData]);\n\n  return { data, isLoaded, fetchData };\n};\n```\n\n```js\nimport * as api from '~/apis';\n\n// httpRequest 객체를 mocking 해줍니다.\njest.mock('~/apis', () => ({\n  httpRequest: jest.fn(() => ({ get: () => Promise.resolve() })),\n}));\n\n\ndescribe('useFetch', () => {\n  // url이 없으면 호출하지않습니다.\n  it('useFetch empty string api => not fetch', async () => {\n    const { result } = renderHook(() => useFetch({ url: '' }));\n    expect(result.current?.data).toEqual(null);\n    const spy = jest.spyOn(api, 'httpRequest');\n    expect(spy).toHaveBeenCalledTimes(0);\n  });\n\n  it('useFetch', async () => {\n    const { result, waitForNextUpdate } = renderHook(() =>\n      useFetch({ url: 'some' }),\n    );\n\n    //처음엔 data의 초기값인 null이어야합니다.\n    expect(result.current?.data).toEqual(null);\n    await waitForNextUpdate(); // effect를 기다렸다가,\n    // 데이터 로드가 끝남을 확인\n    expect(result.current?.data).toEqual({ isLoaded: true });\n\n    // 데이터 로드가 끝났으므로, httpRequest는 1번 호출되어야함\n    const spy = jest.spyOn(api, 'httpRequest');\n    expect(spy).toHaveBeenCalledTimes(1);\n    // 의도적으로 다시 fetch 함수 호출\n    result.current?.fetchData();\n    await waitForNextUpdate();\n    // httpRequest가 한번 더 호출됐는지 확인\n    expect(spy).toHaveBeenCalledTimes(2);\n  });\n});\n```\n\n---\n\n## jest spyOn\n\njest의 spy기능은 테스트코드를 더욱 정교하게 만들 수 있도록 도와줍니다.\n\njest.fn와 유사하지만, 테스트코드에서 mocking된 함수 호출을 감시할 수 있습니다.\n\n다만 위의 useFetch 예시 2개의 테스트의 순서가 바뀔경우 에러가 발생할 수 있는데,\n\n```js\nconst spy = jest.spyOn(api, 'httpRequest');\nexpect(spy).toHaveBeenCalledTimes(1);\n```\n\n바로 이 부분을 주의해야합니다.\n\nspyOn이 작동할때, 인스턴스가 아닌 내부 변수에 호출 횟수가 캐싱됩니다.\n\n그래서 다른 테스트 케이스에서 spyOn의 대상이 되는 함수가 호출됐다면,\n\n또 다른 테스트케이스에서 해당 함수를 호출하지않아도 호출횟수가 0이 아닐 수 있습니다.\n\n## renderHook => result\n\n위의 useFetch에서 짚고 넘어가야하는 부분이 있습니다.\n\n```ts\nconst { result, waitForNextUpdate } = renderHook(() =>\n  useFetch({ url: 'some' }),\n);\nconst { data } = result.current ?? {};\n```\n\n이렇게 data를 destructuring 하고싶은 유혹이 드는데요,\n\n그 전에 잘 생각해봐야합니다. 왜 result.current 인지.\n\nhook 내부의 StateUpdater가 호출되면, result.current.data의 레퍼런스가 변경이 됩니다.\n\n하지만 분해해버리면, StateUpdater 실행되고 나서도 실행전의 레퍼런스가 유지됩니다.\n\n그래서 hook update 하고나서의 값이 반영되질않죠.\n\n사실 이걸 써놓은 이유는 custom hook에서 배열을 리턴하는게 테스트코드의 가독성을 떨어지게 만든다는겁니다.\n\n보세요.\n\n```js\nexpect(result.current?.[0]).toBe(1)\n```\n\n요런식이 되겠쥬? 그나마 이건 괜찮은데.. 함수인 경우는?\n\n```js\nresult.current?.[1](1, 0)\nresult.current?.[1](2, 0)\n```\n\n정말 이대로 괜찮을까요? 저는 useState처럼 이름을 정말 마음대로 자유롭게 짓고 싶은 경우가 아니라면..\n \n테스트코드를 위해서라도 훅에서 배열 리턴하지않고 객체 리턴하겠습니다.\n\n# it, test\n\nit은 test의 alias입니다. 아무거나 편한거 쓰세요.\n\n# act, waitForNextUpdate\n\n우선 첫번째 act는 react testing library의 기능이 아닌, react-dom/test-utils 패키지에 포함된 기능입니다.\n\n반면 waitForNextUpdate는 renderHook의 인스턴스 메소드입니다.\n\n훅 내부에 useEffect를 사용하는 경우입니다.\n\n간단한 예시를 들자면,\n\n```js\nconst useSomeHook = () => {\n  const [data, setData] = useState(0);\n\n  useEffect(() => {\n    setData(1);\n  }, []);\n\n  return data;\n}\n\ndescribe('useSomeHook', () => {\n  it('useSomeHook', async () => {\n    const { result, waitForNextUpdate } = renderHook(() => useSomeHook());\n    expect(result.current?.data).toBe(0);\n    await waitForNextUpdate();\n    expect(result.current?.data).toBe(1);\n  });\n});\n```\n\n위 예시는 act로 커버하기 어렵습니다.\n\nStateUpdater => waitForNextUpdate\n\nDOM Update => act\n\nDOM Update의 예를 들자면.... history.pushState 등이 있겠쥬?\n\n## waitForNextUpdate에서 jest timeout 떨어지는 경우\n\n```bash\nTimeout - Async callback was not invoked within the 5000 ms timeout specified by jest.setTimeout.Timeout - Async callback was not invoked within the 5000 ms timeout specified by jest.setTimeout.Error:\n```\n\n이 경우는 보통 API등의 함수를 mocking해놓고, 반환값이 제대로 안떨어져서\n\nStateUpdater가 실행이 안되는 경우입니다.\n\n혹은 비동기함수가 기본타이머 세팅인 5000ms보다 느리게 수행되는경우겠지요\n\n이럴땐 타이머를 더 늘려주면 됩니다.\n\n가짜 비동기 함수를 만들었다면.. 그 비동기함수를 더 빨리 수행되도록 변경해도 괜찮고요.","src/content/docs/fe/react-hook-test-jest.mdx","16fdf2e47071c3ae","fe/react-native",{"id":354,"data":356,"body":361,"filePath":362,"digest":363,"deferredRender":15},{"title":357,"editUrl":15,"head":358,"template":17,"sidebar":359,"pagefind":15,"draft":19},"React-native",[],{"hidden":19,"attrs":360},{},"# react-native\n\n## react-native 기본\n\nreact-native는 react기반으로 소스코드를 작성하고, 한번에 여러가지 모바일 플랫폼으로 빌드할 수 있다. 그래서 생산성이 엄청나다.\n\n심지어 네이티브로 빌드된다. 웹뷰기반의 하이브리드앱보다는 당연히 성능이 좋다.\n\n하지만 네이티브로 동작하기위해 브릿지를 사용하므로 네이티브보다는 앱 크기가 크고 더 느리다.\n\n성능: native app > react-native app > webview 기반 hybrid app\n\n생산성: 성능과 반대\n\n한마디로 react-native를 사용하면 네이티브를 몰라도 가능하지만...\n\n앱이 커지거나 복잡해져서 라이브러리에서 네이티브 기능을 커스터마이징 할 일이 생긴다면 결국은 네이티브를 알아야한다는 단점 또한 존재한다.\n\nreact native는 nodejs환경에서 간단한 명령어로 프로젝트를 생성할 수 있다.\n\n```bash\nnpm install -g react-native-cli\nreact-native init 프로젝트이름\n```\n\n### 안드로이드\n\n빌드하기전에..\n\n안드로이드 sdk매니저를 통해 현 react-native에 맞는 sdk버전을 설치해줘야한다.\n\n#### 실제 디바이스를 연결하는 경우\n\n1. 실제 디바이스를 개발pc에서 인식할수있도록 드라이버를 설치한다.\n2. 안드로이드 기기를 연결한다.\n\n#### 가상 디바이스로 연결하는 경우\n\n1. 안드로이드의 avd를 통해 가상디바이스를 생성하고 실행한다.\n\n디바이스를 연결했다면 터미널 - 프로젝트가 있는곳\n\n```bash\nreact-native run-android\n```\n\n명령어를 실행하면 연결된 디바이스에서 앱이 자동으로 실행된다.\n\n### IOS\n\n1. app store에서 xcode설치\n2. ios 에뮬레이터 실행\n3. 명령어 실행\n\n   ```bash\n   react-native run-ios\n   ```\n\n## APK 생성\n\n1. Debug 버전 빌드\n\n   ```bash\n   react-native bundle --dev false --platform android --entry-file index.android.js --bundle-output ./android/app/build/intermediates/assets/debug/index.android.bundle --assets-dest ./android/app/build/intermediates/res/merged/debug\n   ```\n\n   ```bash\n   cd android && ./gradlew assembleDebug && cd ..\n   ```\n\n2. Release버전 빌드 - android-app build.gradle에서 버전관리\n\n```bash\ncd android && ./gradlew assembleRelease && cd ..\n```\n\n_**run method**_\n\n```bash\nreact-native run-android --variant=release\n```\n\nGenerated apk will be located at android/app/build/outputs/apk P.S. Another approach might be to modify gradle scripts.\n\n## 기본 사용방법\n\nreact-native\\(이하 RN\\)은 reactJS기반의 문법-JSX를 따른다.\n\n```javascript\nexport default class HelloWorldApp extends Component {\n  render() {\n    return (\n      \u003CText>Hello world!\u003C/Text>\n    );\n  }\n}\n```\n\nreact에서 사용하는 문법\n\n마치 html, 혹은 xml태그와 비슷해보이는 JSX문법이다.\n\nJSX는 ES6으로 작성된다.\n\n### Data Fetching\n\n서버에서 데이터를 가져와야할일이 생기면,\n\n[fetch api](https://github.com/jewelism/boseok-note/tree/955b71efb6653d12b51fe12bb7c6883cc9155ab9/javascript/es6/fetch)를 사용하면 된다.\n\n물론 axios같은 라이브러리도 가능하다.\n\n### 스타일적용하기\n\n사실 버전업이 자주되어서 지금은 어떨지는 모르겠지만,\n\n이 글을 작성하던 2017년 7월즈음에 사용하던 방법이다. \\(rn v0.4\\)\n\n#### 스타일 2개 적용하기\n\n```javascript\nstyle={[styles.styleOne, styles.styleTwo]}\n```\n\n이런식으로 스타일에 배열을 끼워넣으면 된다.\n\n이 경우의 우선순위가 배열에서 가장 뒤에있는 스타일이 적용된다.\n\n버전업으로 동작하지않는다면..\n\nObject.assign을 이용하면 될것같다.\\(추측\\)\n\n```javascript\nstyle={Object.assign({}, styles.styleOne, styles.styleTwo)}\n```\n\n### 터치 제어 관련\n\nView 컴포넌트의 attr중에 pointerEvents='none'으로 설정해놓으면 그 뷰의 터치가 불가능해진다.\n\n가능하게하고 싶으면 null로 지정하면된다.\n\n```javascript\npointerEvents={this.state.enable}\n```\n\n```javascript\nthis.state = {\n  Enable: null,\n}\n```\n\n```javascript\n() => this.setState({enable:'none'})\n```\n\n### Image Source\n\n네이티브와 마찬가지로 같은폴더내에 user.png user@2x.png user@3x.png가 있다면\n\n```javascript\nimport userImg from '경로/user.png'\n```\n\n해주면 해상도 크기에 맞는 이미지가 자동으로 삽입된다\n\n### 네이티브기능을 사용하는 라이브러리?\n\n네이티브 기능을 사용하는 라이브러리라면,\n\nios는 cocoapods를 사용하면 되고, 안드로이드는 gradle을 사용하면 된다.\n\n그 외에 라이브러리는 npm으로.\n\n### 유용한 라이브러리 15가지\n\n[https://codingislove.com/top-15-react-native-libraries/](https://codingislove.com/top-15-react-native-libraries/)","src/content/docs/fe/react-native.mdx","e9d17c63c3ea2ec9","fe/react-tutorial",{"id":364,"data":366,"body":371,"filePath":372,"digest":373,"deferredRender":15},{"title":367,"editUrl":15,"head":368,"template":17,"sidebar":369,"pagefind":15,"draft":19},"React Tutorial",[],{"hidden":19,"attrs":370},{},"# React Tutorial\n\n## 개발환경 설정\n\n맥은 무조건 homebrew 이용하세요.\n\n### 1. node.js 설치하기\n\n[https://nodejs.org/ko/](https://nodejs.org/ko/)\n\n### 2. 텍스트에디터 설치하기\n\n[vscode](https://code.visualstudio.com/)\n\nvscode extensions - ESLint 설치\n\nvscode settings.json 편집하기 - command+shift+p - open setting 타이핑 - 엔터\n\n아래는 제 설정의 일부분입니다\n\n```json\n{\n  \"editor.tabSize\": 2,\n  \"editor.fontSize\": 13,\n  \"editor.codeActionsOnSave\": {\n      \"source.fixAll.eslint\": true\n  },\n}\n```\n\n### 3. 프로젝트 생성\n\n튜토리얼 이므로\n[create-react-app](https://create-react-app.dev/docs/getting-started/)\n를 활용합니다.\n\n가이드를 따라하고, vscode에서 해당 디렉토리를 open해줍니다.\n\n---\n\n## 살펴보기\n\nreact앱을 개발하려면 최소한 자바스크립트 기본 문법을 알고 있어야합니다.\n\n그리고 react나 컴포넌트 등의 개념을 알고있는게 시작하는게 중요한데,\n\n그것은 [여기서](/fe/component) 모두 설명하고 있습니다.\n\n시작부터 모두 이해하려고 하지말고, 컴포넌트까지만 간단하게 읽어보세요.\n\n### index.js\n\nvscode로 프로젝트를 열고, src를 열어보면 index.js가 보입니다.\n\n```js\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  \u003CReact.StrictMode>\n    \u003CApp />\n  \u003C/React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n```\n\n이 프로젝트 코드상에서 index.js가 시작점입니다. 프로젝트가 실행의 시작점을 엔트리 포인트라고 합니다.\n\n우리가 개발한 앱이 실행되면, 이런 코드들이 실행되는거네요.\n\n분명 자바스크립트 파일인데, ```\u003CApp />``` 같은 특이한 문법이 보입니다.\n\n저런 문법을 JSX라고 합니다.\n\n### JSX\n\njavscript extension의 약어입니다.\n\n자바스크립트의 확장문법이라는 뜻이죠\n\njsx를 해석하기위해서는 babel이라는 트랜스파일링을 전문적으로 하는 친구의 도움을 받아야합니다.\n\n돌아와서, jsx로 작성한 문법을 간단하게 먼저 봅시다.\n\n```js\n\u003Cdiv onClick={() => alert('?')} className=\"some_class\" />\n```\n는 아래와 같이 트랜스파일링됩니다.\n```js\nReact.createElement('div', { onClick: () => alert('?'), className: \"some_class\" }, null);\n```\ncreateElement 함수로 작성을 하면 가독성이 안 좋기 때문에, 보통 jsx 문법으로 ReactNode를 작성합니다.\n\n### ReactDOM.render\n\n이제 index.js로 돌아와서, ReactDOM.render 부분을 볼까요?\n\nReact와 ReactDOM은 import 구문을 보면 추측할 수 있듯이, 별도의 패키지(라이브러리)로 분리되어있습니다.\n\n첫번째 파라미터로는 Jsx구문이 들어가있고, 두번째 파라미터는 querySelector가 들어가있죠?\n\njsx구문으로 생성한 React 가상DOM을 두번째 파라미터의 element에 그리겠다는 의미입니다.\n\n### React를 배우기 전 최소한의 선행 학습\n\n가장 중요한건 당연히 자바스크립트를 다루는 능력입니다\n\n문법도 모르는 상태라면 아예 개발하기 어려운 수준이고요.\n\n위에서 설명한것처럼 Jsx도 사실 자바스크립트입니다.\n\n두번째는 querySelector같은 DOM API입니다.\n\n바닐라(순수한) 자바스크립트로 DOM을 직접 제어할일은 없지만,\n\nDOM 개념은 있어야 개발하기 수월합니다.\n\n그래도 DOM 개념정도는 개발하면서 익혀도 아~주 큰 무리는 없습니다.\n\n그리고 브라우저에 대해 많이 알수록 좋습니다.\n\n## 실은..\n\n리액트 개발은 이게 대부분입니다..\n\n함수형 컴포넌트 + react hook API 로 개발하시면 됩니다.\n\n클래스형 컴포넌트는 필요하면 그때가서 익혀도 늦지않습니다.\n\n신규 개발을 클래스형 컴포넌트로 하는건 바보짓이라고 말씀드리고 싶네요.\n\nhook API는 클래스형 컴포넌트의 문제점을 해결하기위해 등장했습니다.\n\n기존의 라이프사이클 API의 문제를 아름답게 해결하는게 목표였지만,\n\n다소 어렵습니다. 개념이 달라져서요.. 그래서 많은 질타를 받고있기도 하죠.\n\n그래도 vue에서 새로 도입한 composition API도 hook API와 같은 컨셉을 갖고 있습니다.\n\n그럼 답이 나왔죠? 선택은 여러분의 몫이지만, 저는 클래스형 컴포넌트를 절대 쓰고 싶지 않습니다.\n\n## 첫번째 리액트 컴포넌트\n\n그럼 간단하게라도 뭔가 개발해봐야겠죠?\n\n튜토리얼에 가장 많이 활용하는 카운터를 개발해보겠습니다.\n\nsrc/components/Counter.js 라는 이름으로 파일을 하나 생성하세요\n\n```js\nconst Counter = () => {\n  const count = 0;\n  return (\n    \u003Cdiv>\n      Count: {count}\n    \u003C/div>\n  );\n}\n\nexport default Counter;\n```\n\nApp.js에 Counter를 import 합니다.\n\n필요없는 내용은 지워버리고 카운터만 남겨둡시다.\n\n```js\n// ...\nimport Counter from './Counter';\n\nfunction App() {\n  return (\n    \u003Cdiv className=\"App\">\n      \u003CCounter />\n    \u003C/div>\n  );\n}\n```\n\n```npm start``` 명령어로 개발서버를 시작합니다.\n\n브라우저에는 Count: 0 이라고 표시될 것 입니다.\n\n이제 버튼을 클릭했을때, 숫자를 늘리고 줄여봅시다.\n\nCounter.js를 수정합니다.\n\n```js\nconst Counter = () => {\n  const [count, setCount] = useState(0);\n\n  const countUp = () => {\n    setCount(count + 1);\n  }\n  \n  const countDown = () => {\n    setCount(count - 1);\n  }\n\n  return (\n    \u003Cdiv>\n      Count: {count}\n      \u003Cbutton onClick={countUp}>+\u003C/button>\n      \u003Cbutton onClick={countDown}>-\u003C/button>\n    \u003C/div>\n  );\n}\n\nexport default Counter;\n```\n\n변경사항을 저장하고, 브라우저에서 다시 확인해봅시다.\n\n```+``` ```-``` 버튼들이 잘 동작함을 확인합니다.\n\n이걸로 카운터 예제는 끝났다고 할 수도 있겠지만, 조금 더 살펴봅시다.\n\nCounter.js를 수정합니다.\n\n```js\n\nconst Counter = () => {\n  const [count, setCount] = useState(0);\n\n  const countUp = () => {\n    setCount(count + 1);\n  }\n  \n  const countDown = () => {\n    setCount(count - 1);\n  }\n\n  const countUp3 = () => {\n    setCount(count + 1);\n    setCount(count + 1);\n    setCount(count + 1);\n  }\n\n  return (\n    \u003Cdiv>\n      Count: {count}\n      \u003Cbutton onClick={countUp}>+\u003C/button>\n      \u003Cbutton onClick={countDown}>-\u003C/button>\n      \u003Cbutton onClick={countUp3}>+3\u003C/button>\n    \u003C/div>\n  );\n}\n```\n\n한번에 3을 더하는 로직과 버튼을 추가했습니다.\n\n잘 동작하나요?\n\n분명 count를 3번 더하는 의도인데.. 생각대로 동작하지않죠?\n\n이유는 setCount 함수가 비동기로 동작하기때문입니다.\n\nsetCount 함수가 동작한다고해서, 내부의 count 변수가 바로 변하지않아요.\n\n믿기지않을땐, 직접 확인해보세요.\n\n로그를 마구마구 찍어봅시다\n\n```js\nconst countUp3 = () => {\n  console.log(count);\n  setCount(count + 1);\n  console.log(count);\n  setCount(count + 1);\n  console.log(count);\n  setCount(count + 1);\n  console.log(count);\n}\n```\n\n첫번째 클릭땐 0이 4번, 두번째 클릭땐 1이 4번 찍힐겁니다.\n\n비동기라 함은 언제 동작할지 모릅니다.\n\n우리 눈에는 바로바로 반영되겠지만, 사실 저 숫자 하나 바꾸기 위한 과정들이 꽤나 복잡합니다.\n\n모든 과정을 지금 살펴보긴 어려우므로 우선 저걸 의대로한대로 동작할수있게 바꿔봅시다.\n\n```js\n// setCount(count + 1);\n// setCount(count + 1);\n// setCount(count + 1);\nsetCount(prevState => prevState + 1);\nsetCount(prevState => prevState + 1);\nsetCount(prevState => prevState + 1);\n```\n\n이런식으로 변경해줍니다.\n\nsetter 파라미터에는 함수도 가능한데,\n\n함수의 첫번째 파라미터로 변경 이전의 state가 넘어옵니다.\n\n그것에 +1을 더하면 비로소 우리가 원하는 동작을 할 수 있죠.\n\n이제 원하는대로 동작하죠?\n\n## CSR, SSR의 개념?\n\n간단하게 표현하면,\n\ncsr: 브라우저가 서버측에서 js파일을 다운받고, 그 자바스크립트를 실행하여 html 생성하여 렌더링\n\nssr: 서버측에서 html을 생성하고, 브라우저는 그것을 받아 렌더링\n\n[더 자세히는 여기서..](/fe/csr-ssr)\n\n\n## props\n\n자식 컴포넌트에 데이터를 전달할때 사용\n\n```js\nconst Hello = ({ name }) => {\n  return (\n    \u003Cdiv>hello~ {name}!\u003C/div>\n  );\n}\n```\n\n```js\n//App.js\n\nconst App = () => {\n  return (\n    \u003Cdiv>\n      \u003Cdiv>App\u003C/div>\n      \u003CHello name=\"world\" />\n    \u003C/div>\n  );\n}\n```\n\nHello 컴포넌트는 \u003Cdiv>hello~ world!\u003C/div> 를 렌더링하겠죠?\n\n예시에서는 문자열을 넘겼지만, 함수를 내려서 자식 컴포넌트에서 부모컴포넌트의\n\n함수를 호출하게 만드는 것도 가능합니다.\n\n부모의 setState 함수를 내려서, 자식에서 부모 컴포넌트의 상태를 바꿀 수 있겠죠?\n\n그리고 props에는 children이라는 약간 특별해보이는 props도 있습니다.\n\n```js\nconst Hello2 = () => {\n  return (\n    \u003Cdiv className=\"hello-1\">\n      \u003Cdiv className=\"hello-2\">\n        \u003Cdiv className=\"hello-3\">\n          {children}\n        \u003C/div>\n      \u003C/div>\n    \u003C/div>\n  );\n}\n\nconst App = () => {\n  return (\n    \u003Cdiv>\n      \u003Cdiv>App\u003C/div>\n      \u003CHello2>world\u003C/Hello2>\n    \u003C/div>\n  );\n}\n```\n```\u003CHello2>world\u003C/Hello2>``` 이 부분은...\n\n```html\n\u003Cdiv className=\"hello-1\">\n  \u003Cdiv className=\"hello-2\">\n    \u003Cdiv className=\"hello-3\">\n      world\n    \u003C/div>\n  \u003C/div>\n\u003C/div>\n```\n위처럼 렌더링됩니다. children을 어떻게 활용할 수 있을지 감이 오시나요?\n\n이처럼 간편하게 데이터를 자식컴포넌트로 내려줄 수 있습니다.\n\n하지만 반대로 자식이 부모 컴포넌트에게 데이터를 전달할수는 없습니다..\n\n어플리케이션이 커질수록 데이터의 흐름을 알기 어렵게 하거든요.\n\n이것을 단방향 데이터 플로우라고 합니다.\n\n## 배열 렌더링하기\n\njavascript array에는 map이라는 메소드가 있습니다.\n\n(유사배열이나 iterable객체에 map메소드를 사용하고 싶다면, Array.from 을 활용하시면 됩니다.)\n\nreact에서는 {}에 expression을 작성하죠?\n\n\\{렌더링하고싶은 배열.map}을 이용하여 배열을 렌더링 할 수 있겠죠.\n\n```js\nconst list = ['apple', 'banana', 'boseok'];\n\nconst Component1 = () => {\n  return (\n    \u003Cdiv>{list.map((item) => \u003Cdiv key={item}>{item}\u003C/div>)}\u003C/div>\n  );\n}\n\n// Component1 result\n\u003Cdiv>\n  \u003Cdiv>apple\u003C/div>\n  \u003Cdiv>banana\u003C/div>\n  \u003Cdiv>boseok\u003C/div>\n\u003C/div>\n```\n\n배열을 렌더링할땐 react에서는 \n```key```\n라는 속성을 이용하여 배열의 변경을 감지합니다.\n\nkey에는 map 콜백의 두번째 인자인 index를 사용하지 않을 것을 권장합니다.\n\n[자세한 내용은 여기서..](/fe/virtual-dom/#key)\n\n## Context API\n\nredux같은 구시대 유물은 이제 버리고, Context API를 쓰세요.\n\nreact팀에서도 Context를 권장하고 있습니다. 사실 react-redux도 Context 기반이기도 하고요.","src/content/docs/fe/react-tutorial.mdx","f6531e7b32099c8e","fe/react",{"id":374,"data":376,"body":381,"filePath":382,"digest":383,"deferredRender":15},{"title":377,"editUrl":15,"head":378,"template":17,"sidebar":379,"pagefind":15,"draft":19},"React",[],{"hidden":19,"attrs":380},{},"# React\n\n* facebook에서 만들고 활용하고 있는 ui 라이브러리\n\n핵심 개념인 컴포넌트는 [여기에서 설명](/fe/component)합니다.\n\n리액트는 ReactDOM 이라는 별도의 패키지의 render 메소드를 사용하여\n\nReact 컴포넌트를(VDOM) 실제로 DOM에 렌더링할 수 있습니다.\n\n## Hook API\n\nhook 혹은 hooking 이라는 용어는.. 프로세스를 가로채고 정상적인 프로세스를 방해 할 수 있다는 의미입니다.\n\nreact hook에서는 (과거 stateless로 사용했던) functional component에서도 상태를 가질 수 있으며\n\n라이프사이클을 대체할 수 있는 함수를 제공합니다. (useEffect)\n\n이제는 react개발의 핵심이 된 react 라이브러리의 최신 API입니다.\n\n## 사용 규칙\n\n1. 컴포넌트에서 훅을 호출하는 순서가 보장되어야한다.\n\n```\n순서가 보장되어야한다는 것은 제어구조 내에서 사용하지 말라는 것입니다.\n\n리액트 내부에서 관리하는, 훅을 위한 인덱싱이 깨질 수 있기 때문이죠.\n```\n\n2. 훅은 함수형 컴포넌트 혹은 커스텀 훅 안에서만 호출한다.\n\n3. use~ 로 네이밍한다. 에러는 아니지만 경고가 뜬다.\n\n## 근데 왜 이걸 사용하나?\n\n사실 가장 큰 단점은 props가 암묵적으로 넘어온다는점 입니다. hoc를 많이 사용하면 props 이름 충돌의 가능성도 배제할 순 없죠.\n\n함수형 컴포넌트에서 state를 사용하기위해 사용하는것도 맞지만,\n\n공통 비즈니스로직들을 사용하기위해 hoc를 활용했는데, 복잡해질수록 Wrapper가 늘어나기만하고..\n\nhoc를 여러개 중첩하면 보기도 힘들고, 어떤 hoc가 어떤 로직을 가졌는지 파악하기도 쉽지않고,\n\n여러개의 life cycle에 중복 로직도 들어가고, 로직들이 흩어지기도 하고.. 점점 복잡해지고 헷갈리며 테스트하기도 어려워집니다.\n\nvue의 경우에는 hoc와 비슷하면서도 다른 mixins를 이용해서 중복 로직을 처리하는데,\n\n같은 문제가 있어서 vue3에서 react hook에 영감을 받아 개발한 composition API를 공개했죠.\n\n아래에서는 가장 많이 사용하는 hook API 3개와 커스텀 hook을 소개합니다.\n\n---\n\n## useState\n\nuseState 훅은 기존 클래스형 컴포넌트의 state와 setState를 대체합니다.\n\nuseState 함수는 파라미터로 state초기값을 넘겨주고, 아래와 같이 배열을 리턴합니다.\n\n```js\nconst [state, setState] = useState(initialState);\n```\n\n배열의 두번째에 위치한 setState함수로 state를 변경 할 수 있습니다.\n\n또한 setter에 함수를 사용할 수도 있습니다.\n\n아래 코드는 단순 boolean을 toggle하는 함수를 활용하는 예시입니다.\n\n```js\n//typescript\nconst [flag, setFlag] = useState\u003Cboolean>(false);\n\nconst toggleFlag1 = () => setFlag(!flag);\nconst toggleFlag2 = () => setFlag((prevState) => !prevState);\n```\n\n장점이 전혀 없는것처럼 보일 수도 있지만..\n\nuseCallback으로 toggleFlag를 다시 작성하면..\n\n```js\n//typescript\nconst [flag, setFlag] = useState\u003Cboolean>(false);\n\nconst toggleFlag1 = useCallback(() => setFlag(!flag), [flag]);\nconst toggleFlag2 = useCallback(() => setFlag((prevState) => !prevState), []);\n```\n\ndeps에서 차이를 보이고 있습니다.\n\n가능하면 deps가 적을수록 좋습니다. deps중에 하나라도 변경되면, 해당 훅이 다시 실행됩니다.\n\n함수를 자주 새로 생성하는것을 줄이는건 성능에 거의 영향을 주지않지만 나름 의미도 있고,\n\n훅이 특정 상태에 의존성을 갖게 되는것이 중요하다고 할 수 있습니다.\n\n## useEffect\n\n기존 클래스 컴포넌트로는 생명주기 메소드를 이용했는데, 이제는 생명주기가 아닌 '상태'주기를 이용해야합니다.\n\n리액트 생명주기 메소드는 호출 타이밍이 정해져있죠. 고정된 파이프라인입니다.\n\n반면에 useEffect로 생성하는 상태주기 메소드는 프로그래밍 가능한 수많은 파이프라인입니다.\n\n이제 API호출해야하는 타이밍에 대해 의견이 엇갈 일 조차도 없습니다.\n\n상태주기를 다루고 있으므로, 각 훅의 deps에 의존성을 모두 추가하는것이 정상이며, 그렇게 해야합니다. eslint에 좋은 플러그인이 존재합니다.\n\nuseEffect를 여러번 사용해서, 기능별로 분리해놓으면 원하는 기능을 버그없이 구현할 수 있습니다.\n\n아래는 간단한 예제입니다.\n\n```js\nuseEffect(\n  () => {\n    //...some effect code\n    return () => {\n      // ...some clean up code\n    };\n  },\n  [\n    //deps\n  ]\n);\n```\n\n아래 코드처럼 props가 변경될때 state를 변경시키도록 할 수도 있습니다.\n\n```js\nconst SomeComponent = ({myInput}) => {\n  const [input, setInput] = useState('');\n\n  useEffect(() => {\n    setInput(myInput);\n  }, [myInput]); // setInput????\n}\n```\n\nsetInput은 왜 deps에 포함시키지않아도 될까요?\n\neffect는 deps 중에 하나라도 변경되면 trigger되는데요, setInput은 어차피 변하지않기때문입니다..!\n\n그러므로 변하지않는값은 넣지않아도 됩니다.\n\n아래에 헷갈릴 수도 있는 예제를 하나 추가합니다.\n\n```js\nconst SomeComponent = ({ a, b }) => {\n  const isNotZero = useMemo(() => a !== 0 && b !== 0, [a, b]);\n\n  useEffect(() => {\n    somePureFunction(a !== 0 && b !== 0);\n  }, [a, b]);\n\n  useEffect(() => {\n    somePureFunction(isNotZero);\n  }, [isNotZero]);\n}\n```\n\n두 개의 effect는 로직이 같습니다. 하지만 실행되는 횟수는 달라질 수 있습니다.\n\nisNotZero 는 a, b를 deps로 가지는데, 값은 true, false 중에 하나입니다.\n\n첫번째 effect는 a 혹은 b가 변경되면 실행될것이고\n\n두번째 effect는 isNotZero의 '값'(true, false)가 달라지면 실행될것입니다.\n\nisNotZero가 a, b가 달라져서 재계산하더라도, 결국 값이 달라지지 않았다면 effect가 실행되지 않습니다.\n\n## useMemo, useCallback\n\n용도 자체는 레퍼런스 변경을 방지하는 것 입니다.\n\n예를 들어, 상위 컴포넌트에서 props로 함수를 하위 컴포넌트에게 전달한다고 가정합니다.\n\n이때, 상위 컴포넌트 렌더링이 돌면, props로 넘겼던 함수의 레퍼런스가 변경됩니다.\n\n실제로 함수자체가 변경되지않았음에도 함수가 재생성되어 props가 변경됐다고 가정한 하위 컴포넌트는\n\n쓸데없이 리렌더될 수 있습니다.\n\nuseMemo는 값을 메모이제이션 한다는 특징이 있어서 비싼 연산을 기억하여 최적화 할 수도 있습니다.\n\n하지만 react 공식문서에서는 추후 업데이트에서 재계산을 할지도 모르니, 성능향상으로 쓰지말라고 가이드합니다.\n\n```js\nconst [myName, setMyName] = useState(\"boseok jung\");\n\nconst reversedMyName = useMemo(\n  () => Array.from(myName).reverse().join(\"\"),\n  [myName]\n);\n\nconsole.log(reversedMyName); // gnuj koesob\n```\n\n아래는 useMemo와 useCallback을 비교한 것입니다.\n\n사실 useCallback은 명시적으로 함수일것이다를 알 수 있는 것 외에는 useMemo와 동일하게 동작합니다.\n\n```js\nfunction someFunction() {\n  return \"boseok\";\n}\n\nconst memo = useMemo(() => someFunction, []);\nconst callback = useCallback(someFunction, []);\n```\n\n아래처럼 deps관리를 위해서라도 같은 deps를 가진 컴포넌트 변수(함수 포함)들이 있다면, 하나의 useMemo를 통해 변수들을 반환받는게 좋을것입니다.\n\n(곧 나오는 용어인 deps는 아래서 설명하고 있습니다.)\n\n```js\nconst [name, setName] = useState(0);\n\nconst [nameLength, reversedName] = useMemo(\n  () => [name.length, Array.from(name).reverse().join(\"\")],\n  [name]\n);\n\n// const nameLength = useMemo(() => name.length, [name]);\n// const reversedName = useMemo(\n//   () => name.length,\n//   Array.from(name)\n//     .reverse()\n//     .join(''),\n//   [name]\n// );\n```\n\n간단한 예제인데, 주석처럼 작성하면... 로직이 길고 복잡하다고 가정했을때 => 어떤 훅에 name dependency가 있는지 코드를 전부 파악해야하고, 수정하기 두렵습니다.\n\nuseCallback에 대해 조금 더 이야기 해보자면.. memo로 동일한 기능을 구현할 수 있어서 useCallback이 필요없을지도 모르겠지만\n\nuseCallback의 존재 이유는 변수인지 함수인지 구분하기 위함도 있고, useEffect와 함께 사용할때\n\nuseEffet 훅이 deps의 레퍼런스 체크할때의 의미가 있습니다.\n\n어차피 렌더하는 횟수만큼 함수자체는 생성하겠지만, 변수에 할당을 안한다는 의미입니다.\n\n함수의 생성 자체는 경량함수인 arrow function을 사용할 것이고, 그정도 비용은 무시합니다.\n\n```js\nfunction SomeComponent({ name }) {\n  const onClick = useCallback(() => {\n    // do something\n  }, []);\n\n  const someEffect1 = useCallback(() => {\n    // something...\n  }, []);\n  const someEffect2 = () => null;\n\n  useEffect(() => {\n    someEffect1();\n  }, [someEffect1]);\n\n  useEffect(() => {\n    someEffect2();\n  }, [someEffect2]);\n\n  return (\n    \u003Cdiv>\n      \u003Cdiv>name: {name}\u003C/div>\n      \u003Cbutton type=\"button\" onClick={onClick}>\n        click!\n      \u003C/button>\n    \u003C/div>\n  );\n}\n```\n\n우선 someEffect2는 아마 lint를 쓴다면 경고를 띄워줄겁니다.\n\nsomeEffect2를 useCallback을 써라 혹은 deps를 지워라.\n\n어차피 매번 someEffect2라는 변수에는 새로운 함수가 할당될것이기때문이죠.\n\n반면 someEffect1의 사용은 옳습니다.\n\nsomeEffect1의 레퍼런스는 오직 someEffect1의 deps에 의해 변하므로, 변하지않거든요.\n\n---\n\n## dependency list (deps)\n\nuseEffect, useMemo, useCallback의 두번째인자는 DependencyList 입니다.\n\n배열을 넘겨주면되고, 배열의 요소는 특정 변수들을 넣어주면되는데,\n\nuseMemo의 경우,\n\n```js\nconst [myName, setMyName] = useState(\"boseok jung\");\n\nconst reversedMyName = useMemo(\n  () =>\n    Array.from(myName)\n      .reverse()\n      .join(\"\"),\n  [myName]\n);\n```\n\nmyName이라는 state에 의존하고있으므로, myName을 넣어줍니다.\n\nreversedMyName이라는 변수가 갱신되는 조건이 myName이라는 변수가 변경됐을 때 콜백을 다시 실행하여 갱신하고, 그것을 메모이제이션하는 겁니다.\n\nvscode 플러그인 같은걸 사용하면, 자동으로 넣어주기도 합니다.\n\n## custom hook\n\n기존 클래스 컴포넌트에서는 공통 로직을 분리하기위해 with~ 라는 단어로 시작하는 hoc를 만들곤 했는데요,\n\n요즘은 클래스 컴포넌트 대신 함수형 컴포넌트와 hook을 사용하기때문에, 공통 로직을 위해서는 hook을 만들어서 사용합니다\n\n네이밍 컨벤션은 use~입니다. useState처럼요. 이 컨벤션은 리액트의 프리컴파일러에 의해 강제됩니다. use로 시작하지않으면 아마 에러가 날겁니다.\n\n이제 예제를 볼까요?\n\n아래와 같은 두 컴포넌트가 있습니다.\n\n```js\nconst Page1 = () => {\n  const [isChecked, setIsChecked] = useState(false);\n\n  const onChangeCheckBox = () => setIsChecked((prevState) => !prevState);\n\n  return (\n    \u003Cdiv>\n      \u003Cdiv>페이지1\u003C/div>\n      \u003Cinput type=\"checkbox\" checked={isChecked} onChange={onChangeCheckBox} />\n      \u003Cspan>선택\u003C/span>\n    \u003C/div>\n  );\n};\n\nconst Page2 = () => {\n  const [isChecked, setIsChecked] = useState(false);\n\n  const onChangeCheckBox = () => setIsChecked((prevState) => !prevState);\n\n  return (\n    \u003Cdiv>\n      \u003Cdiv>페이지2\u003C/div>\n      \u003Cinput type=\"checkbox\" checked={isChecked} onChange={onChangeCheckBox} />\n      \u003Cspan>선택\u003C/span>\n      {/* some elements... */}\n    \u003C/div>\n  );\n};\n```\n\n엄청 좋은 예제는 아니지만 이해를 돕기엔 충분합니다.\n\ncustom hook을 사용하여 이런식으로 유사한 로직을 분리할 수 있습니다.\n\n추가로 useMemo와 유사한 useCallback의 활용도 볼 수 있습니다~\n\n```js\nconst useCheckBox = (initialState = false) => {\n  const [isChecked, setIsChecked] = useState(initialState);\n\n  const onChangeCheckBox = useCallback(\n    () => setIsChecked((prevState) => !prevState),\n    []\n  );\n\n  return [isChecked, onChangeCheckBox];\n};\n\nexport default useCheckBox;\n```\n\n커스텀 훅은 별게없고 함수형 컴포넌트랑 유사하지만 단지 JSX (ReactNode)를 리턴하지 않고 로직에 대한 상태나 setter를 리턴하는 것 뿐입니다.\n\n생성한 커스텀 훅을 활용하여 다시 Page1만 작성해보면 아래와 같을 것 입니다.\n\n```js\nimport useCheckBox from \"./useCheckBox\";\n\nconst Page1 = () => {\n  const [isChecked, onChangeCheckBox] = useCheckBox();\n\n  return (\n    \u003Cdiv>\n      \u003Cdiv>페이지1\u003C/div>\n      \u003Cinput type=\"checkbox\" checked={isChecked} onChange={onChangeCheckBox} />\n      \u003Cspan>선택\u003C/span>\n    \u003C/div>\n  );\n};\n```\n\n예제의 useCheckBox에 해당하는 로직이 짧아서 큰 메리트를 못 느낄수있지만,\n\n뷰와 모델을 깔끔하게 분리해내고나면 컴포넌트 자체 가독성이 좋아지고 테스트하기 편해집니다.\n\n---\n\nchangeEvent를 받아서 value를 뽑아내고 validate function을 호출하고..\n\nsetState해주는 로직을 갖고있는 custom hook 예제입니다 (타입스크립트)\n\n```ts\nimport { useCallback, useState } from \"react\";\nimport { IIsValidTextInputOptions, isValidTextInput } from \"utils/validate\";\n\ninterface IUseTextInput {\n  initialValue?: string;\n  validatorOption?: IIsValidTextInputOptions;\n}\n\ntype ChangeEventType = React.ChangeEvent\u003C\n  HTMLInputElement | HTMLTextAreaElement\n>;\n\n/**\n * [text, onChangeText]\n * validator는 validatorOption의 property가 하나라도 있어야 작동합니다.\n * 그래서 기본적으로 validate는 하지않습니다\n */\n\nconst useTextInput = ({\n  initialValue = \"\",\n  validatorOption = {},\n}: IUseTextInput = {}): [string, (e: ChangeEventType) => void] => {\n  const [text, setText] = useState(initialValue);\n\n  const onChangeText = useCallback(\n    (e: ChangeEventType) => {\n      const { value } = e.target;\n      const isUsingValidator = !!Object.keys(validatorOption).length;\n      if (\n        !isUsingValidator ||\n        (isUsingValidator && isValidTextInput(value, validatorOption))\n      ) {\n        setText(value);\n      }\n    },\n    [validatorOption]\n  );\n\n  return [text, onChangeText];\n};\n\nexport default useTextInput;\n```\n\n---\n\nAPI 호출하는부분에서 API 로딩과 에러를 promise 친숙하게 ts로 작성한 hook입니다. 참고만하세요..\n\n```ts\ntype Method = \"GET\" | \"POST\" | \"PUT\" | \"DELETE\";\ntype APIFunctionReturn\u003CT = any> = [T, StateUpdater\u003CT>, boolean, boolean];\ntype APIStatus = \"PENDING\" | \"FULFILLED\" | \"REJECTED\";\n\nconst useFetch = \u003CT = any>(\n  apiFunction: () => Promise\u003CT>,\n  method: Method = \"GET\"\n): APIFunctionReturn\u003CT> => {\n  const [data, setData] = useState\u003CT>(null);\n  const [apiStatus, setApiStatus] = useState\u003CAPIStatus>(\"PENDING\");\n\n  const isLoading = useMemo(() => apiStatus === \"PENDING\", [apiStatus]);\n  const isError = useMemo(() => apiStatus === \"REJECTED\", [apiStatus]);\n\n  useEffect(() => {\n    if (!data) {\n      apiFunction()\n        .then((data) => {\n          setData(data);\n          setApiStatus(\"FULFILLED\");\n        })\n        .catch(() => {\n          setApiStatus(\"REJECTED\");\n        });\n    }\n  }, [apiFunction, method, data]);\n\n  return [data, isLoading, isError];\n};\n\nexport default useFetch;\n```\n\n# 커스텀 훅으로 ui와 로직의 깔끔한 분리\n\n위에 있는 내용을 이해했다면, 커스텀 훅으로 ui와 로직의 분리가 가능하겠죠?\n\n컴포넌트는 props와 하나의 커스텀훅만 가지는게 꽤나 좋은 설계입니다.\n\n그 커스텀 훅 내부에서 또 여러개의 훅을 쓸지라도요.\n\n이렇게 모델과 ui가 분리되면 해당 컴포넌트 자체는 훅만 테스트하면 됩니다.\n\n앱이 안정적이고 유지보수하기 좋게 됩니다.\n\n---\n\n# Dynamic Component\n\n## with string\n\nstring으로 다이나믹 컴포넌트 렌더링하는 방법.\n\nvue와 유사한 형태\n\n```js\nimport Card1 from './Card1';\nimport Card2 from './Card2';\nimport Card3 from './Card3';\n\nconst CardComponents = {\n  Card1,\n  Card2,\n  Card3,\n};\n\n// 이렇게 하거나..\nconst Component = ({is, components, ...props}) => {\n  const DynamicComponent = components[is];\n  return (\n    \u003CDynamicComponent {...props} />\n  );\n};\n\n// 혹은..\nconst Component = ({is, components, ...props}) => React.createElement(components[is], props);\n\nconst App = () => {\n  const [currentComponent, setCurrentComponent] = useState('Card1');\n  return (\n    \u003CComponent is={currentComponent} components={CardComponents}/>\n  );\n}\n```\n\n# input type file\n\n```html\n\u003Cinput type=\"file\">\n```\n\n요런 녀석으로 file을 업로드할 수 있다.\n\nreact에서는 onChange 이벤트를 바인딩해줘야한다.\n\n그런데 브라우저 동작이 같은 파일을 연속 두번 업로드하게되면,\n\n파일이 바뀐게 아니므로, onChange가 작동을 안한다.\n\n그런데 작동하게 해야할 기획이 들어왔다고하면.. 되게 해야한다.\n\nfile은 수정할 수 없으므로 value를 바인딩할수도 없다.\n\n그래서 ref를 이용하여 아래와 같이 바인딩해준다\n\n```html\n\u003Cinput type=\"file\" ref={fileRef} onChange={onChangeImage} />\n```\n\n이런식으로.. 바인딩해주고, \n\n```js\nconst fileRef = useRef();\n```\n\n```js\nfileRef.current.value = '';\n```\n\n이런 식으로 value를 적절한 곳에서 초기화시켜버리면 된다.\n\n\n# Performance\n\n## 1. 클래스 컴포넌트인 경우\n\n(클래스 컴포넌트를 사용할때만!)\n\nreact는 react만의 최적화 기법이 있다.\n\nlifecycle 메소드를 이용하는 방법이다.\n\n우선 react는 state, props가 변경되면 해당 컴포넌트를 다시 렌더링한다.\n\nreact의 shouldComponentUpdate lifecycle method에는 nextProps, nextState가 순서대로 파라미터에 전달된다.\n\n파라미터 이름만봐도 대충 짐작이 간다.\n\n현재 state와 props 전달받은 state와 props를 비교할수있다.\n\n컴포넌트를 다시 그리고싶다면 true를 리턴하면되고, 최적화를 위해 리렌더링을 하기싫다면- false를 리턴하면된다.\n\n더 자세히 알고싶다면 공식문서를..\n\n[https://reactjs.org/docs/react-component.html\\#shouldcomponentupdate](https://reactjs.org/docs/react-component.html#shouldcomponentupdate)\n\nstate와 props 구조가 단순하고, 구현하기귀찮다면\n\n클래스에 Component를 상속받지말고, PureComponent를 상속받으면 된다.\n\nPureComponent에는 shouldComponentUpdate 메소드가 이미 구현되어있다.\n\nreact 개발자 중 한명은 PureComponent를 사용하는것을 권장하지않는다.\n\n곧 react가 버전업하게되면, 함수형 컴포넌트의 성능을 향상시킬 것이라고 한다.\n\n컴포넌트에 lifecycle이 필요없다면 함수형 컴포넌트를 사용하도록 하는것이 향후에\n\n성능을 좋게 하는 방법이라고 할 수 있겠다.\n\n## 2. 함수형 컴포넌트인 경우\n\nreact hook을 이용하여 프로퍼티 혹은 변수, 메소드를 캐싱하자.\n\n=> 성능이슈가 있는 컴포넌트에서 useMemo, useCallback을 적극적으로 활용하자.\n\n### useSelector를 사용하는 경우\n\n구조분해할당을 알고있다면 아래처럼 사용하고 싶을것이다.\n\n```js\n// state.user = {name, email, phone} \u003C= 이렇다고 가정하자.\n\nconst {name, email} = useSelector(state => state.user);\n```\n\n하지만 이 방법은 해당 훅에서 state.user를 바라보고있기때문에, 레퍼런스가 변경되면 다시 렌더한다.\n\n다시 말하면 name, email이 변경되지않고 phone이 변경되어도 리렌더한다.\n\n이런 경우에는 디스트럭쳐링을 활용할 수 없고, 풀어서 쓰거나..\n\n아래 코드처럼 useSelector의 두번째 인자에 비교함수를 작성하거나 아래처럼 shallowEqual을 사용하는것이다.\n\n```js\nconst { name, email } = useSelector(\n  state => ({\n    name: state.user.name,\n    email: state.user.email\n  }),\n  shallowEqual\n);\n```\n\n둘다 react-redux 패키지에 포함되어있다.","src/content/docs/fe/react.mdx","533b2e6c00bcc803","fe/rxjs",{"id":384,"data":386,"body":391,"filePath":392,"digest":393,"deferredRender":15},{"title":387,"editUrl":15,"head":388,"template":17,"sidebar":389,"pagefind":15,"draft":19},"RxJS",[],{"hidden":19,"attrs":390},{},"# Reactive extension Javascript (rxjs)\n\n## Reactive extension\n\n### Reactive programming?\n\n```javascript\nvar a = 1;\n\nvar b = 2;\n\nvar c = a + b;\n\nb = 3;\n\n//c == 3???? => reactive에서는 4…\n```\n\n마치 js 클로저를 설명하기위해 counter와 모듈패턴을 예로 하듯이..\n\nreactive를 설명하기위한 대표적인 예시인 엑셀\n\n엑셀시트에서 A=1, B=2, C=A+B 일때, A를 2로 변경하면 C는 3에서 4로 변경된다.\n\nrx는 data flow-stream 에만 관심이 있다.\n\nStream - 어떤 글에서는 어떤 기간동안 다루게 되는 이벤트나 데이터의 컬렉션이라고 설명하고있는데\n\n심플하게 표현하면 =&gt; data flow\n\n참고\\) 자바에도 8버전에 Stream API가 나옴! 자바도 데이터플로우와 함수형의 개념을 수용 =&gt; 패러다임의 변화\n\n### rx의 필요성\n\njs개발 =&gt; callback hell =&gt; promise, async/await\n\n하지만 근본적인 해결책은 아니다.\n\n에러처리도 마찬가지. Promise의 catch는 좋다.\n\n하지만 async/await를 사용했는데 에러핸들링이 필요하다면?\n\nTry catch로 wrapping 해야함.\n\n정리하면 rx를 사용하게 되면 비동기 로직, 에러 핸들링에 유리하고,\n\n마치 함수형처럼 stateless하고, clean한 input, output으로 사이드이펙트를 최소화하고 코드를 간결하고 유지보수하기 좋은 구조로 설계할 수 있다.\n\n공식문서에도 functional이라는 단어가 포함되어있다.\n\n웹 프론트 어플리케이션을 개발할때, 다소 복잡한 UI갱신 로직들은 UI 라이브러리나 프레임워크에게 맡긴다.\n\n그래서 데이터플로우와 로직에만 집중할 수 있는데, 그것마저도 rx라는 라이브러리의 힘을 빌려서 clean하게 작성할 수 있다.\n\nrxjs에서는 reactive를 위해서 Observer패턴을 사용합니다.\n\n### 편리함\n\n웹소켓은 열면 닫아줘야하고, api통신은 도중에 중단할 수 없고(최신 실험적 스펙이나 라이브러리의 힘을 빌릴순 있겠지만), 이벤트리스너는 사용하고 삭제해야한다.\n\nrx를 사용하여 원하는 타이밍에 웹소켓을 닫고, api통신을 중단하고, 이벤트리스너를 자동으로 삭제하여 해제하거나 중단하는데 수고를 덜어준다.\n\n### js array의 문제점\n\nconst myArray = someArray.filter\\(\\).map\\(\\).reduce\\(\\)…\n\n메소드마다 배열을 iterate해야하고, 다시 할당하고, 해제한다\\(GC\\)\n\n이런 방식이 다소 비효율적이다.\n\n이런문제는 rxjs로 해결가능하다.\n\niterate, 할당 횟수를 줄여준다. 이렇게 되면 당연히 GC도 덜한다.\n\n### 사용법\n\njs 메소드와 유사함\n\n```javascript\nimport {of} from 'rxjs';\n\nof(1,2,3);\n```\n\njs의\n\n```javascript\nArray.of(1,2,3) //[1, 2, 3]\n```\n\n이것만 유사한게아니라 map, filter, reduce등등.. 네이밍이 같거나 아주 유사하다.\n\nPromise와 유사함\n\n```javascript\nmyObservable.subscribe(successFn, errorFn, completeFn)\n\npromise.then(successFn, errorFn)\n```\n\nPromise의 구조와도 유사하쥬?\n\n## 몇가지 오퍼레이터 소개\n\n```javascript\nfromEvent(inputElement, 'keyup') //엘리멘트의 이벤트 발생을 관찰한다.\npluck('target', 'value') //위에서 관찰하는 엘리먼트의 값을 가져온다.\nfilter(callback) /* js의 filter와 유사하다. callback에 (text)=> text.length>=3 이런식으로 작성하여 조건을 걸수있다.*/\ndebounceTime(ms) /* ms에는 ms단위로 숫자를 적어준다. lodash의 debounce와 유사하다. 시간만큼 지난후 리턴. debounceTime은 input에 뭔가 입력하고, 자동으로 request를 하는것을 구현할때 유용하다.\n*/\ndistinctUntilChanged //중복된 이벤트 제거\nflatMapLatest() /* 이전에 만들어진 observable을 무시하고 가장 마지막의 observable을 새로운 observable로 만들어준다. param의 예제로는 Promise가 가능하다. 이말은 Promise도 \"스트림화\"가 가능하다는것이다.*/\n```\n\n그 외 여러가지 객체들이나 오퍼레이터를 사용하고 싶다면..\n\n[https://rxjs-dev.firebaseapp.com/api](https://rxjs-dev.firebaseapp.com/api)\n\n### Hot\\(eager\\), Cold\\(lazy\\) observable\n\nobservable은 Subscriber가 있을때 이벤트가 발생하면, 이벤트를 전달한다\n\nHot observable은 subscriber가 없어도, 이벤트를 전달하는 로직을 실행한다\n\nCold observable은 subscriber가 없으면, 이벤트를 전달하는 로직을 실행하지않는다.\n\n### rxjs6버전부터 바뀐 문법들\n\nrxjs6버전부터는 문법이 함수형처럼 바뀌었다.\n\noperators는 이제 pipe를 통해 묶어서 사용하면된다.\n\nEx\\)\n\n```javascript\nmyObservable\n  .map(data => data * 2) //이 부분을 보세요\n  .subscribe(...);\n```\n\n이런식으로 map같은 오퍼레이터들을 체이닝했지만,\n\nrxjs6버전이상은 pipe를 통해 묶어서 써야한다.\n\nEx\\)\n\n```javascript\nimport { map } from 'rxjs/operators';\n\nmyObservable\n  .pipe(map(data => data * 2)) //이 부분이 달라졌쥬?\n  .subscribe(...);\n```\n\n메소드가 아닌 함수가 되어서 import해야하고 오퍼레이터 사용도 달라졌다.\n\n1. catch\\(\\) =&gt; catchError\\(\\)\n2. do\\(\\) =&gt; tap\\(\\)\n3. finally\\(\\) =&gt; finalize\\(\\)\n4. switch\\(\\) =&gt; switchAll\\(\\)\n5. throw\\(\\) =&gt; throwError\\(\\)\n6. fromPromise\\(\\) =&gt; from\\(\\)\n\n등등...\n\n이전 버전을 사용하려면 npm install --save rxjs-compat 를 해주면 된다고 한다.\n\n### Subject, Observable 차이\n\n1. Subject는 Observable처럼 구독할수있다.\n2. Subject는 Observable을 extends했다.\n3. Subject는 다른 Observable을 구독할수있다는 점에서 다름.\n\n---\n\n### Reference\n\nhttps://rxjs-dev.firebaseapp.com/api\n\nhttps://www.slideshare.net/benlesh1/rx-js-and-reactive-programming-may-2015\n\nhttps://www.slideshare.net/sunhyouplee/vuejs-reactive-programming-vuetiful-korea-2nd","src/content/docs/fe/rxjs.mdx","57333afba5be9364","fe/scrolltobottom",{"id":394,"data":396,"body":401,"filePath":402,"digest":403,"deferredRender":15},{"title":397,"editUrl":15,"head":398,"template":17,"sidebar":399,"pagefind":15,"draft":19},"scrollToBottom",[],{"hidden":19,"attrs":400},{},"# scrollToBottom\n\n프론트어플리케이션을 개발하다보면, 특정 엘리먼트 위치로 스크롤하거나, 제일 하단, 상단스크롤이 필요할때가 많죠.\n\n거기에 바로 이동되는게 아니라, 스크롤이되면서 부드럽게 이동하려면.. 구현방법을 모르면 머리아파집니다.\n\n쉽게 구현해봅시다.\n\n우선 제일 하단으로 스크롤하는 함수입니다.\n\n```javascript\nexport const scrollToBottom = element => {\n  const el = element ? element : window;\n  el.scrollBy({top: el.scrollHeight || 99999, behavior: 'smooth'});\n};\n```\n\n스크롤영역을 가진 엘리먼트를 파라미터로 넘기면 그 엘리먼트가 스크롤되고, 아니면 전체화면이 스크롤되도록 구현했습니다.\n\n아래함수는 특정 엘리먼트가 가장 상단에 보이도록 스크롤합니다.\n\n```javascript\nexport const scrollToElement = (element, block = 'start') => {\n  if(!element)\n    throw Error('no element');\n  element.scrollIntoView({ block,  behavior: 'smooth' });\n};\n```\n\n파라미터로 엘리먼트, block이 있는데, 엘리먼트는 화면에 보여져야할 엘리먼트이고,\n\n블록은 start, end 문자열을 넣으면 됩니다. 안넣으면 디폴트로 start입니다.\n\nend옵션을 주면, 해당엘리먼트가 스크롤영역 가장 하단에 보이게됩니다.\n\n신기\\(?\\)하게도 스크롤영역이 여러개여도, 알아서 해당엘리먼트가 있는 스크롤영역을 찾아서 스크롤합니다.","src/content/docs/fe/scrolltobottom.mdx","02c686ced5d7a3ef","fe/seo-check-point",{"id":404,"data":406,"body":411,"filePath":412,"digest":413,"deferredRender":15},{"title":407,"editUrl":15,"head":408,"template":17,"sidebar":409,"pagefind":15,"draft":19},"SEO Check Point",[],{"hidden":19,"attrs":410},{},"# SEO Check Point\n\n\\*구글검색 기준입니다\n\n## 웹사이트내 링크\n\n깨진 링크가 있는지 확인하는것은 필수다.\n\n구글크롤러가 깨진링크를 발견하면 좋은 웹사이트 점수를 얻을 수 없다.\n\n## 키워드\n\n```\n1. 내용\n첫 단락에 키워드 넣기\n동의어/LSI 사용\n내부/외부 링크 삽입\n200자 이상의 글\n\n2. 타이틀 태그(Title Tag)\n클릭 유도하는 제목\n80자 이내\n\n3. 메타 디스크립션(Meta Descirption) //검색해서 나왔을때, 아래에 나오는 부가적인~ 간단한 설명\n160자 이내\n\n4. URL\n\n5. H1 태그\n단 하나의 H1태그 사용\nH2와 H3 안에 동의어 사용\n하지만 너무 많은 키워드를 중복적으로 넣는 키워드 스터핑(Keyowrd Stuffing)은 좋지 않습니다. 그래서 적절한 수의 키워드와 동일어를 섞어 사용하는 것이 좋습니다.\n```\n\n```\n1. Robots.txt\n\n2. 사이트맵(Sitemap.xml)\n\n3. 웹사이트 스피드 \n\n로딩 타임 최소화\n4. 이미지 알트 텍스트(Image ALT Text)\n\n관련된 글 추가\n5. 앵커 텍스트(Anchor Text)\n\n6. 사용자 경험\n\n404 페이지\n팝업창 최소화하기\n사이트 모바일 최적화\n```\n\nref: https://www.twinword.co.kr/blog/google-seo-checklist/","src/content/docs/fe/seo-check-point.mdx","c331c20b362a71d9","fe/testing-in-mobile",{"id":414,"data":416,"body":421,"filePath":422,"digest":423,"deferredRender":15},{"title":417,"editUrl":15,"head":418,"template":17,"sidebar":419,"pagefind":15,"draft":19},"모바일 브라우저 테스트 환경설정",[],{"hidden":19,"attrs":420},{},"# 모바일 브라우저 테스트 환경설정\n\n## 안드로이드\n\nhomebrew를 이용하여 안드로이드 스튜디오를 설치합니다\n```bash\nbrew install --cask android-studio\n# https://formulae.brew.sh/cask/android-studio\n```\n커맨드가 완료되면 Application에 안드로이드 스튜디오가 설치되어있습니다.\n\n실행하여 초기설정을 진행합니다.\n\n실행하면 작은 팝업이 뜨는데, 하단의 톱니바퀴 Configure 버튼 => AVD Manager를 클릭합니다.\n\n표에서 가장 오른쪽을 보면, Actions 란에 녹색 Play버튼을 눌러서 시뮬레이터를 실행합니다.\n\n하단의 Create Virtual Device를 클릭하면 버전을 선택하여 설치하고 다양한 크기와 환경의 디바이스를 시뮬레이팅 할 수 있습니다.\n\n에뮬레이터가 켜지면 모바일 브라우저를 실행하고 테스트합니다.\n\n### 자바스크립트 콘솔\n\n브라우저 창에 about:debug 를 입력하면\n브라우저 상단에 '자바스크립트 콘솔 열기' 라고 뜬다.\n\n설정 > 더보기 > 제일 하단에\n자바스크립트 콘솔 관련 설정도 할 수 있다.\n\n### Android 호스트 설정 (hosts 설정)\n\n호스트 설정을 하려면 AVD Manager에서 순서대로\n\nCreate Virtual Device > 디바이스 스킨 대충 선택 > x86 Images 탭 > ABI가 x86_64 선택 > deviceName 쉽고 알아볼수있게 짓기(커맨드에서 사용하므로, 예를 들면 => aos11)\n\n```bash\n# /Users/{username}/Library/Android/sdk/emulator\n> ./emulator -list-avds\n> ./emulator -avd {deviceName(aos11)} -writable-system\n```\n\n```bash\n# /Users/{username}/Library/Android/sdk/platform-tools\n> adb root\n> adb shell avbctl disable-verification\nSuccessfully disabled verification. Reboot the device for changes to take effect.\n> adb disable-verity\nusing overlayfs\nSuccessfully disabled verity\nNow reboot your device for settings to take effect\n> adb reboot\n> adb root && adb remount\nremount succeeded\n> adb -s {emulatorName} pull /system/etc/hosts ~/Desktop\n> adb -s {emulatorName} push ~/Desktop/hosts /system/etc/hosts\n\n> adb shell\n# cat /etc/hosts\n```\n\n---\n## IOS\n\n앱스토어에서 xcode를 검색하고 설치합니다.\n\n설치 후 실행하면 상단 툴바에 Xcode => Open Developer Tool => Simulator를 순서대로 클릭하여 시뮬레이터를 실행합니다.\n\nPreferences => Components에서 버전을 선택하여 설치하여 사용할수도 있습니다.\n\n목록에 있는것들보다 더 하위 버전을 선택하고 싶다면, xcode의 버전을 낮춰야합니다.\n\n하위 버전 xcode는 아래 링크에서 다운로드 가능합니다.\n\nhttps://developer.apple.com/download/all/?q=xcode\n\nmac os 버전별로 사용가능한 ios simulator는 아래 링크에서 확인가능합니다.\n\nhttps://en.wikipedia.org/wiki/Xcode#Version_comparison_table\n\n### IOS 호스트 설정 (hosts 설정)\n\nIOS 시뮬레이터는 맥북의 호스트를 보고있기 때문에 별도 설정이 필요없습니다.\n\n### 자바스크립트 콘솔 보기\n\n[Safari Technology Preview를 설치하세요!](https://developer.apple.com/safari/download/)\n\n시뮬레이터에서 사파리를 열어서 웹사이트를 열고\n\nSafari Technology Preview의 Develop 탭 => 해당 시뮬레이터 => 해당 웹사이트 누르면\n\nWeb Inspector가 뙇!하고 뜹니다.\n\n---\n\n잘 정리해놓은 이런 글도 있습니다\n\nhttps://karl-park.github.io/devstory/2018/10/25/Android-iOS-WebView-Debugging/","src/content/docs/fe/testing-in-mobile.mdx","c38e3dcc5e2d1d54","fe/virtual-dom",{"id":424,"data":426,"body":431,"filePath":432,"digest":433,"deferredRender":15},{"title":427,"editUrl":15,"head":428,"template":17,"sidebar":429,"pagefind":15,"draft":19},"Virtual DOM, Key",[],{"hidden":19,"attrs":430},{},"# Virtual DOM\n\n우선 virtual DOM의 등장 배경부터 알아보자.\n\n웹 어플리케이션이 거대해질수록, DOM의 조작은 너무나 큰 비용이며 매우 느렸다.\n\n예를 들어, 부모 엘리먼트 일부분을 변경하면, 변경될 필요도 없는 나머지 children들도 모두 다시 그려진다던지.. 굉장히 비효율적이다.\n\n그래서 DOM의 변경을 최소화시켜야한다. 이게 virtual DOM의 역할이다.\n\nreact.js에서는 성능 및 브라우저 간 호환성을 위해 virtual DOM을 선택했다.\n\n가상돔은 HTML 돔의 추상화 개념이다. 가벼우며, 브라우저 스펙의 구현체와는 분리되어있다.\n\nreact 가상돔과 실제 돔은 거의 유사하다. checked, dangerouslySetInnerHTML, key, ref, htmlFor, className 등의 차이가 있을뿐이다.\n\nhtmlFor, className 같은 경우는, for와 class가 자바스크립트의 예약어이기때문에 조금 바꿔서 사용하도록했다.\n\naria-_와 data-_, 웹컴포넌트를 제외하고는 모든 DOM Properties, attributes는 카멜케이스로 작성한다.\n\n[나머지 차이점은 여기서 확인하도록 하자.](https://reactjs.org/docs/dom-elements.html)\n\n```\n작성한 react 컴포넌트는 React Element로 변환된다.\n\n그러면 ReactElement은 빠르고 쉽게 비교, 업데이트 작업을 한 후 가상 돔에 삽입된다.\n```\n\n## 재조정 (Reconciliation)\n\nstate, props가 변경되면, render함수는 새로운 React 엘리먼트 트리를 반환합니다.\n\n여기서 생성된 트리에 맞게 가장 효율적인 UI 갱신방법은 [react의 비교 알고리즘 (Diffing Algorithm)](https://ko.reactjs.org/docs/reconciliation.html#the-diffing-algorithm)을 사용\n\n복잡도 O(n^3)을 O(n)으로 낮추기위해 2가지 조건을 두고 DOM과 똑같은 모델을 만들어서 변경된 부분을 계산해낸다.\n\n```\n1. 서로 다른 타입의 두 엘리먼트는 서로 다른 트리를 만들어낸다.\n2. 개발자가 key prop을 통해, 여러 렌더링 사이에서 어떤 자식 엘리먼트가 변경되지 않아야 할지 표시해 줄 수 있다.\n```\n\n## react의 비교 알고리즘 (Diffing Algorithm)\n\n두 개의 트리를 비교할 때, React는 두 엘리먼트의 루트(root) 엘리먼트부터 비교합니다.\n\n두 루트 엘리먼트의 타입이 다르면, React는 이전 트리를 버리고 완전히 새로운 트리를 구축합니다.\n\n이전 DOM 노드가 파괴되고, 루트 엘리먼트 하위 컴포넌트도 모두 언마운트됩니다.\n\n두 루트 엘리먼트의 타입이 같으면, 두 엘리먼트의 속성을 비교하여 변경된 속성만 갱신합니다.\n\nDOM 노드의 처리가 끝나면, React는 이어서 해당 노드의 자식들을 재귀적으로 처리합니다.\n\nDOM 노드의 자식들을 재귀적으로 처리할 때, React는 기본적으로 동시에 두 리스트를 순회하고 차이점이 있으면 변경을 생성합니다.\n\n```html\n\u003Cul>\n  \u003Cli>first\u003C/li>\n  \u003Cli>second\u003C/li>\n\u003C/ul>\n\n\u003Cul>\n  \u003Cli>first\u003C/li>\n  \u003Cli>second\u003C/li>\n  \u003Cli>third\u003C/li>\n\u003C/ul>\n```\n\n이렇게 마지막에 추가하는경우는 문제가없지만, 다른곳을 변경한다면 종속트리를 유지하지않고 모든 자식을 변경하기때문에 매우 비효율적입니다.\n\n이러한 문제를 해결하기위해 key라는 속성을 사용합니다.\n\n## Key\n\n그래서 key는 유일한 값을 가져야하지만, 전역적으로 유일 할 필요는 없고, 형제 사이에서만 유일하면 됩니다.\n\nKey는 React가 어떤 항목을 변경, 추가 또는 삭제할지 식별하는 것을 돕습니다. key는 엘리먼트에 안정적인 고유성을 부여하기 위해 배열 내부의 엘리먼트에 지정해야 합니다.\n\nkey는 반드시 변하지 않고, 예상 가능하며, 유일해야 합니다. 변하는 key(Math.random()으로 생성된 값 등)를 사용하면 많은 컴포넌트 인스턴스와 DOM 노드를 불필요하게 재생성하여 성능이 나빠지거나 자식 컴포넌트의 state가 유실될 수 있습니다.\n\nkey에는 리스트가 변경되지않는곳이 아니라면 index를 사용하지 않는 것이 좋습니다.\n\n[index를 key로 사용했을때 발생하는 문제의 예시코드](https://ko.reactjs.org/redirect-to-codepen/reconciliation/index-used-as-key)\n\nindex를 key로 사용하면 배열 엘리먼트의 순서가 바뀌었을 때 key 또한 바뀝니다. 그렇게되면 컴포넌트 state가 의도하지않는 방식으로 동작하게 될 수 있습니다.\n\n---\n\n# virtual DOM의 구현\n\n구현에 앞서..\n\n```jsx\n\u003Cul className=\"list\">\n  \u003Cli>item 1\u003C/li>\n  \u003Cli>item 2\u003C/li>\n\u003C/ul>\n```\n\n위 jsx 코드는 babel에 의해 아래 코드와 같이 트랜스파일링됩니다.\n\n```js\nReact.createElement(\n  \"ul\",\n  { className: \"list\" },\n  React.createElement(\"li\", {}, \"item 1\"),\n  React.createElement(\"li\", {}, \"item 2\")\n);\n```\n\n리액트의 경우에는 이런식으로 엘리먼트를 생성합니다.\n\n```js\nfunction h(type, props, …children) {\n  return { type, props, children };\n}\n\nh('ul', { 'class': 'list' },\n  h('li', {}, 'item 1'),\n  h('li', {}, 'item 2'),\n);\n```\n\n이런식으로 React.createElement를 대체할 수 있는 함수를 생성할 수 있습니다.\n\n```js\n/** @jsx h */\nconst a = (\n  \u003Cul className=\"list\">\n    \u003Cli>item 1\u003C/li>\n    \u003Cli>item 2\u003C/li>\n  \u003C/ul>\n);\n```\n\n이렇게 상단에 주석을 넣어주면 babel이 React.createElement대신 h를 사용합니다.\n\nh함수가 실행되면 우리의 가상돔은 이렇게 표현됩니다.\n\n```js\nconst a = {\n  type: \"ul\",\n  props: { className: \"list\" },\n  children: [\n    { type: \"li\", props: {}, children: [\"item 1\"] },\n    { type: \"li\", props: {}, children: [\"item 2\"] },\n  ],\n};\n```\n\n이렇게 생성된 가상돔을 실제 돔에 추가할 수 없으므로,\n\n가상돔 노드를 파라미터로 받아서, 실제 돔 노드를 리턴하는 createElement 함수를 작성합니다. (props제외)\n\n변수 앞의 \\$은 실제 돔 표현을 구분하기위해 붙였습니다.\n\n```js\nfunction createElement(node) {\n  if (typeof node === \"string\") {\n    //노드가 string이면\n    return document.createTextNode(node); //텍스트노드반환\n  }\n  const $el = document.createElement(node.type); //해당 노드 타입으로 엘리먼트 생성\n  node.children\n    .map(createElement) //children 재귀처리\n    .forEach($el.appendChild.bind($el)); //children들을 생성된 엘리먼트의 자식으로 append\n  return $el; //해당 element 반환\n}\n```\n\n[document.createTextNode(data)](https://developer.mozilla.org/ko/docs/Web/API/Document/createTextNode)\n[document.createElement(tagName[, options])](https://developer.mozilla.org/ko/docs/Web/API/Document/createElement)\n\n이렇게 가상돔을 실제돔으로 변경했습니다!\n\n이제 가상돔트리의 변화에 대한 감지 혹은 비교 알고리즘을 만들어야합니다.\n\n여기서는 old, new 두 개의 가상돔 트리를 비교하여 실제 돔에 필요한 변경만 수행합니다.\n\n\\$parent는 가상 노드의 실제 DOM요소입니다.\nindex는 부모 엘리먼트에 있는 노드의 위치 입니다.\n\n```js\nfunction updateElement($parent, newNode, oldNode, index = 0) {\n  if (!oldNode) {\n    // 이전 노드가 없는 경우(노드가 새로 추가된 경우)\n    $parent.appendChild(createElement(newNode));\n  } else if (!newNode) {\n    // 새로운 노드가 없는 경우(노드를 삭제해야 하는 경우)\n    $parent.removeChild($parent.childNodes[index]);\n  }\n}\n```\n\n두 노드를 비교하고 노드가 실제로 변경되었는지 알려주는 함수입니다.\n\n```js\nfunction changed(node1, node2) {\n  return typeof node1 !== typeof node2 ||\n         typeof node1 === ‘string’ && node1 !== node2 ||\n         node1.type !== node2.type\n}\n```\n\n작성된 changed함수를 활용하여 노드의 변경을 적용합니다.\n\n```js\nfunction updateElement($parent, newNode, oldNode, index = 0) {\n  if (!oldNode) {\n    $parent.appendChild(createElement(newNode));\n  } else if (!newNode) {\n    $parent.removeChild($parent.childNodes[index]);\n  } else if (changed(newNode, oldNode)) {\n    $parent.replaceChild(createElement(newNode), $parent.childNodes[index]);\n  }\n}\n```\n\n마지막으로 두 노드의 children을 비교합니다. updateElement함수를 재귀적으로 호출합니다.\n\n고려해야할상황\n\n```\n텍스트 노드는 자식(children)을 가질 수 없기 때문에, 엘리먼트 노드만 비교를 해야합니다.\n이제 현재 노드에 대한 참조를 부모로 전달해야합니다.\n모든 자식(children)을 하나씩 비교해야 합니다. (어떤 시점에 ‘undefined’를 가질 수도 있습니다만 우리 함수는 그것을 처리 할 수 있습니다.)\n인덱스, 자식(children) 배열의 child 노드의 인덱스입니다.\n```\n\n```js\nfunction updateElement($parent, newNode, oldNode, index = 0) {\n  if (!oldNode) {\n    $parent.appendChild(createElement(newNode));\n  } else if (!newNode) {\n    $parent.removeChild($parent.childNodes[index]);\n  } else if (changed(newNode, oldNode)) {\n    $parent.replaceChild(createElement(newNode), $parent.childNodes[index]);\n  } else if (newNode.type) {\n    const newLength = newNode.children.length;\n    const oldLength = oldNode.children.length;\n    for (let i = 0; i \u003C newLength || i \u003C oldLength; i++) {\n      updateElement(\n        $parent.childNodes[index],\n        newNode.children[i],\n        oldNode.children[i],\n        i\n      );\n    }\n  }\n}\n```\n\n이렇게 가상돔의 구현을 완료했습니다.\n\n### 요약\n\n```\nh함수와 createElement 함수 작성\n가상돔트리의 변화에 대한 감지 혹은 비교 알고리즘 작성\n실제 돔에 변경된 부분만 적용\n\n```\n\n---\n\nref\n\nhttps://ko.reactjs.org/docs/\n\nhttps://ko.reactjs.org/docs/reconciliation.html\n\nhttps://github.com/FEDevelopers/tech.description/wiki/%EA%B0%80%EC%83%81-%EB%8F%94%EA%B3%BC-%EB%8F%94%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90\n\nhttps://medium.com/@deathmood/how-to-write-your-own-virtual-dom-ee74acc13060","src/content/docs/fe/virtual-dom.mdx","7c0b0cb51661e0e0","fe/vue-tutorial",{"id":434,"data":436,"body":441,"filePath":442,"digest":443,"deferredRender":15},{"title":437,"editUrl":15,"head":438,"template":17,"sidebar":439,"pagefind":15,"draft":19},"Vue Tutorial",[],{"hidden":19,"attrs":440},{},"# Vue Tutorial\n\n## 개발환경 설정\n\n### 1. node.js 설치하기\n\n[https://nodejs.org/ko/](https://nodejs.org/ko/)\n\n### 2. 텍스트에디터 설치하기\n\n추천 에디터\n\n1. WebStorm - 유료\n2. vscode - 무료\n\n### 3. vue cli로 프로젝트 생성\n\n```bash\nnpx @vue/cli create 프로젝트이름\n```\n\n프로젝트 생성시 여러가지 옵션들을 선택하게되는데, 여기에 대해 잘 모른다면, 두번째 선택지에서 Use NPM을 선택하시고 나머지는 기본을 선택하시면 됩니다. 3.0.4 기준으로는 선택지가 한개밖에없네요. 그냥 선택하고 넘어가시면 됩니다.\n\n### 4. 에디터에서 생성한 프로젝트열기\n\n```\n에디터에서 생성한 프로젝트의 디렉토리를 추가하거나 open 하면됩니다.\n```\n\n### 5. 로컬에서 웹 띄우기\n\n```bash\nnpm run serve\n```\n\n### 6. 브라우저에서 생성한 프로젝트 확인하기\n\n```bash\nhttp://127.0.0.1:8080/\n# or\nhttp://localhost:8080/\n```\n\n빈페이지가 아닌, 아래와 같은 화면이 나오면 성공\n\n\u003Cimg src=\"/images/vue-hello.png\" />\n\n---\n\n저번에 vue cli를 활용해서 vue 프로젝트를 간단하게 생성했습니다.\n\n아래 그림은 생성한 프로젝트의 src/App.vue를 열어본 모습입니다.\n\n\u003Cimg src=\"/images/vue-init-project-dir.png\" />\n\n코드를 보시면, 상단에 template내에 html태그'처럼' 생긴것들이 눈에 보입니다.\n\n그리고 HelloWorld 태그를 보시죠.\n\nhtml태그에서는 볼수 없던 태그이죠?\n\n이름만 봐도 누군가 커스텀으로 만든것처럼 보입니다.\n\n\u003Cimg src=\"/images/vue-script-components.png\" />\n\n위 그림을 보시죠\n\n저런식으로 export default로 내보낸 vue 객체내에,\n\ncomponents 객체에 변수를 바인딩하게되면,\n\n템플릿에서 사용가능한 컴포넌트가 됩니다.\n\nHelloWorld는 컴포넌트라는 것이죠.\n\n```javascript\nimport HelloWorld from \"./components/HelloWorld.vue\";\n```\n\n스크립트의 첫줄을 보시면 위의 코드를 보실 수 있는데요,\n\nHelloWorld 컴포넌트는 components 디렉토리에 존재하는걸 알 수 있습니다.\n\n그렇다면 컴포넌트라는게 무엇일까요.\n\n이해하기쉽게 **'html 엘리먼트의 집합체'**라고도 표현할 수 있겠습니다.\n\n정확하게는 vue 객체라고 표현하는게 올바릅니다.\n\nhtml 엘리먼트가 없는 컴포넌트도 있거든요.\n\nvue 컴포넌트에는 다양한 옵션\\(기능\\)들이 존재합니다.\n\n최종적으로 vue의 여러가지 컴포넌트들을 조합해서 하나의 웹사이트가 구성됩니다.\n\n그리고 싱글파일컴포넌트\\(SFC\\)라는 용어가 있는데요,\n\nHelloWorld.vue 처럼, 확장자를 vue로 가지면서,\n\n\"export default\"하는 객체가 있다면, 그것을 싱글파일컴포넌트라고 부릅니다.\n\n\\(파일하나에 여러개의 vue 컴포넌트를 생성할 수 있습니다.\\)\n\n---\n\n이제 컴포넌트에 대한 감이 어느정도 잡혔습니다.\n\n프로젝트에 컴포넌트를 추가해보며, 조금 더 이해하도록 합시다.\n\n먼저 src/components 폴더내에 ByeWorld.vue를 생성합니다.\n\n그리고 내용을 작성하도록 합니다.\n\n먼저 템플릿부터 작성하겠습니다만, App.vue에서 보이는 구조처럼\n\n템플릿, 스크립트, 스타일 순서로 코드를 작성하면 됩니다.\n\n```html\n\u003Ctemplate>\n  \u003Cdiv class=\"text\">\n    Good Bye World!\n  \u003C/div>\n\u003C/template>\n```\n\n딱히 기능이 없는, div태그 하나뿐인 컴포넌트입니다.\n\n이제 바로 아래에 작성할 자바스크립트는\n\n```html\n\u003Cscript>\n \u003C!--여기에 스크립트 작성-->\n\u003C/script>\n```\n\n이런식으로 스크립트 태그안에 작성해주세요.\n\nvue/cli로 프로젝트를 생성하고 기본 소스코드를 보면\n\n세미콜론이 생략되어있는것을 볼수있는데, 저는 세미콜론을 사용하는것을 선호합니다.\n\n취향이므로 적절히 생략해주세요.\n\n같은 맥락\\(?\\)으로 객체 마지막 프로퍼티뒤에 콤마붙이는걸 좋아합니다. \\(배열제외\\)\n\n```javascript\nexport default {\n  name: \"ByeWorld\", //이름은 컴포넌트파일의 이름과 같게해주세요\n};\n```\n\n마지막으로 스타일은 이렇게 작성해주세요\n\n마찬가지로 style태그로 꼭 묶어주세요\n\n```html\n\u003Cstyle>\n \u003C!--여기에 스타일 작성-->\n\u003C/style>\n```\n\n```css\n.text {\n  font-size: 15px;\n}\n```\n\n모두 작성하셨다면 아래 그림과 같은 소스코드형태가 됩니다.\n\n\u003Cimg src=\"/images/vue-3byeworld.png\" />\n\n정말 간단한 싱글파일컴포넌트를 작성해보았습니다.\n\n만들기만했으므로, 웹에는 보이지않습니다.\n\n이제 작성한 컴포넌트가 웹에 보여질수있도록 import 해봅시다.\n\nsrc/App.vue 를 열어주세요.\n\n먼저 스크립트 부분에\n\n```javascript\nimport ByeWorld from \"./components/ByeWorld.vue\";\n```\n\n이 코드를 추가해주시구요.\n\nimport한 ByeWorld컴포넌트를 components에도 추가해줍니다.\n\n그리고 상단의 템플릿에서도 ByeWorld를 추가해줍니다.\n\n설명대로 진행하셨다면, 소스코드는 아래그림처럼 됩니다.\n\n\u003Cimg src=\"/images/vue-3app.png\" />\n\n소스를 저장하시고 웹을 확인해보시면, 페이지 하단에 Good Bye World! 문구가 추가된걸 볼 수 있습니다.\n\n---\n\n저번에 컴포넌트 추가하는방법을 익혔습니다!\n\n그렇다면 이제 컴포넌트에 대해 좀 더 자세히 알아보도록 합시다.\n\n## 배경지식\n\n컴포넌트 기본에서 언급했던 것과 같이, vue.js에서 컴포넌트는 vue객체일뿐입니다.\n\n싱글파일컴포넌트로 컴포넌트를 생성할때,\n\n```javascript\nexport default {\n  ...\n};\n```\n\n이런식으로 객체를 생성하고, export 합니다.\n\n그냥 객체일뿐인데, 메소드나 라이프싸이클훅에서 this를 콘솔에 찍어보면,\n\nvue객체가 됩니다.\n\n\"export\" 하고나서 컴포넌트를 바인딩하기전에,\n\nvue 라이브러리 내부에서 뭔가 처리해주는게 틀림없습니다.\n\n## 단방향 데이터 플로우\n\n최신 ui 라이브러리\\(react, vue\\)가 채택하고있는 데이터플로우는 단방향입니다.\n\n기본적으로는 부모컴포넌트에서 자식으로 데이터를 내려주고, 자식은 받아서 렌더링만 하는게\n\n권장되는방법입니다.\n\n그런데 개발하다보면, 꼭 그렇게만 할수없을때도 있습니다.\n\n자식에서 부모컴포넌트로 데이터를 돌려줘야할때도있고.. props로 받은 데이터를 수정하고 싶을때도 있습니다.\n\n## 이벤트버스\n\n이렇게 난처할때, 사용할 수 있는게 vue.js에서는 이벤트입니다.\n\nvue.js는 친절하게도 이벤트 인터페이스를 아주 편하게 구현해놨습니다. 사용만 하면됩니다.\n\n@input, @change 이런걸 보신적있나요? 이런게 모두 이벤트입니다.\n\n@가 v-on의 축약형이란걸 알게되는순간, 아~ 하고 이해하게됩니다.\n\n아래서 설명하고있지만 이벤트는 emit으로 쏘고, on으로 받거든요.\n\n```javascript\nthis.$emit(\"change\");\n```\n\n를 통해서 상위컴포넌트로 이벤트를 전달할 수도 있죠. \\(상위컴포넌트에서 @change, 혹은 \\$on으로 받습니다\\)\n\n여기에서 this는, vue객체겠죠. 여기서 이벤트버스를 사용할 수 있는 힌트를 얻었습니다.\n\n$emit으로 이벤트를 전달하고 $on으로 받는다고했죠?\n\n그리고 그 두개의 메소드는 vue객체의 메소드죠.\n\n그러면 이제 main.js처럼 entry point에 이벤트버스를 생성해보겠습니다.\n\n```javascript\n// ...some code\nimport Vue from \"vue\";\nVue.prototype.$eventBus = new Vue();\n// ...some code\n```\n\n쨘! 이렇게하면 모든 vue객체에서 \\$eventBus로 접근하여 이벤트버스를 사용할수 있습니다!\n\n```javascript\nthis.$eventBus.$emit;\nthis.$emit;\n```\n\n이렇게 두개의 이벤트를 사용할 수 있게 됐습니다.\n\n프로토타입에 등록한 \\$eventBus는 부모자식 상관없이 이벤트를 주고 받을 수 있습니다.\n\n그런데 this.\\$emit은 자기 자신의 부모컴포넌트 '인스턴스'로만 이벤트를 쏘게됩니다.\n\n---\n\n쨘.. 이런식으로 컴포넌트 state가 있는데, 각 state가 바뀔때마다, 이벤트버스로 데이터변경을 알리고싶을때,\n\n메소드를 동적으로 만들때! vuex의 mapMutations처럼!!! 이럴때 유용합니다.\n\n하나하나 event emit하고, 받는곳에서는 on으로 하나하나 다 받기 귀찮잖아요.\n\n자바스크립트니까 동적으로 구현해봅시다.\n\n먼저 state!\n\n```javascript\nconst SURVEY_INFO_STATE = {\n  surveyName: \"\",\n  startDate: \"\",\n  startTime: \"\",\n  endDate: \"\",\n  endTime: \"\",\n  surveyOrgan: \"\",\n  surveyDescription: \"\",\n};\n```\n\n뷰 컴포넌트 data에 맵핑하고싶다면 ...SURVEY_INFO_STATE 이런식으로 스프레드 오퍼레이터를 쓰면됩니다.\n\n이해가 잘 안 되실까봐 친절하게 아래 예제코드도 있어여!ㅎㅎ\n\n```javascript\ndata: vm => ({\n  ...SURVEY_INFO_STATE,\n}),\n```\n\n이제 동적으로 메소드를 만들어봅시다.\n\n```javascript\nconst surveyInfoMethods = {};\nObject.keys(SURVEY_INFO_STATE).forEach((stateName) => {\n  surveyInfoMethods[\n    `handleChange${capitalizeFirstLetter(stateName)}`\n  ] = function(v) {\n    this[stateName] = v;\n    this.$eventBus.$emit(`change-${stateName}`, v);\n  };\n});\n```\n\n위에서 생성한 메소드도 뷰 컴포넌트에 아래와 같이 맵핑하면 됩니다\n\n```javascript\nmethods: {\n  ...surveyInfoMethods,\n},\n```\n\ncapitalizeFirstLetter가 뭔지 모르실까봐...아래 또 구현체를 드립니다.\n\n```javascript\nexport const capitalizeFirstLetter = (string = \"\") => {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n```\n\n이벤트는 아래와 같이 on으로 받을수있습니다.\n\n```javascript\nObject.keys(SURVEY_INFO_STATE).forEach((stateName) => {\n  this.$eventBus.$on(`change-${stateName}`, (v) => {\n    this[stateName] = v;\n  });\n});\n```\n\n간단하쥬?\n\n---\n\n## .vue\n\n컴포넌트를 생성하는 대표적인 방법중에 하나가\n\nvue 라는 확장자로 컴포넌트를 만드는 방법입니다. \\(SFC\\)\n\nvue 파일에는 보통 순서대로 템플릿, 스크립트, 스타일이 들어가는데,\n\n이것을 vue-loader라는 친구가 처리해줍니다.\n\n## vue-loader\n\nvue-loader는 npm의 의존성을 관리하는 package.json의 dev dependency에서 찾아볼 수 있습니다.\n\ndev dependency이므로 컴파일단계에서 \\*.vue를 vue-loader가 해석해줍니다.\n\n그래서 브라우저에서 해석할 수 없는 vue확장자가 자연스럽게 실행되는것처럼 느껴지죠.\n\n## virtual dom \\(가상돔\\)\n\n또 하나의 중요한 개념이 등장했습니다.\n\n바로 뷰객체 혹은 SFC에서 template에 해당하는 부분인, virtual dom입니다.\n\n템플릿내부를 보면, 마치 태그와 생김새가 같습니다.\n\n하지만 내부적으로는 createElement와 같은 vue라이브러리의 메소드가\n\n템플릿을 파싱하여 자바스크립트 객체로 변형시킵니다.\n\nreact에서는 render function 내에 작성한 jsx문법이 있다면, createElement와 같거나 비슷한 메소드로\n\njs object로 변경하는 작업이 존재합니다. render function은 아래에서 더 자세히 소개합니다.\n\ndom을 직접 변경하는 것은 비용이 많이 들어가는 작업입니다.\n\n모던 웹에서는 실시간으로 dom이 자꾸자꾸 변경되고,\n\n받아오는 데이터도 계속해서 변합니다.\n\n그런 무거운 작업을 최소화시키고자 하는것이 virtual dom입니다.\n\n데이터변경이 있으면, dom을 바로 변경하지않고 내부적으로 바뀐 부분만\n\n계산하여, 그 부분만 변경하게 됩니다.\n\n예를 들어, 외부 데이터로 \\[1,2,3\\] 이라는 데이터를 받았고\n\n템플릿에서\n\n```html\n\u003Cdiv>1\u003C/div>\n\u003Cdiv>2\u003C/div>\n\u003Cdiv>3\u003C/div>\n```\n\n이런식으로 렌더링한다고 가정합니다.\n\n그런데 \\[1,2,3,4\\]로 데이터가 갱신됐습니다. 화면을 다시 렌더링해야합니다.\n\n```html\n\u003Cdiv>1\u003C/div>\n\u003Cdiv>2\u003C/div>\n\u003Cdiv>3\u003C/div>\n```\n\n위에서 아래처럼 변경될것입니다.\n\n```html\n\u003Cdiv>1\u003C/div>\n\u003Cdiv>2\u003C/div>\n\u003Cdiv>3\u003C/div>\n\u003Cdiv>4\u003C/div>\n```\n\n직접 변경과, virtual dom은 여기서 차이가 발생합니다.\n\n직접 dom을 조작하는 로직이라면 \\(차이점을 계산하는 라이브러리 혹은 알고리즘이 없다고 했을때\\)\n\n해당하는 기존 템플릿을 제거하고, 새로운 템플릿을 렌더링하여 특정 위치에 삽입할것입니다.\n\n그런데 요즘 프론트라이브러리, 프레임워크는 기존 dom에 4만 추가하는 방법을 사용합니다.\n\n여기에 이제 더 복잡한 템플릿이나 로직이 추가된다면, virtual dom이 훨씬 유리할것입니다.\n\nreact에도 virtual dom개념이 존재하지만, vue와는 조금 다른 알고리즘을 사용하여서\n\n같은 virtual dom이지만 속도차이가 존재합니다.\n\nangular.js \\(v1\\)은 dom을 직접 조작하여서 속도가 상대적으로 느립니다.\n\n하지만 위에서 예제로 설명한 간단한 list렌더링의 경우에는 key라는 속성을 이용하여,\n\nlist에서 어느부분이 변경됐는지 감지하고, 계산하여 바뀐부분만 변경합니다.\n\n## render function\n\n위에서 virtual dom을 js object로 변경할때, createElement라는 숨어있는 메소드를 이용한다고 말씀드렸습니다.\n\n화면에 컴포넌트를 렌더링할때는 render라는 메소드를 사용합니다.\n\nlife cycle을 확인해보시면, 프레임워크마다 차이는 있겠지만\n\n컴포넌트가 마운트되기전에 render function을 실행합니다.\n\n```\n여기서 잠깐 life cycle method에 대해 설명합니다.\nlife cycle method 는 말 그대로\n컴포넌트의 생명주기입니다.\n특정 타이밍이 되면, 자동으로 실행하는 메소드입니다. (프레임워크에서 호출합니다.)\n우리가 직접 호출하지않죠.\n그리고 심지어 컴포넌트가 사라질때도 컨트롤할수있습니다. (unmount || destroy)\n```\n\n그리고 컴포넌트가 업데이트되어도 실행합니다.\n\nreact에서는 render function을 구현하지만, vue에서는 그렇지않습니다.\n\n템플릿부분에 작성하면, vue-loader가 자동으로 생성해주죠.\n\n# v-for\n\nv-for는 아마 v-if와 함께 템플릿에서 가장 많이 쓰게될 디렉티브이므로,\n\n한번 알아둘때, 잘 알아두는것이 좋습니다!\n\n우선, v-for는 말 그대로 반복을 의미합니다.\n\n예를들어, 스크립트에 아래와 같은 배열이 있다고 가정합시다.\n\n```javascript\ndata: (vm) => ({\n  cardList: [\n    { text: \"쥬얼리1\", value: 1 },\n    { text: \"쥬얼리2\", value: 2 },\n    { text: \"쥬얼리3\", value: 3 },\n    { text: \"쥬얼리4\", value: 4 },\n  ],\n});\n```\n\n이것을 템플릿에 바인딩하기위해, v-for를 사용할수 있습니다.\n\n```html\n\u003Cdiv v-for=\"(item, index) in cardList\">{{item.text}}\u003C/div>\n```\n\n대충 예상이 되시나요? 아래와 같이 렌더링되어야할겁니다!\n\n```html\n\u003Cdiv>쥬얼리1\u003C/div>\n\u003Cdiv>쥬얼리2\u003C/div>\n\u003Cdiv>쥬얼리3\u003C/div>\n\u003Cdiv>쥬얼리4\u003C/div>\n```\n\n하지만 자바스크립트 콘솔에서는 key 어쩌고 저쩌고하는 에러, 혹은 경고를 뿜어낼것입니다.\n\n처음 리스트를 반복해서 렌더링할때는 문제없지만,\n\n배열이 변경될때, key값은 어떤 배열이 변경됐는지 계산하기위한 속성으로 사용하기때문에,\n\nupdate를 위해 지정해주는것이 좋습니다. 그러므로 키는 각 배열에서 고유한값으로 지정해주는것이 좋습니다.\n\n중복된 키가 존재하면, 배열이 변경되고 dom변경시 예상하지못한 결과가 나올수있겠죠.\n\n물론 콘솔에 에러를 보기싫은것도 당연하고요!\n\n그런데 중요한점은, v-for를 사용할때 key값으로 index를 사용하면 안됩니다.\n\n고유한값이긴하지만, 그냥 순서번호일뿐이에요. 배열의 중간값.. 길이가 3인 배열에서 index 1에 해당하는 배열을 빼더라도,\n\nindex 1에 해당하는 배열은 기존 배열의 index 2에 해당하는 배열이 되겠죠.\n\n이 말은 위에 쥬얼리1,2,3,4 배열을 보시면, 쥬얼리2가 index 1이죠?\n\n쥬얼리2를 배열에서 빼버리면, 쥬얼리3의 index가 1이 됩니다.\n\n당연히 배열이 변경되고 업데이트될때 예상치못한 버그가 발생할수있죠.\n\n단순히 배열 끝만 변경하는 push, pop같은 메소드만 사용하거나,\n\n배열의 변경이 없을거라면 index를 key값으로 해도 상관없습니다.\n\n그러므로 key값을 index가 아닌 고유의 값으로 잘 설정해줍시다.\n\n```html\n\u003Cdiv v-for=\"(item, index) in cardList\" :key=\"item.value\">{{item.text}}\u003C/div>\n```\n\n# vuex\n\nfacebook의 flux 패턴과 매우 유사하다.\n\n단방향 데이터흐름을 갖고있으며, 용어도 거의 같다.\n\n흐름을 정리하자면,\n\n컴포넌트 =&gt; 비동기로직 =&gt; 동기로직 =&gt; 상태 이다.\n\n다시 정리하면,\n\nComponent\\(View\\) =&gt; Actions =&gt; Mutations =&gt; State\n\nvue에서 컴포넌트의 상태를 data라고 한다.\n\nvuex에서 어플리케이션의 상태를 state라고 한다.\n\n비동기 로직은 actions에서.\n\ncomponent에서 비동기로직\\(actions\\)을 dispatch 한다.\n\n비동기로직에서 동기로직으로 commit 한다.\n\n이 과정들을 통해서 app의 state가 바뀌면 re-render한다.\n\n간단한 counter를 만들어놓은 예제\n\n[https://github.com/jewelism/vuex_vue-router_example/tree/master/src/store](https://github.com/jewelism/vuex_vue-router_example/tree/master/src/store)\n\n# vue-rx\n\n## v-stream 디렉티브\n\n스트림의 시작점으로 사용할 수 있다.\n\n```javascript\nv-stream:click=\"myStream$\"\n```\n\n## domStream\n\n템플릿에서 사용한 스트림을\n\n```javascript\ndomStreams: [‘myStream$’]\n```\n\n이런식으로 props처럼 써주면 인스턴스내에서 this.myStream\\$으로 사용할 수 있다.\n\nvue-rx의 내부적으로 domStreams의 배열의 값들로 subject 인스턴스를 생성해주고 있다.\n\n## subscriptions\\(\\)\n\nsubscriptions 메소드는 computed라고 생각하면되는데,\n\nobservable을 subscribe하고, 데이터를 받아온다는점.\n\nthis.\\$watchAsObservable은 vue-rx의 내부적으로 vue의 watch를 사용하여\n\n값이 변하는지 확인하고, observer의 next메소드를 통해 값이 변화한것을 알려준다.\n\n\\$watchAsObservable를 사용하면, 데이터의 변화를 감지하여 observable로 변환시켜준다.\n\n# v-model-with-props\n\nvuetify 라이브러리를 사용하여 개발하는도중, 문제가 생겼다.\n\nv-text-field라는 vuetify에서 제공하는 컴포넌트를 사용하고싶었다.\n\n그리고 그 컴포넌트를 감싸고있는 똑같은 모양의 검색바를 만들고 사용하는데,\n\n```vue\n\u003Cdiv class=\"searchBarWrapper\">\n  \u003Cdiv>\u003C/div>\n  \u003Cdiv class=\"searchBar\">\n    \u003Cv-text-field\n            v-model=\"propModel\"\n            :label=\"placeholder || '검색'\"\n            box/>\n  \u003C/div>\n\u003C/div>\n```\n\n이런모양의 템플릿을 매번 게시판마다 넣어줘야해서, 컴포넌트화를 시켰다.\n\nv-model으로 받는 데이터\\(상태\\)가 바뀌어야하는데,\n\n그 데이터를 props로 받기때문에, 변경할수없는문제가 생겼다.\n\n그래서 v-model을 삭제하고 @change=\"handleChangeText\" 를 추가하여, 부모컴포넌트에서 메소드를 만들고\n\nprops로 내려서 문자열 변경을 감지하는 방법을 사용했다.\n\n그런데, @change가 트리거되는 시점이, 입력하다가 엔터를 치거나, 포커스아웃되면 그때 트리거되는 방식이다.\n\n입력값이 변동되면 바로바로 검색되게하는 기획인데, 기능이 어긋난다.\n\n그래서 바로바로 입력에 반응하는 양방향바인딩 v-model 디렉티브를 props와 함께 사용하는 방법을 아래에서 소개한다.\n\n우선 검색바 컴포넌트이다. 템플릿은 위에 작성되어있다.\n\n```js\nexport default {\n  name: \"SearchBar\",\n  props: {\n    placeholder: String,\n    handleChangeText: Function,\n  },\n  data: () => ({\n    text: \"\",\n  }),\n  computed: {\n    propModel: {\n      get() {\n        return this.text;\n      },\n      set(value) {\n        this.text = value;\n        this.handleChangeText(value);\n      },\n    },\n  },\n};\n```\n\nv-model을 computed로 바인딩했다.\n\n그러면 검색바에 뭔가 입력하면 셋팅되어있는 text라는 상태에 저장되고,\n\n가져올때 가져온다. 이건 그냥 템플릿에 보여주기위한 페이크라고 보면된다.\n\n실제 부모한테 바뀐 입력값을 전달하는것이 이제 computed의 set함수이다.\n\n첫번째라인은 페이크로 보여주기위한 값을 설정하는것이고,\n\n두번째라인, props로 받은 handleChangeText함수를 호출하는데, 파라미터로 입력값을 전달한다.\n\n그러면 이제 부모컴포넌트에서 검색바 객체를 생성할때,\n\nprops로 handleChangeText메소드만 간단하게 구현해주면된다.\n\n부모컴포넌트의 템플릿\n\n```html\n\u003Csearch-bar :handle-change-text=\"handleChangeSearchText\"/>\n```\n\n메소드\n\n```js\nhandleChangeSearchText(text) {\n  this.searchInputText = text;\n},\n```\n\n이런식이다. 이렇게 구현하면, v-model에 props를 바인딩하는것과 유사한 기능을 구현할수있다.","src/content/docs/fe/vue-tutorial.mdx","d547082ea828bb11","fe/watch",{"id":444,"data":446,"body":451,"filePath":452,"digest":453,"deferredRender":15},{"title":447,"editUrl":15,"head":448,"template":17,"sidebar":449,"pagefind":15,"draft":19},"watch 구현",[],{"hidden":19,"attrs":450},{},"# Object Watch\n\nObject의 프로토타입을 확장하는 monkey patching이라서 코드를 활용하기보다는,\n\ngetter, setter를 이용하여 watch를 구현하는 방법을 공부하는게 좋다.\n\n이 구현방법은 구버전의 vue의 reactive와 유사하다\n\n```js\nif (!Object.prototype.watch) {\n  Object.defineProperty(Object.prototype, \"watch\", {\n    enumerable: false\n    , configurable: true\n    , writable: false\n    , value: function (prop, handler) {\n      var\n        oldval = this[prop]\n        , newval = oldval\n        , getter = function () {\n          return newval;\n        }\n        , setter = function (val) {\n          oldval = newval;\n          return newval = handler.call(this, prop, oldval, val);\n        }\n        ;\n\n      if (delete this[prop]) { // can't watch constants\n        Object.defineProperty(this, prop, {\n          get: getter\n          , set: setter\n          , enumerable: true\n          , configurable: true\n        });\n      }\n    }\n  });\n}\n\nval = 2;\nwatch(\"val\",function(id, old, cur) {\n  console.log(\"Changed property: \", id);\n  console.log(\"Original val: \", old);\n  console.log(\"New val: \", cur);\n });\n\n val = 4;\n\n```","src/content/docs/fe/watch.mdx","3233296d7b7fcd0e","fe/web-term",{"id":454,"data":456,"body":461,"filePath":462,"digest":463,"deferredRender":15},{"title":457,"editUrl":15,"head":458,"template":17,"sidebar":459,"pagefind":15,"draft":19},"웹 관련 용어",[],{"hidden":19,"attrs":460},{},"# 웹 관련 용어\n\n- Proxy: 클라이언트와 서버사이의 중개자역할을 하는 서버\n\n- 캐시: 리소스 보관소\n\n- 게이트웨이: 다른 어플리케이션과 연결된 특별한 서버\n\n- 터널: 단순 HTTP 통신을 전달하기만 하는 특별한 Proxy. 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용한다.","src/content/docs/fe/web-term.mdx","f4149999a07255e4","fe/webpack-dev-server",{"id":464,"data":466,"body":471,"filePath":472,"digest":473,"deferredRender":15},{"title":467,"editUrl":15,"head":468,"template":17,"sidebar":469,"pagefind":15,"draft":19},"webpack-dev-server",[],{"hidden":19,"attrs":470},{},"# webpack-dev-server\n\n개발환경에서 js를 빌드하고 어떤 html에서 해당 스크립트를 불러온다고 했을때,\n\n단순히 html을 file 프로토콜로 열게되면, 브라우저의 same origin policy에 의해 불러올 수 없는 경우(상위 폴더가 같은경우만 허용)도 있습니다.\n\n해결하려면 빌드 후 nodejs http-server 패키지를 사용하거나, 웹서버를 이용해서 띄우거나, was를 개발하거나해서 http프로토콜로 프로젝트를 실행합니다.\n\n여러가지 방법이 있지만 모두 번거롭고, 매 프로젝트마다 이렇게 하긴 정말 피곤한 일 입니다.\n\n그것을 해결해주는 것이 webpack-dev-server입니다.\n\n결국 nodejs 위에서 실행되는것이겠지만, 직접 개발할 필요도 없고, webpack의 플러그인이므로 아래와 같이 간편하고 설정, 사용할 수 있다는 장점이 있습니다.\n\n또 하나의 장점으로는 클라이언트측 코드를 수정하면 hot-loader 기능으로 자동으로 리로드됩니다.\n\ndocument를 보면 스크롤해야 할 정도로 기능도 많습니다.\n\n```js\n// webpack.config.js\n\ndevServer: {\n  contentBase: __dirname + \"docs\",\n  inline: true,\n  hot: true,\n  host: \"localhost\",\n  port: 8080\n},\n```\n\n```json\n{\n  ...,\n  \"start\": \"webpack-dev-server\"\n}\n//npm start\n```\n\n---\n\n# webpack-dev-server Proxy\n\nwebpack-dev-server의 정말 유용한 기능중 하나인 proxy도 마찬가지로 브라우저의 same origin policy때문에 개발됐습니다.\n\n백엔드에서 처리해주지않는 이상 프로토콜 도메인 포트번호중에 하나라도 다르면 프론트단에서 백엔드 API와 통신할 수 없는데,\n\n로컬에서 서버를 하나띄워놓고 API를 대신 호출하는 방식으로 cors의 불편함을 해소시켜줍니다.\n\n아래와 같이 간단하게 사용할 수 있습니다.\n\n```js\ndevServer: {\n  proxy: {\n    '/api': {\n      target: 'http://localhost:3000',\n      pathRewrite: {'^/api' : ''}\n    }\n  }\n}\n```\n\n---\n\nref: https://webpack.js.org/configuration/dev-server\n\nhttps://webpack.js.org/configuration/dev-server/#devserverproxy\n\nhttps://developer.mozilla.org/ko/docs/Archive/Misc_top_level/Same-origin_policy_for_file:_URIs","src/content/docs/fe/webpack-dev-server.mdx","d2640964803d75d3","fe/webpack-babel",{"id":474,"data":476,"body":481,"filePath":482,"digest":483,"deferredRender":15},{"title":477,"editUrl":15,"head":478,"template":17,"sidebar":479,"pagefind":15,"draft":19},"webpack, babel",[],{"hidden":19,"attrs":480},{},"# Webpack과 babel\n\n## Webpack 등장배경\n\n현대 브라우저나 자바스크립트는 자체적으로 모듈시스템이 있습니다.\n\n하지만 그것이 없던 시절.. IIFE을 활용한 모듈패턴 외에는 딱히 파일단위 모듈시스템을 사용하는게 쉽지않았고..\n\n그리고 웹 프로젝트가 커질수록, 자바스크립트 파일을 하나로 관리하는데 한계가 있었으므로, 여러개의 자바스크립트로 나눠서 개발을 하는데\n\n그마저도 각 파일들의 스코프 침범이나, 변수 충돌등에서 자유롭지 못했습니다.\n\n또, 자바스크립트의 파일이 여러개 생기고, 사이즈가 커질수록 네트워크통신에서 불리하기때문에, 비용을 최소화할 방법이 필요했죠.\n\n그것을 webpack이 해결해줍니다.\n\n## Webpack\n\nWebpack은 쉽게말하면 여러가지 기능들을 해주는 번들러입니다.\n\nwebpack은 설정에 따라 정적파일을 minify하고 합쳐주고 관리하거나, [webpack-dev-server](/fe/webpack-dev-server)로 로컬개발서버를 띄운다던지, 여러가지 일을 자동으로 해주는 모듈 번들러입니다.\n\n보통 라이브러리들을 합친 js파일, 작성한 코드 파일. 이렇게 두개의 작은 사이즈로 번들링된 파일을 제공합니다.\n\n웹팩이 관리하기 힘든 부분은 *로더*라는 친구가 도와준다.(번들링전 헬퍼) css-loader가 대표적이다.\n\n*플러그인*은 번들링 후 헬퍼이다. 로더와 비슷하게 여러가지일들을 할수있다. uglify라던지.\n\n## Babel\n\n바벨은 트랜스파일러이자 컴파일러다. (컴파일이라는 용어가 더 큰 범주이다.)\n\n보통, ES6+문법을 ES5문법으로 바꿔서, 기존 브라우저의 호환성을 목적으로 사용한다\n\n그외에는 stage단계에 있는 문법들(표준 제안)이나 jsx, typescript를 위해 사용하기도 한다.\n\nhttps://babeljs.io/ => REPL을 구현해놨으니 간단한 문법을 테스트해볼수도 있다.\n\n하위 브라우저 호환성을 목적으로 polyfill이라는 개념과 core-js라는 라이브러리도 존재한다.\n\nbabel은 단순히 트랜스파일러이다. 컴파일하여 소스코드를 변환한다는 의미이다.\n\ncore-js는 polyfill을 위한 라이브러리이다. 기존 @babel/polyfill 패키지와 같은 역할을 한다.","src/content/docs/fe/webpack-babel.mdx","21b6686f0d638b4d","fe/webview",{"id":484,"data":486,"body":491,"filePath":492,"digest":493,"deferredRender":15},{"title":487,"editUrl":15,"head":488,"template":17,"sidebar":489,"pagefind":15,"draft":19},"webview",[],{"hidden":19,"attrs":490},{},"# 웹뷰(Webview)\n\n웹뷰란..\n\n웹을 앱에 임베딩하는것을 뜻합니다.\n\n쉽게 말하면, 웹페이지를 앱의 전체 혹은 일부분에 끼워넣는거죠.\n\n## 장점\n\n웹뷰를 사용하는데는 당연히 장점이 있어서 쓰는거겠죠?\n\n1. Human Resource\n\n예를 들면, aos, ios, 모바일 웹페이지를 개발한다고 가정합시다.\n\n그러면 각 3개의 클라이언트를 따로 개발해야합니다.\n\n하지만 해당영역에 웹뷰를 사용한다면? 웹페이지만 개발하면 됩니다.\n\n1개의 클라이언트만 개발해도 되므로, 인적자원을 덜 소모하죠.\n\n2. 앱 배포\n\naos는 상대적으로 심사과정이 덜 까다롭고, 빠릅니다.\n\n문제는 ios인데요, 앱을 배포하려면 심사과정이 까다롭고 시간이 소요됩니다.\n\n빠르게 수정해서 배포해야하는일이 생긴다면 웹뷰를 활용해보세요.\n\n업데이트를 자유롭게 할수있으니까요\n\n## 단점\n\n웹뷰를 사용하면 물론 단점도 있습니다.\n\n당연히 네이티브 기능에 제약이 따르며,\n\n1. Server Resource\n\n서버자원을 더 사용합니다. 각 클라이언트마다 웹 페이지를 호출할테니까요.\n\n2. 상대적으로 느린 속도\n\n웹뷰는 아무래도 네이티브보단 성능에서 상대적으로 느릴수밖에 없어요.\n\n네이티브는 이미 사용자가 앱스토어에서 빌드된 앱을 다운받고,\n\n웹뷰는 html css js등의 리소스를 다운받고 파싱 & 렌더링하는데에 시간이 소요되기때문이죠.","src/content/docs/fe/webview.mdx","1d927d0c9afdac26","cs/data-structure",{"id":494,"data":496,"body":501,"filePath":502,"digest":503,"deferredRender":15},{"title":497,"editUrl":15,"head":498,"template":17,"sidebar":499,"pagefind":15,"draft":19},"자료구조",[],{"hidden":19,"attrs":500},{},"## tree\n\n트리란 그래프의 일종으로, 여러 노드가 한 노드를 가리킬 수 없는 구조이다.\n\n간단하게는 회로가 없고, 서로 다른 두 노드를 잇는 길이 하나뿐인 그래프를 트리라고 부른다.\n\n트리에서 최상위 노드를 루트 노드\\(root node\\)라고 한다.\n\n또한 노드 A가 노드 B를 가리킬 때 A를 B의 부모 노드\\(parent node\\)\n\nB를 A의 자식 노드\\(child node\\)라고 한다.\n\n자식 노드가 없는 노드를 잎 노드\\(leaf node\\)라고 한다.\n\n잎 노드가 아닌 노드를 내부 노드\\(internal node\\)라고 한다.\n\n### binary-tree\n\n바이너리트리, 이진트리 같은 말이다.\n\n각각의 노드가 최대 두 개의 자식 노드를 가지는 트리 자료 구조이다.\n\n\u003Cimg src=\"/images/binary_tree.png\"/>\n\n_크기가 9이고, 높이가 3인 이진 트리_\n\n## 탐색\n\n```\nin-order : 왼쪽 자식노드, 내 노드, 오른쪽 자식노드 순서로 방문한다.\npre-order : 내 노드, 왼쪽 자식노드, 오른쪽 자식노드 순서로 방문한다.\npost-order : 왼쪽 자식노드, 오른쪽 자식노드, 내 노드 순서로 방문한다.\nlevel-order : 내 노드, 내 노드로부터 깊이 1인 노드들, 내 노드로부터 깊이 2인 노드들, ... , 내 노드로부터 깊이 N인 노드들 (N: 나(트리)의 깊이)\n```\n\n## Referfence\n\nhttps://ko.wikipedia.org/wiki/트리_구조\n\nhttps://ko.wikipedia.org/wiki/이진_트리\n\n---","src/content/docs/cs/data-structure.mdx","f6fa777a888c5281","cs/ddns",{"id":504,"data":506,"body":511,"filePath":512,"digest":513,"deferredRender":15},{"title":507,"editUrl":15,"head":508,"template":17,"sidebar":509,"pagefind":15,"draft":19},"DDNS",[],{"hidden":19,"attrs":510},{},"가정용 인터넷 공유기에서 제공하는 기능인 Dynamic DNS에 대해서.\n\n### DNS\n\nDomain Name System\n\n먼저 DNS에 대해 알아야하는데, 간단합니다.\n\nnaver.com처럼 자연어로 구성된 도메인을 숫자로 구성된 ip로 변환해주는 시스템입니다.\n\n---\n\n### 그렇다면 DDNS는?\n\n**외부**에서 가정용 공유기에 연결된 컴퓨터에 **접근**하고싶을때 사용합니다.\n\n고정ip가 할당되어있다면 그냥 ip로 접근하면 됩니다.\n\n그러나 일반적으로 ip 갯수부족 이슈로 isp에선 동적ip를 내려주고 할당받게되는데..\n\n**매번 바뀌는 ip주소를 외부에선 추적할 방법이 없습니다.**\n\n그래서 공유기를 판매하는 업체(?)에서 dns를 제공합니다.\n\n저는 tplink라는 공유기를 사용중인데, tplink의 ddns를 설정하면\n\n```아이디.tplinkdns.com``` 이런식으로 도메인을 할당받을수있고,\n\n내부에선 ip가 바뀌든 말든 자동으로 tplink쪽 dns에 반영이 되어\n\n외부에서 ip변경에 문제없이 자신의 컴퓨터에 접근할 수 있습니다.\n\n이걸 활용해서 개인서버구축을 아주 쉽게할 수 있습니다.","src/content/docs/cs/ddns.mdx","65da19a5eaa0f26d","cs/http",{"id":514,"data":516,"body":521,"filePath":522,"digest":523,"deferredRender":15},{"title":517,"editUrl":15,"head":518,"template":17,"sidebar":519,"pagefind":15,"draft":19},"http",[],{"hidden":19,"attrs":520},{},"## HTTP \\(HyperText Transfer Protocol\\)\n\n기본 port : 80\n\n2018년 현재 http프로토콜이라고 하면 기본적으로는 1.1을 의미한다.\n\n슬슬 2버전 도입을 준비중인 단계\n\n예전에는 http는 html문서를 주고받는데 많이 사용했다.\n\n요즘은 [REST](/server-side/rest)라는 개념이 대세를 이루면서,\n\n다양한 포맷의 데이터를 주고 받는데 사용한다.\n\nhttps가 이제 거의 기본이 되어가면서, http프로토콜만 단독적으로 사용하진않는다.\n\n[REST](/server-side/rest)에서도 소개했지만\n\nhttp에는 GET, POST, PUT, DELETE 등.. 다양한 메소드들이 있다.\n\nhttp로 request하면, 서버는 3자리로 된 응답코드와 함께 response한다.\n\n\u003Cimg src=\"/images/http-msg.png\" />\n\n```\n시작 줄(start-line)에는 실행되어야 할 요청, 또은 요청 수행에 대한 성공 또는 실패가 기록되어 있습니다.\n이 줄은 항상 한 줄로 끝납니다.\n\nHTTP 메시지의 시작 줄과 HTTP 헤더를 묶어서 요청 헤드(head)라고 부르며,\n이와 반대로 HTTP 메시지의 페이로드는 본문(body)이라고 합니다.\n\n옵션으로 HTTP 헤더 세트가 들어갑니다. 여기에는 요청에 대한 설명,\n혹은 메시지 본문에 대한 설명이 들어갑니다.\n\n요청에 대한 모든 메타 정보가 전송되었음을 알리는 빈 줄(blank line)이 삽입됩니다.\n```\n\n그 응답코드를 http status code라고 한다.\n\n응답코드에는 어느정도 규칙이 있는데,\n\n많이 사용하는것만 설명하고 나머지는 링크에서 확인하길 바란다.\n\n[https://ko.wikipedia.org/wiki/HTTP\\_상태\\_코드](https://ko.wikipedia.org/wiki/HTTP_상태_코드)\n\n```\n2xx: 성공\n200: 서버가 요청을 정상적으로 수행했고, 요청한 페이지를 제공했음을 의미한다.\n```\n\n```\n301: Redirect. 요청한 페이지에서 새로운 페이지로 다시 request한다.\n304: Not modified.\n - 문서가 변경되지않음을 알려준다. 바디를 포함하면 안된다.\n - 이것은 헤더 필드 후에 첫 공백라인으로 종료.\n - 304 응답이 캐시되지않았다면, 캐시는 반드시 이 응답을 무시하고 조건없는 요청을 반복해야 한다.\n```\n\n```\n4xx: 주로 클라이언트 에러\n400: Bad Request. 클라이언트에서 보낸 데이터가 잘못됐음을 의미한다.\n401: Unauthorized. 인증이 필요함을 의미한다.\n403: Forbidden. 인가 실패를 의미한다. 권한없음.\n404: Not Found. 요청한 페이지를 찾을 수 없다.\n```\n\n```\n500: Interval Server Error. 서버에서 오류발생으로 응답할 수 없음을 의미한다.\n```\n\n## HTTPS\n\n기본 port : 443\n\n쉽게 말하면 브라우저에 등록된 기관의 SSL인증서를 웹서버에 등록하게되면\n\n보안이 강화된 http 프로토콜을 사용할 수 있다.\n\n비대칭키 암호화방식으로 이론상으로는 해킹이 불가능하다.\n\n---\n\n## HTTP 메시지 (HTTP Message)\n\n### 인바운드, 아웃바운드 (inbound, outbound)\n\n트랜잭션의 방향을 표현하는 용어이다.\n\n서버사이드 기준으로 생각하면 된다.\n\n서버에서 클라는 서버에서 클라로 나가는것이기때문에 아웃바운드.\n\n반대로 클라에서 서버로 들어가기때문에 인바운드다.\n\n### 다운스트림, 업스트림 (downstream, upstream)\n\nstream은 데이터 흐름을 표현하는 용어이다.\n\n데이터 흐름은 HTTP요청과 응답 관계없이 모두 다운스트림이다.\n\n메시지는 결코 업스트림으로 흐르지않는다.\n\n### 메시지 문법\n\n* 요청\n\nmethod, request URL, version\n\n* 응답\n\nversion, HTTP status code, reason-phrase\n\n* 공통\n\n헤더, 본문\n\nreason-phrase: HTTP status code를 간단히 설명해주는 짧은 문구. 사람에게 읽히기 위한 목적으로 존재. (aka OK, Not Found)\n\nheaders: ```Content-type: text/plain```과 같은 부가적인 정보를 전송하기위한 선택적 key-value 쌍들.\n\nref: https://developer.mozilla.org/ko/docs/Web/HTTP/Messages\n\nHTTP 완벽가이드","src/content/docs/cs/http.mdx","1069711789eeb045","cs/port",{"id":524,"data":526,"body":531,"filePath":532,"digest":533,"deferredRender":15},{"title":527,"editUrl":15,"head":528,"template":17,"sidebar":529,"pagefind":15,"draft":19},"port",[],{"hidden":19,"attrs":530},{},"## 포트번호?\n\n네트워크 서비스나 특정 프로세스를 식별하는 번호이다.\n\n정해져있는것은 아니고, 보통 소프트웨어에서 설정할 수 있다.\n\n하지만 well known port라고 해서 0번 ~ 1023번은 운영체제에서 사용하므로\n\n사용하지않는게 좋다.\n\n49152 ~ 65535 포트를 사용해야 거의 겹치는 일이 없을것이다.\n\n## 예시\n\n웹브라우저에서 포트가 80으로 설정된 http사이트로 접속하게되면\n\n주소 뒤에 포트번호가 붙지않는데, 그것은 브라우저에서 http는 80이므로\n\n포트번호를 생략해서 보이지않는 것 뿐이다.\n\n```\nhttp://xxx.xxx.xxx.xxx:80\n```\n\n위에 작성한 주소처럼 80포트를 붙여도 같은 사이트로 이동한다.\n\n포트번호가 443인 https도 마찬가지다.\n\n## Well Known Port\n\nwell known port에서 필수적으로 알아야하는 포트번호만 소개한다.\n\n```\n21 : FTP\n22 : SSH\n80 : HTTP\n443 : HTTPS\n```\n\n## 알아두면 좋은 포트번호?\n\n어플리케이션에서 기본적으로 채택하고 있는 포트번호를 알고있으면,\n\n여러 어플리케이션을 개발하고 실행하는동안에 포트번호가 겹쳐서\n\n프로세스가 실행되지않는 문제를 어느정도는 방어할 수 있을 것이다.\n\n```\n3000: node.js, react.js app(cra)\n4200: angular\n8080: tomcat, vue.js(@/vue/cli), oracle\n```\n\n위처럼 8080이 특히 많이 겹친다.\n\nvue.js 같은 경우에는 실행할때 웹팩에서 8080이 사용중이면 포트를 자동으로 변경해서 실행하므로 나중에 실행하면 문제가 안된다.\n\n오라클이나 톰캣은 설정을 통해 수동으로 변경해줘야한다.\n\n## 포트포워딩?\n\n은 여기서 설명합니다.\n\n[소형라우터와 공유기](/cs/router)","src/content/docs/cs/port.mdx","c35a4583fb21ed99","cs/process",{"id":534,"data":536,"body":541,"filePath":542,"digest":543,"deferredRender":15},{"title":537,"editUrl":15,"head":538,"template":17,"sidebar":539,"pagefind":15,"draft":19},"process, thread",[],{"hidden":19,"attrs":540},{},"## Processor\n\n```\n프로세서 = CPU\n```\n\n## Process\n\n```\n실행중인 프로그램.\n```\n\n## Thread\n\n```\n프로세스에서 실행되는 흐름의 단위.\n```\n\n## 프로세스와 스레드의 차이\n\n```\n프로세스끼리 메모리를 공유할 수 없다.\n스레드끼리 메모리를 공유할 수 있다.\n```","src/content/docs/cs/process.mdx","38d0087f05c042dd","cs/router",{"id":544,"data":546,"body":551,"filePath":552,"digest":553,"deferredRender":15},{"title":547,"editUrl":15,"head":548,"template":17,"sidebar":549,"pagefind":15,"draft":19},"router",[],{"hidden":19,"attrs":550},{},"## 인터넷 공유기, 소형 라우터와 ip\n\n### IP\n\n```\nIP란 네트워크에서 컴퓨터들이 서로 통신하기 위한 점으로 구분된 4개의 번호입니다.\n\n공인 IP, Public IP - ISP에서 제공하는 IP입니다. 전세계에서 유일한 번호를 갖습니다.\n\n내부 IP, Private IP - 특정 네트워크 내부에서만 사용하는 IP입니다.\n```\n\n127.0.0.1 은 자기 자신 컴퓨터의 ip주소입니다.\n\nhosts 설정을 보면 기본적으로 localhost라는 도메인이 127.0.0.1에 바인딩된 것을 볼 수 있는데요,\n\n그래서 개발서버를 돌리면\n\n```\n127.0.0.1:포트\nlocalhost:포트\n```\n\n둘 중에 하나로 접근하면 됩니다.\n\n도메인이 달라서 CORS에러가 난다면,\n\nhosts파일을 수정해서 해당 아이피를 CORS에러나는 도메인으로 설정하면 해결가능합니다.\n\n### 포트포워딩, DMZ(Twin IP)\n\n포트포워딩은 IP:포트 조합으로 통신을 다른곳으로 넘겨줄 수 있는 기능입니다.\n\nDMZ는 내부IP를 하나 지정해서 공인 IP의 모든 포트를 할당하는 기능입니다. 약간 편리하고 단순한 포트포워딩이라고 생각하셔도 될거같아요.\n\n여기서 잠깐..\n\n```\n내부ip는 내부 네트워크에서만 사용할 수 있으므로,\n외부에서 내부ip가 할당된 컴퓨터에 접속하려면, 공인 ip로 접근해야하는데, 접속하기위한 연결고리가 바로 포트포워딩 혹은 DMZ입니다.\n```\n\n예를 들어, 내부 네트워크 192.168.0.2:3000에 할당된 로컬 개발서버를 외부에서 접근하는 일은 포트포워딩 혹은 DMZ가 필요하겠죠.\n\n### 공유기\n\n공유기는 이름처럼 인터넷 회선을 공유하여 여러 디바이스에서 인터넷을 접속할 수 있도록 도와줍니다. \\(신호를 적절히 분리해서 여러개로 내보내줍니다.\\)\n\n무선 공유기는 무선 통신(wifi)를 사용할 수 있는 공유기겠죠?\n\n```\n192.168.0.1\n```\n\n이런 IP주소를 보신적 있으신가요?\n\n흔히 가정용 공유기에서 많이 사용되는 공유기 주소죠.\n\n공유기도 cpu가 내장된 하나의 컴퓨터이자 라우터입니다.\n\n일반 가정집에는 보통 한개의 공인 IP\\(public ip\\)주소를 할당받게되죠.\n\n그 ip를 공유기가 받아서 인터넷통신을 하는데,\n\n여러대의 컴퓨터에 같은 ip를 할당하면 문제가 발생하겠죠? 공유기가 어떤 컴퓨터와 통신해야하는지 모르니까요.\n\n그래서 공유기의 내부적으로 DHCP를 활용해서 각 컴퓨터마다 private ip\\(사설 ip\\)를 생성해서 할당하게 됩니다.\n\n공유기자신에게 할당한 기본 ip주소가 192.168.0.1이구요.\n\nDHCP라는건 Dynamic Host Configuration Protocol의 약자인데요,\n\n네트워크 관리자들이 조직 내의 네트워크 상에서 IP 주소를 중앙에서 관리하고 할당해줄 수 있도록 해주는 프로토콜이에요.\n\n기본적으로 동적으로 IP를 할당해서 내부IP 충돌이나 IP부족을 해결하는데요,\n\n필요한경우 랜카드 고유 주소인 MAC주소를 이용하여 내부IP도 고정하여 사용할 수 있습니다.\n\n### 공유기 확장하기 - 2개 연결\n\n우리집에는 공유기가 거실에 있어요.\n\n그리고 제 컴퓨터는 제 방에 있고요. 그래서 벽이 존재하는데요,\n\n5ghz의 최대 효율을 내는 통신을 하려면 벽이 없어야한다고 합니다.\n\n그리고 여러대의 유선랜 컴퓨터를 사용중이기도 하고요.\n\n그래서 제 방에 추가적인 공유기를 설치하면서, 그 가이드를 공유드리고자 합니다.\n\n가정집엔 따로 신청하지 않는 이상? 인터넷 회선이 하나씩 들어오죠. 공인 IP는 한개입니다.\n\n그 회선을 첫번째 메인 공유기 WAN포트에 물립니다. 저같은 경우는 거실에 있는 공유기죠.\n\n다음으론 메인 공유기 LAN포트와 제 방에 있는 서브 공유기의 WAN포트를 연결합니다.\n\n각 공유기의 전원만 연결하면 하드웨어 세팅은 이정도로 끝납니다.\n\n메인 공유기의 설정은 너무 쉽습니다. 처음 접속하면 설정 마법사라는 친구가 알아서 해줄거에요.\n\n하지만 서브 공유기는 내부 IP충돌을 막기위해 따로 설정해줘야합니다.\n\n메인공유기의 설정에 접속해서 내부 IP 범위를 확인합니다.\n\n아마 보통 192.168.0.1 ~ 192.168.0.255 을 사용할거에요.\n\n이제 서브 공유기에 접속해서 내부 IP 범위를 확인하고, 충돌한다면 변경해야해요.\n\n저는 단순히 192.168.1.1 ~ 192.168.1.255 이렇게 변경했어요.\n\n쉽죠? 설정은 이걸로 끝입니다.\n\n그런데 제 방에 있는 메인 컴퓨터에 DMZ를 설정하고 싶었어요.\n\n그래서 그 방법도 공유드리자면...\n\n우선 메인 공유기의 DMZ를 설정할때 두번째 공유기의 MAC주소로 설정하고요,\n\n그리고 서브 공유기의 DMZ 설정에서 메인 컴퓨터의 MAC주소로 설정하면 됩니다.\n\n\u003Cimg src=\"/images/dhcp.png\"/>\n\n### 개인서버 구축하기\n\n위의 환경을 세팅했다면 개인서버 구축은 매우 쉽습니다.\n\n저는 개인서버에는 우분투를 설치했는데요,\n\nubuntu 16버전이상 기준으로 랜선을 연결하면 자동으로 인터넷을 감지합니다.\n\n개발용 컴퓨터에서 ssh로 서버에 접속하려면 위의 설정에서 추가적으로 22번 포트를 꼭 포트포워딩해줘야합니다.\n\n터미널에서 아래와 같은 명령어로 개인서버에 접속을 시도해보시면 됩니다.\n\n```bash\nssh 사용자계정@ip주소or도메인\n```\n\n정상적으로 접속된다면 성공적.\n\n이제 추가적인 앱을 배포하고싶다면,\n\nssh 설정처럼 그 앱의 포트번호를 포트포워딩해주면 됩니다.","src/content/docs/cs/router.mdx","e934cfb8ff0832ec","cs/tcp-udp",{"id":554,"data":556,"body":561,"filePath":562,"digest":563,"deferredRender":15},{"title":557,"editUrl":15,"head":558,"template":17,"sidebar":559,"pagefind":15,"draft":19},"tcp-udp",[],{"hidden":19,"attrs":560},{},"## TCP \\(Transmission Control Protocol\\)\n\nTCP프로토콜을 사용하면\n\n클라이언트가 서버에 접속하기 위해서 연결하는 과정이 있는데\n\n이것을 3-handshake라고 한다.\n\n마찬가지로 연결을 해제할때는 4-handshake라고 한다.\n\nTCP는 UDP와는 다르게 handshake와 에러제어, 흐름제어 등의 기능이 있다.\n\n이러한 과정때문에 속도는 좀 더 떨어지지지만 좀더 좋은 품질의 데이터를 얻을 수 있다.\n\n그리고 설정된 연결을 통해 양방향으로 데이터를 전송한다.\n\n하지만 요즘 시대에 네트워크가 에러나는 경우는 극히 드물다고한다\n\n## UDP \\(User Datagram Protocol\\)\n\nTCP에서 언급한 것처럼, 연결하는 과정이 없다.\n\n그렇기 때문에 에러제어, 흐름제어는 당연히 없고,\n\n연결이 됐는지 안됐는지도 모른다.\n\n단방향으로 일방적으로 데이터를 보내고 데이터가 누락되더라도 알 수 없다.\n\n빠른 latency와 데이터 전송 속도가 중요한 인터넷방송이나 온라인게임 서비스들에는 udp가 적합하다.\n\n스타크래프트에서 UDP로 게임을 해본적이 있으신가요? 그 UDP가 여기서 설명하는 UDP입니다.\n\n인터넷방송에서 1프레임정도 누락되는 것은 사실 체감도 안되고 크리티컬하지도 않을 것이다.","src/content/docs/cs/tcp-udp.mdx","b1fc854c5e6e9ee1","godot4/animation",{"id":564,"data":566,"body":571,"filePath":572,"digest":573,"deferredRender":15},{"title":567,"editUrl":15,"head":568,"template":17,"sidebar":569,"pagefind":15,"draft":19},"Animation",[],{"hidden":19,"attrs":570},{},"애니메이션은 게임엔진의 주요 기능중 하나입니다.\n\ngodot에선 ```AnimaionPlayer```, ```AnimationTree```\n\n이 두개의 강력한 노드의 조합으로 다양한 애니메이션을 커버할 수 있습니다.\n\n### 단순한 애니메이션 구현\n\n단순한 어떠한 동작을 실행하고싶다면 ```AnimatedSprite2D```노드만으로도 충분한 경우가 많습니다.\n\n노드를 추가하고 해당 노드에 포커스하면 하단에 SpriteFrames 탭이 생기고, 스프라이트 애니메이션을 편집할 수 있습니다.\n\nauto play, loop 등의 기능버튼이 있어서 상황에 따라 사용하기 편리합니다.\n\n### AnimationPlayer\n\n```AnimatedSprite2D```노드만으로 부족하다면 ```AnimaionPlayer```노드를 활용하세요\n\n다른 노드 대부분의 프로퍼티를 조작할 수 있게 됩니다.\n\n이 과정에서 ```AnimatedSprite2D```노드에서 생성해둔 애니메이션을 ```AnimaionPlayer```에서\n\n활용하고 싶다면 ```Animated Sprite to Animation Player Converter``` 플러그인을 설치하고 사용하세요. 클릭 한번으로 AnimationPlayer노드에 애니메이션들을 추가할 수 있습니다.\n\n### AnimationTree\n\n보통 주인공 캐릭터는 idle, move, run, attack, ... 등등 여러 애니메이션을 사용해야하고,\n\n애니메이션마다 우선순위, 애니메이션이 끝나고나서 실행되어야할 또 다른 애니메이션 등등\n\n이렇게 복잡한 애니메이션을 구현할땐 AnimationPlayer, AnimationTree를 활용합니다.\n\nAnimationTree에서 각 액션에 대해 BlendSpace를 생성하고, 관계를 생각하여 연결해줍니다.\n\n각 애니메이션 관계에는 방향이 있고, 그 방향에서 ```Switch Mode```, ```Condition```등을 설정하여\n\n어떤 상황에서 애니메이션이 스위칭될건지, 해당 애니메이션이 어떤 Condition을 가졌을때 동작하는지\n\n이름(id)을 설정해줍니다. 여기에서 설정한 id는 아래스크립트처럼 어떤 상황에서 어떤 애니메이션을 실행해야하는지 결정합니다.\n\n```python\nanimation_tree[\"parameters/conditions/idle\"] = true\nanimation_tree[\"parameters/conditions/walk\"] = false\nanimation_tree[\"parameters/conditions/attack\"] = false\n```\n\n#### AnimationTree를 사용했는데 애니메이션이 작동안할때\n\n```BlendSpace```를 사용했다면 연필모양의 버튼을 클릭해서 Blend Path를 그렸는지 확인해주세요.\n\n```BlendSpace2D```를 사용했다면 Blend Path가 (일반적으로는) 사각형 모양이 나와야합니다.","src/content/docs/godot4/animation.mdx","c032955f2cec31df","godot4/autoload",{"id":574,"data":576,"body":581,"filePath":582,"digest":583,"deferredRender":15},{"title":577,"editUrl":15,"head":578,"template":17,"sidebar":579,"pagefind":15,"draft":19},"AutoLoad (Singleton)",[],{"hidden":19,"attrs":580},{},"싱글톤이라는 개념은 웹개발자들에게 디자인패턴으로 익숙할 수 있다.\n\n다만 싱글톤이라는것은 디자인패턴보단 인스턴스가 하나인것을 의미한다. (많이들 오해한다.)\n\n디자인패턴에서도 생각해보면 결국 인스턴스를 하나만 사용하기 위한 용도로 쓴다.\n\nfrontend개발자라면 react에서 redux, vue에서 vuex를 떠올려도 좋다.\n\nAutoLoad는 스크립트파일을 지정하여 마치 전역 객체로 사용할 수 있는 것처럼 만들어준다.\n\n```util.gd```라는 스크립트 파일을 오토로드에 ```Util```이라는 이름으로 등록하고, util.gd 파일의 함수를 호출하려면,\n\n어떤 스크립트에서나 ```Util.func1()``` 이런식으로 호출이 가능하다.\n\n```변수```를 사용하거나 ```signal```을 등록해두고 사용할 수도 있다.\n\n다만 변수를 사용할땐 ```싱글톤```이라는점에서 주의해야한다.\n\n씬1에서 값을 변경하면 씬2에서도 적용이 된다는 의미이고, 프로그램을 종료하지 않은 이상\n\n씬을 전환하거나 해제해도 값이 사라지거나 초기화되지않는다는 의미이다.","src/content/docs/godot4/autoload.mdx","d85e99786bbb877c","godot4",{"id":584,"data":586,"body":591,"filePath":592,"digest":593,"deferredRender":15},{"title":587,"editUrl":15,"head":588,"template":17,"sidebar":589,"pagefind":15,"draft":19},"Godot (고도 게임엔진)",[],{"hidden":19,"attrs":590},{},"오픈소스 게임엔진 godot(아마 godot4 기준)에 대한 포스팅입니다.\n\n2D 게임을 다루고 있어서 3D에 대한 내용은 아마 없..\n\n장점으로는 타 엔진이 대략 30%의 수수료를 가져가는것과 다르게 오픈소스라 라이센스비용이 들지않는다는 점.\n\n그리고 직관적으로 설계되어 많은 부분들이 배우지 않아도 이해하여 사용하기 쉽다.\n\n그 말은 상대적으로 ```배우기 쉬운 엔진```이라는 의미\n\n이 엔진 또한 다양한 플랫폼에서 빌드가 가능함.\n\n언어도 선택의 여지가 넓음. 반대로 GDscript라는 자체언어가 있는데, 아무래도 이게 공식 언어다보니 호환성이 가장 좋은듯하고 썼을때 가장 무난한 느낌. 두번째로는 유니티를 저격하는건지 C#을 공식 지원한다.\n\nGDS는 마치 파이썬과 ts의 하위호환을 합쳐놓은듯한 느낌. js 개발자인 나는 꽤나 비슷하다고 느꼈지만 js가 편한 부분도 많아서 가끔 그립다.\n\n\n\n## 기본컨셉\n\ngodot4에선(이전버전 모름) 노드라는 개념으로 장면(씬)을 구성한다.\n\n2D게임을 제작할때 최상위노드는 Node2D 이다.\n\n왼쪽상단을 보면 Scene이라는 탭이 있고, 거기에서 Node2D를 생성하고 하위 노드로 게임에 필요한 배경이나 캐릭터 등을 모두 추가한다.\n\n그리고 노드는 씬으로 저장할수있어서 godot4 gui에서 단순히 드래그드롭으로 또 다른씬에 추가할 수 있고, 재활용하거나 인스턴스를 Programmatic하게 생성할 수 있다.\n\n노드를 추가하면 게임엔진에서 기본적으로 제공하는 노드들이 아주 많다. 필요한건 대부분 구현되어있다.\n\n없는건 노드들끼리 조합해서 사용하면 된다.\n\n## 노드와 충돌처리\n\n캐릭터를 만들고싶으면 ```CharacterBody2D```노드를 사용하면 된다.\n\n그리고 ```CollisionShape2D```를 추가하여 충돌처리를 한다.\n\n```CharacterBody2D```를 노드트리에서 선택하고, inspector를 보면\n\ncollision layer, mask도 설정할 수 있다.\n\ncollision layer는 해당 노드가 어떤 충돌 타입을 가지는지 지정하면 된다.\n\nplayer 캐릭터라면, collision layer중에 하나를 선택하고 layer이름을 player라는것을 인지할수있게 이름을 변경하고 layer를 선택해준다.\n\n그리고 지형과 충돌하게 만들려면, 지형에 해당하는 노드에 mask를 player로 설정하면 된다.\n\ncollision layer와 mask를 이용하면 까다롭고 복잡한 충돌 관계를 쉽게할 수 있다.\n\n## Signal\n\nsignal이라는 개념이 있다.\n\n게임 ui에 버튼이 있고, 그것을 pressed했을때 signal이 발생하고,\n\nsignal에 연결된 함수를 호출하는 개념이다.\n\nfe개발자라면 이벤트버스라고 생각해도 좋다.\n\n```gdscript\n$Button.pressed.connect(func():\n    print(\"button pressed!\")\n)\n```","src/content/docs/godot4/index.mdx","8b711c35c36affaf","godot4/tip",{"id":594,"data":596,"body":601,"filePath":602,"digest":603,"deferredRender":15},{"title":597,"editUrl":15,"head":598,"template":17,"sidebar":599,"pagefind":15,"draft":19},"Tip or Trick",[],{"hidden":19,"attrs":600},{},"## 타이머 추가하기 싫을때\n\n가끔 코드로 뭔가 실행시키고나서 몇초후 다른 코드를 실행시키고싶을때가 있다.\n\n이럴땐 보통 Timer노드를 추가하고, Timer.timeout signal을 통해서 특정 시간이 지나면 시그널함수를 호출하게하여\n우리가 원하는 결과를 만들어내곤한다.\n\n하지만 이게 은근히 귀찮고 보기 안좋을때도 있다. 노드트리가 조금 지저분하게? 변경될수도있고, 시그널 커넥트하는게 귀찮다.\n\n게다가 타이머노드에서 oneshot 옵션을 체크하는걸 깜빡하면 버그가 생길 여지도 있다.\n\n그래서 그냥 아래 예시처럼 간단하게 tween을 사용하는 팁을 공유하고자한다.\n\nlabel을 보여주고, 1.5초후에 라벨을 invisible하게 만드는 간단한 코드이다.\n\n물론 타이머로 구현해도 된다. 하지만 이렇게 간단한 경우 난 tween을 이용하는게 더 편하고 직관적이더라.\n\n\n```python\ndisplay_level_label.show()\nvar tween = create_tween()\ntween.tween_interval(1.5)\ntween.finished.connect(func():\n    display_level_label.hide()\n)\n```\n\n## move_and_slide\n\nCharacterBody에는 move_and_slide라는 함수가 있다.\n\n단순히 velocity를 변경한다고해서 charbody가 움직이는게 아니라,\n\n변경 후 ```move_and_slide```메소드를 호출해줘야한다.\n\n그런데 예를 들어서 플랫포머게임이라서 중력 노드를 개발해서 charbody에 붙였다치자.\n\n움직이는 코드에도 move_and_slide 메소드가 있어서 실행되고있고, 중력 노드에도 move_and_slide 메소드가 실행될 수 있다.\n\n다시말하면 move_and_slide가 프레임당 2번 이상 호출되는 상황에서 문제가 생길 수 있다.\n\n정확히 말하면 문제가 생긴다기보단 의도한 속도랑 다른 결과가 나올 수 있다. 주의해야한다.","src/content/docs/godot4/tip.mdx","b4c12a1be574a330","js/arrayprototype",{"id":604,"data":606,"body":611,"filePath":612,"digest":613,"deferredRender":15},{"title":607,"editUrl":15,"head":608,"template":17,"sidebar":609,"pagefind":15,"draft":19},"Array.prototype",[],{"hidden":19,"attrs":610},{},"# concat\n\n```js\n//ES5 이하의 환경이라면 const를 var로..\nconst arr1 = [1, 2];\nconst arr2 = [3, 4];\n\n// 배열을 합친다\nconsole.log(arr1.concat(arr2)); // [1,2,3,4]\n\n//ES6 환경이라면 \nconst newArr = [...arr1, ...arr2];\nconsole.log(newArr); // [1,2,3,4]\n```\n\n\n# entries\n\n```js\n// ES6\n// entries() 메서드는 배열의 각 인덱스에 대한 key/value 쌍을 가지는 새로운 Array Iterator 객체를 반환합니다.\n// 가끔 필요한데.. 어려울수있음..! iterator객체는 그냥 쉽게 말해서 for of 문법에 사용가능한 객체라고 이해하면 편함\n\nconst a = ['a', 'b', 'c'];\nconst iterator = a.entries();\n\nconsole.log(iterator.next().value);\n\nfor (let e of iterator) {\n    console.log('in for', e);\n}\n\nconsole.log(iterator.next().value);\n\n  // [0, 'a']\n  // [1, 'b']\n  // [2, 'c']\n```\n\n\n# every\n\n```js\n/** mock array */\nconst boseokList = [];\nfor (let i = 0; i \u003C 10; i++) {\n    boseokList.push({ id: i, name: `boseok${i}`, bool: i % 2, realName: 'boseok' });\n}\n\nconsole.log(boseokList);\n// boseokList 배열의 모든 realName 프로퍼티가 'boseok' 문자열인가?\nconst isAllBoseok = boseokList.every(boseok => boseok.realName === 'boseok');\n// boseokList 배열의 모든 name 프로퍼티가 'boseok1' 문자열인가?\nconst isAllBoseok1 = boseokList.every(boseok => boseok.name === 'boseok1');\n\nconsole.log(isAllBoseok); //true\nconsole.log(isAllBoseok1); //false\n```\n\n\n# filter\n\n```js\n/** mock array */\nconst boseokList = [];\nfor (let i = 0; i \u003C 10; i++) {\n    boseokList.push({ id: i, name: `boseok${i}`, bool: i % 2 });\n}\n\n// console.log(boseokList);\n\n// boseokList배열에서 bool프로퍼티의 값이 유효한가?\nconst oddList = boseokList.filter(boseok => boseok.bool);\n\n// boseokList배열에서 bool프로퍼티의 값이 유효하지않은가? - js에서 0이나 false, null, undefined는 모두 false처럼 작동한다\nconst evenList = boseokList.filter(boseok => !boseok.bool);\n\nconsole.log('true', oddList); //bool프로퍼티가 유효한것들만 뽑아서 다시만든 배열\n\nconsole.log('not', evenList); //bool프로퍼티가 유효하지않은것들만 뽑아서 다시만든 배열\n```\n\n\n# includes\n\n```js\nconst arr = [1, 2, 3];\n// this 배열이 파라미터의 값을 포함하는가?\nconsole.log(arr.includes(1)); // true \nconsole.log(arr.includes(4)); // false\n\n// indexOf로 includes를 구현해보고,\n// indexOf로 쉽게 구현할수있는데 왜 이 메소드가 필요한지 생각해보자!\n\nconsole.log(arr.indexOf(1) > -1);\n// 위의 문장으로 indexOf를 대체할수있는데, 왜 includes가 필요할까?\n// 개인적인 생각으로는, 코드를 작성하고 나면 여러사람들이 코드를 보게된다.\n// arr.indexOf(1) > -1 이런 식은 익숙하지않다면 한눈에 잘 안들어온다\n// arr.includes(1) 이것은 어떤의미인지 명확하다. 혼동될일이 없으며\n// indexOf로 includes를 구현하다가 실수 할 일이없다.\n// 예를들어서 어떤 개발자는 arr.indexOf(1) > 0 으로 구현할수도있다.\n// 대부분의 경우에는 작동하지만 찾고있는 1이라는 숫자가 0번째 index에 위치해있다면,\n// arr.indexOf(1) > 0는 0을 return 할 것이고, 그것을 만약에 if 문 내에 작성했다면..\n// if(arr.indexOf(1) > 0) //이 구문은 결국\n// if(0) //이므로 false처럼 작동하므로 if내부의 코드가 실행되지않아 버그를 유발하게된다\n```\n\n\n# indexOf\n\n```js\n// mozila reference\n// 배열에서 지정된 요소를 찾을 수있는 첫 번째 index를 return, 존재하지 않으면 -1을 return (앞에서부터 순서대로)\n// lastIndexOf는 indexOf와 같지만, 뒤에서부터 순서대로 찾는다는점이 다르다\nvar a = [2, 9, 9]; \na.indexOf(2); // 0 \na.indexOf(7); // -1\n\nif (a.indexOf(7) === -1) {\n  // 요소가 배열에 존재하지 않습니다.\n}\n```\n\n\n# join\n\n```js\n//mozila의 예제\nvar a = ['바람', '비', '불'];\nvar myVar1 = a.join();      // myVar1에 '바람,비,불'을 대입\nvar myVar2 = a.join(', ');  // myVar2에 '바람, 비, 불'을 대입\nvar myVar3 = a.join(' + '); // myVar3에 '바람 + 비 + 불'을 대입\nvar myVar4 = a.join('');    // myVar4에 '바람비불'을 대입\n//여기까지 mozila의 예제\n\na.push(undefined, '1');\nconsole.log(a);\nvar myVar5 = a.join('');\nconsole.log(myVar5); //undefined는 무시되고, 합쳐진다\n```\n\n\n# Array.prototype.map\n\n이 메소드는 배열을 하나씩 순회하며, callback으로 하나씩 값을 뱉어준다.\n그리고 callback이 return 하는 값들로 새로운 배열을 만들어서 return한다.\n\n```js\nconst arr = [1, 2, 3];\nconst newArr = arr.map(n => n * 2);\nconsole.log(newArr); //[2, 4, 6]\n```\n\n\n# pop\n\n```js\n// 배열의 마지막 요소를 제거하고, 제거된 요소를 return\n// 첫번째를 지우는것은 shift\n// 첫번째에 삽입하는건 unshift\n// 특정요소를 삭제할때 splice\n\nconst arr = [1,2,3];\nconst removedValue = arr.pop();\n\nconsole.log(removedValue);\nconsole.log(arr);\n```\n\n\n# push\n\n```js\n// 배열 마지막에 새로운 값을 추가한다\n// 첫번째에 삽입하는것은 unshift\n\nconst arr = [1, 2, 3];\nconsole.log(arr);\narr.push(4);\nconsole.log(arr);\n```\n\n\n# reduce\n\n```js\n// mozila reference\n// 배열의 각 요소마다 누적 계산값과 함께 함수를 적용해 하나의 값으로 줄입니다.\n// 쉽지않쥬?\n// https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce\n\n// accumulator: 현재 누적값\n// currentValue: 배열에서 현재 요소\n// currentIndex: 배열에서 현재 요소의 index\nconst total = [0, 1, 2, 3].reduce((accumulator, currentValue, currentIndex) => {\n  return accumulator + currentValue;\n});\nconsole.log(total); //6\n\n\n// reduce와 reduceRight 차이점\nvar a = [\"1\", \"2\", \"3\", \"4\", \"5\"]; \nvar left  = a.reduce(function(prev, cur)      { return prev + cur; }); \nvar right = a.reduceRight(function(prev, cur) { return prev + cur; }); \n\nconsole.log(left);  // \"12345\"\nconsole.log(right); // \"54321\"\n```\n\n\n# reverse\n\n```js\n// 배열의 순서를 거꾸로 뒤집는다.\n\nconst arr = [1, 2, 3, 4];\narr.reverse();\n\nconsole.log(arr);\n```\n\n\n# shift\n\n```js\n// 배열의 첫번째 요소를 지우고, 그 값을 return \n// 마지막 요소 지우는건 pop\n\nconst arr = [1,2,3];\nconst removed = arr.shift();\nconsole.log(removed, arr);\n```\n\n\n# slice\n\n```js\n// mozila의 설명 : slice() 메소드는 어떤 배열의 begin부터 end까지(end는 불포함)에 대한 \n// shallow copy를 새로운 배열 객체로 반환합니다. 원본 배열은 수정되지 않습니다.\n// 여기서 shallow copy라는건 배열의 요소의 copy방법을 뜻한다.\n// 증거와 예제는 아래의 arr, newArr 를 참고하자\n// 예제를 봐도 shallow copy가 헷갈리거나 혼동되면 나중에 다시 공부하세요\n\n// 배열을 copy하여 새로운 배열을 생성한다.\n// 파라미터로 시작과 끝을 정할수있는데, 끝은 포함되지않는다\n// 이해되지않는다면, 예제에서..\n\nconst o = { name: 'boseok' };\nconst o2 = { name: 'boseok2' };\nconst arr = [o, o2];\nconst newArr = arr.slice(1,2);\nconsole.log('기존배열', arr);\nconsole.log('복사한배열', newArr);\no2.id = 1; //배열의 객체를 수정해보자.\nconsole.log('==========================');\nconsole.log('기존배열', arr); //기존배열은 당연히 o를 포함하기때문에 배열의 값이 같이 바뀌어야한다.\nconsole.log('복사한배열', newArr); //deep copy였다면 내부의 값까지 통째로 복사했기때문에 바뀌지않아야하는데, shallow라서 배열의 요소 객체의 프로퍼티가 변경된다\n\n```\n\n\n# some\n\n```js\n/** mock array */\nconst boseokList = [];\nfor (let i = 0; i \u003C 10; i++) {\n    boseokList.push({ id: i, name: `boseok${i}`, bool: i % 2 });\n}\n\nconsole.log(boseokList);\n\n// 리스트에서 값을 하나씩 뽑아낸 객체(boseok) 에서 id값을 비교해서 하나라도 일치하면 true, 이경우에는 true\nconst hasId = boseokList.some(boseok => boseok.id === 1);\n// 리스트에서 값을 하나씩 뽑아낸 객체(boseok) 에서 id값을 비교해서 하나라도 일치하면 true, 이경우에는 false\nconst hasId2 = boseokList.some(boseok => boseok.id === 11);\n\nconsole.log(hasId, hasId2);\n```\n\n\n# sort\n\n```js\n// 배열을 정렬한다\n// callback으로 정렬방법을 지정할수도있다\n\nconst numArr = [3, 2, 1];\nnumArr.sort();\nconsole.log(numArr); // [1,2,3]\n\nconst objArr = [\n  { id: 1, name: 'boseok1', age: 15 },\n  { id: 2, name: 'boseok2', age: 16 },\n  { id: 3, name: 'boseok3', age: 17 },\n  { id: 4, name: 'boseok4', age: 18 },\n  { id: 5, name: 'boseok5', age: 19 },\n];\n\nobjArr.sort((obj, obj2) => {\n  return obj.id \u003C obj2.id; //값이 큰것을 앞으로 보낸다.\n});\nconsole.log(objArr); // id가 5인것부터 1까지 순서대로 나온다.\n\n/////////////////////////////////////\n\nconst objArr2 = [\n  { id: 1, name: 'boseok1', age: 15 },\n  { id: 2, name: 'boseok2', age: 16 },\n  { id: 3, name: 'boseok3', age: 17 },\n  { id: 4, name: 'boseok4', age: 18 },\n  { id: 5, name: 'boseok5', age: 19 },\n];\nobjArr2.sort((o, o2) => o.age \u003C o2.age); //나이가 많은순서로 정렬\nconsole.log(objArr2);\n```\n\n\n# splice\n\n```js\n// 배열에 있는 요소를 제거하거나, 추가한다.\n// 추가하는방법은 deleteCount에 0을 넣고, 뒤에 넣을 요소들을 추가하면 된다.\n// array.splice(start, deleteCount, item1, item2, ...)\n// 삭제한 배열이 있다면, 그것을 리턴한다\n\n// mozila의 예제\n\nvar myFish = ['angel', 'clown', 'mandarin', 'surgeon'];\n// index 2자리에 drum을 넣는다\nvar removed = myFish.splice(2, 0, 'drum'); // ['angel', 'clown', 'drum', 'mandarin', 'surgeon']\nconsole.log(myFish, removed);\n```\n\n\n# statc_of\n\n```js\n// ES6\n// 가변인자를 받는 of메소드\nconst newArr = Array.of(1, 2, 3);\nconst newArr2 = Array.of(1);\n\nconsole.log(newArr); //[1,2,3]\nconsole.log(newArr2); //[1]\n\n//ES5 이하 환경에서의 polyfill\nif (!Array.of) {\n    Array.of = function () {\n        return Array.prototype.slice.call(arguments);\n    };\n}\n//를 먼저 실행해주면 of를 정상적으로 사용할수있다.\n```\n\n\n# static_from\n\n```js\n// 유사배열 - 배열이 아닌 객체인데 length 프로퍼티가 있고 배열처럼 생겼다\nconst likeArray = {\n    length: 3,\n    0: 'boseok',\n    1: 'boseok1',\n    2: 'boseok2',\n};\n// 유사배열이 배열인가?\nconsole.log('likeArray === array?', Array.isArray(likeArray)); //false\n// 유사배열을 배열로 바꿔주는 Array의 from이라는 static 메소드\nconst arr = Array.from(likeArray);\n// from으로 변경한 배열이 진짜 배열인가?\nconsole.log('arr === array?', Array.isArray(arr)); //true\n```\n\n\n# unshift\n\n```js\n// 배열의 첫번째에 값을 삽입하고 기존배열을 한칸씩뒤로 미룬다\n// 배열마지막에 삽입하는것은 push\n\nconst arr = [1, 2, 3];\narr.unshift(0);\nconsole.log(arr); //[0,1,2,3]\n```","src/content/docs/js/Array.prototype.mdx","3a7db025e10e424a","js/stringprototype",{"id":614,"data":616,"body":621,"filePath":622,"digest":623,"deferredRender":15},{"title":617,"editUrl":15,"head":618,"template":17,"sidebar":619,"pagefind":15,"draft":19},"String.prototype",[],{"hidden":19,"attrs":620},{},"# charAt\n\n```js\n/**\n * String.prototype.charAt(index)\n * \n * index 위치에 해당하는 문자 반환\n */\n\n console.log('boseok'.charAt(0)); // b\n console.log('boseok'.charAt(1)); // o\n console.log('boseok'.charAt(2)); // s\n```\n\n\n# charCodeAt\n\n```js\n/**\n * String.prototype.charCodeAt(index)\n * \n * charAt과 유사하게, 해당 인덱스의 위치에 해당하는 문자의 UTF-16 코드를 반환\n */\n\n console.log(\"abc\".charCodeAt(0)); //97\n console.log(\"abc\".charCodeAt(1)); //98\n```\n\n\n# codePointAt\n\n```js\n/**\n * String.prototype.codePointAt(index)\n * \n * fromCodePoint와 반대되는 프로토타입 메소드\n */\n\nvar icons = '☃★♲';\n\nconsole.log(icons.codePointAt(1)); //9733\n\nconsole.log(String.fromCodePoint(9733)); //★\n```\n\n\n# concat\n\n```js\n/**\n * String.prototype.concat(...string)\n * \n * 파라미터의 string과 this문자열을 합쳐서 새로운 문자열을 반환한다.\n */\n\nconsole.log(\"bo\".concat(',', 'seok')); //bo,seok\nconsole.log(\"bo\" + ',' + 'seok'); //bo,seok\n```\n\n\n# endsWith\n\n```js\n/**\n * \n * String.prototype.endsWith(string[, length])\n * this문자열이 파라미터의 string으로 끝나는지 true, false로 리턴.\n * this문자열의 길이를 두번째파라미터인 length로 제한할수도있음.(옵션)\n */\n\nconsole.log('boseok!'.endsWith('!')); // true\nconsole.log('boseok!'.endsWith('!', 4)); // false\n```\n\n\n# includes\n\n```js\n/**\n * ES6 스펙\n * String.prototype.includes(searchString[, position])\n * \n * this문자열에서 searchString이 포함되어있으면 true, 아니면 false 리턴.\n * 두번째파라미터는 옵션인데, position에 해당하는 index부터 찾는다.\n * \n * 사실 이 메소드는 indexOf로 대체가 가능하긴하다.\n * 이 메소드가 나온이유를 추측해보면 당연히 편리성이다.\n * \n * 예를들면 아래와 같은 코드를 보자.\n * \n * const isIncludes = 'boseok'.indexOf('b');\n * if(isIncludes) {\n *  console.log('문자열 찾음');\n * } else {\n *  console.log('문자열 없음');\n * }\n * \n * 헷갈리쥬?\n * 문자열을 찾았는데 해당 인덱스가 0이라서, if가 true가 아니고, false에 해당하므로\n * 문자열이 없다고 콘솔에 찍히는데, 이런 사소한 실수를 범할수있기때문에, includes가 나온것이 아닌가..ㅎㅎ\n * \n * if에 -1같은걸 비교하는 로직이 들어가면 가독성이 살짝 불편해질수도있다.\n * 그래서 ES6환경에서는 includes를 선호한다. \n */\n\n console.log('boseok'.includes('b'));\n console.log('boseok'.includes('b', 1));\n```\n\n\n# indexOf\n\n```js\n/**\n * \n * String.prototype.indexOf(searchString[, fromIndex])\n * \n * this문자열에서 첫번째로 나타나는 searchString문자열을 찾고, 그 위치를 반환한다. \n * fromIndex옵션은 어디서부터 찾을지 위치를 정할수있다.\n * \n * 문자열이 없으면 -1 리턴\n */\n\nconsole.log('boseok'.indexOf('b')); //0\nconsole.log('boseok'.indexOf('b', 1)); //-1\n```\n\n\n# lastIndexOf\n\n```js\n\n/**\n * \n * String.prototype.lastIndexOf(searchValue[, fromIndex])\n * \n * indexOf와 유사하지만 뒤에서부터 찾는다는 점에서 다르다.\n * this문자열에서 마지막 searchString문자열을 찾고, 그 위치를 반환한다.\n * fromIndex옵션은 어디서부터 찾을지 위치를 정할수있다.\n * \n * 문자열이 없으면 -1 리턴\n */\n\nconsole.log('boseokb'.lastIndexOf('b')); // 6\n```\n\n\n# length\n\n```js\n/**\n * length 프로퍼티는 해당 문자열의 길이\n */\nconsole.log(\"abcd\".length); //4\nconst boseok = \"boseok\";\nfor (let i = 0; i \u003C boseok.length; i++) {\n  console.log(boseok[i]);\n}\n```\n\n\n# localeCompare\n\n```js\n/**\n * String.prototype.localeCompare(string)\n * \n * 문자열끼리 비교하는데, 문자열을 순서대로 비교하여 같으면 0을 리턴,\n * 뒤에있으면 양수, 앞에있으면 음수를 리턴한다.\n * 앞, 뒤의 기준이 명확하진않지만 UTF-16기준인듯하다.\n * \n * 사실 두번째, 세번째 파라미터도 있지만 내용이 많고 헷갈리기쉽다.\n * 공식문서를 참고할것\n * \n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare\n */\n\nvar a = 'réservé';\nvar b = 'RESERVE';\nvar c = 'reserve';\nvar d = 'reserve';\n\nconsole.log(a.localeCompare(b)); //1\nconsole.log(c.localeCompare(b)); //-1\nconsole.log(d.localeCompare(b)); //0\n```\n\n\n# match\n\n```js\n/**\n * String.prototype.match(regex)\n * \n * 파라미터는 정규식이다.\n * new RegExp() 를 넣어도 되고, /정규식/g 이런식으로 넣어도 된다.\n * /ab+c/i;\n * new RegExp('ab+c', 'i');\n * 같은 결과를 나타낸다. \n * ES6 에서는 new RegExp(/ab+c/, 'i'); 이렇게도 사용할수있다.\n * 두가지 방법이 있는이유는 생성자 방식은 어떤패턴을 사용할지 정확히 알수없는경우- 사용자입력 등으로 생성되어서, 런타임방식으로 컴파일되게 한다.\n * g라는 위치는 정규식을 문자로 나타냈을때의 flag인데,\n * 아래의 의미를 나타낸다. /식/gi 이런식으로 이어서쓴다.\ng\nglobal match; 일치하는 첫 번째 문자에서 멈추지 않고 전체에서 일치하는 모든 문자를 검색합니다.\ni\nignore case(대소문자를 구별하지 않습니다.)\nm\nmultiline; 시작 혹은 끝 문자 탐색(^ and $)이 다중행에 적용되도록 합니다.  (예로,  \\n 혹은 \\r로 개행된 각각의 라인 시작 혹은 끝 뿐만 아니라, 전체 입력 문자의 시작 혹은 끝에서 일치합니다.\ny \nsticky; matches only from the index indicated by the lastIndex property of this regular expression in the target string (and does not attempt to match from any later indexes).\n\n * 이 메소드를 이해하려면 정규식에 대한 이해가 먼저 필요하다.\n * \n * 문자열에 패턴이 매칭되면 배열에 일치하는 값을 담아서 리턴해준다.\n * 일치하는 문자열이 없으면 null을 반환한다.\n */\n\n\nif('boseokA'.match(/[A-Z]/gim)){\n  console.log('matched');\n} else {\n  console.log('not matched');\n}\n\n\n\n\n\n```\n\n\n# padEnd\n\n```js\n/**\n * ES2017 스펙\n * \n * String.prototype.padEnd(int, string)\n * \n * 문자열에서 int-문자열길이만큼 string을 뒤에 붙여서 리턴한다.\n * string이 주어지지않았다면 ' '로 표기된다.\n */\n\nconst str = '100';\nconsole.log(str.padEnd(4), ','); //'100,'\nconsole.log(str.padEnd(4)); //'100 '\nconsole.log(str.padEnd(2)); //'100'\nconsole.log(str.padEnd(0)); //'100'\nconsole.log(str.padEnd(-1)); //'100'\n```\n\n\n# padStart\n\n```js\n/**\n * \n * String.prototype.padStart(int, string)\n * padEnd와 같은건데, string을 앞에 붙인다는점에서만 다르다.\n * \n */\nconst str1 = '5';\n\nconsole.log(str1.padStart(2, '0')); //'05'\n```\n\n\n# repeat\n\n```js\n/**\n * ES6 스펙\n * String.prototype.repeat(int)\n * \n * this문자열을 int번만큼 반복한 문자열을 리턴한다\n */\n\n console.log('boseok'.repeat(5)); //'boseokboseokboseokboseokboseok'\n```\n\n\n# replace\n\n```js\n/**\n * String.prototype.replace(string|regex, string|function)\n * \n * 첫번째 파라미터에 regex와 string을 넣는것의 활용차이는 this문자열에서 매칭되는 모든 문자열을 바꿀것인가 이다.\n * 정규식의 flag에 g옵션으로 replace하면 replaceAll과 같다.\n * 문자열을 넣으면 매칭되는 첫번째문자열만 바꿔치기한다.\n * \n * 두번째파라미터의 function을 넣을수도있다.\n * \n * 파라미터로는 순서대로 (찾는 문자열, 찾은 인덱스, 원래 문자열)이 넘어온다.\n * 여러번 찾으면 콜백이 여러번 실행된다. 두번째파라미터인 찾은 인덱스만 바뀜.\n */\n\nconsole.log('boseok'.replace('boseok', '123')); //123\nconsole.log('boseok'.replace('o', '123')); //b123seok\nconsole.log('boseok'.replace(/o/g, '123')); //b123se123k\nconsole.log('boseok'.replace(/o/g, (...a) => {\n  console.log(a); //[ 'o', 1, 'boseok' ] and [ 'o', 4, 'boseok' ]\n  return '123';\n}));  //b123se123k\n```\n\n\n# search\n\n```js\n/**\n * String.prototype.search(regex)\n * \n * this문자열에서 정규식에 일치하는 첫번째 문자열을 찾아서 그 위치를 반환한다.\n * 못찾으면 -1 리턴\n * \n * indexOf와 거의 같지만 정규식으로 찾는다는점에서 다르다.\n */\n\n console.log('boseok'.search(/o/)); //1\n```\n\n\n# slice\n\n```js\n/**\n * String.prototype.slice(beginIndex[, endIndex])\n * \n * this문자열을 잘라서 리턴한다.\n * beginIndex가 this문자열길이 이상이면 빈문자열을 리턴한다.\n * 만약 음수를 넣는다면 this.문자열의 길이 -음수로 처리한다.\n * 양수를 넣으면 그 인덱스부터 끝까지의 문자열을 리턴한다.\n * 두번째파라미터를 넣는경우 어디까지 자를것인지 정할수있다.\n */\n\n const boseok = 'boseok';\n console.log(boseok.slice(-1)); //'k'\n console.log(boseok.slice(1)); //'oseok'\n console.log(boseok.slice(1, 3)); //'os'\n console.log(boseok.slice(6)); //''\n\n```\n\n\n# split\n\n```js\n/**\n * String.prototype.split(string[, limit])\n * \n * this문자열을 첫번째파라미터인 string으로 각각 잘라서 배열로 리턴한다.\n * 두번째 파라미터인 limit은 잘라진 배열의 길이를 제한할 수 있습니다.\n */\n console.log('boseok'.split('')); //[ 'b', 'o', 's', 'e', 'o', 'k' ]\n /**\n  * 위의 예제에서 문자열을 간단하게 배열로 변경했습니다.\n  * 하지만 이 방법은 좋지않습니다. UTF-16 codeunit기준으로 자르기때문이지요.\n  * 아래의 끔찍한 결과를 확인해보시져!\n  */\n  console.log('𨭎'.split('')); //[ '�', '�' ]\n\n/**\n *   아래의 방법들이 더 적절합니다.\n *  4개의 결과 모두 콘솔에 [ '𨭎', '1' ] 이 나올것입니다.\n * 제일 마지막 방법은 babel에 의해 트랜스파일링된 것입니다.\n */\n console.log(Array.from('𨭎1'));\n console.log([...'𨭎1']);\n console.log('𨭎1'.split(/(?=[\\s\\S])/u));\n console.log('𨭎1'.split(/(?=(?:[\\0-\\uD7FF\\uE000-\\uFFFF]|[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]))/));\n```\n\n\n# startWith\n\n```js\n/**\n * \n * String.prototype.startWith(string[, position])\n * \n * this문자열이 첫번째파라미터로 주어진 string으로 시작하는지 판단해줍니다.\n * true, false리턴.\n * \n * position은 옵션인데, 주어지지않으면 0으로 시작하고, 주어지면\n * 해당하는 인덱스부터 찾기 시작합니다.\n */\n\nconsole.log('boseok'.startsWith('b')); //true\nconsole.log('boseok'.startsWith('bo')); //true\nconsole.log('boseok'.startsWith('o')); //false\nconsole.log('boseok'.startsWith('o', 1)); //true\n```\n\n\n# static_fromCharCode\n\n```js\n/**\n * String.fromCharCode(...number)\n * \n * UTF-16 포맷에 해당하는 문자열을 리턴\n * \n * 문자 하나를 UTF 16으로 변환하는것은 'a'.charCodeAt(0) 이런식으로 사용하면 된다.\n */\n\nconsole.log(String.fromCharCode(97)); // a\nconsole.log(String.fromCharCode(43)); // +\n\n```\n\n\n# static_fromCodePoint\n\n```js\n/**\n * fromCharCode 와 비슷하게, 해당 number에 해당하는 특수문자를 반환.\n * String.fromCodePoint(...number)\n */\n\n console.log(String.fromCodePoint(9733)); // ★\n```\n\n\n# substring\n\n```js\n/**\n * String.prototype.substring(startIndex[, endIndex])\n * 우선 substr은 deprecated입니다. 대신에 이 메소드를 사용하세요.\n * 기본적인 사용방법은 slice와 동일합니다.\n * 대신에 startIndex가 endIndex보다 크면 내부적으로 startIndex와 endIndex를 swap합니다. (slice는 그렇지않음)\n * 그리고 음수를 넣으면 차이점이 보입니다.\n */\nconsole.log('boseok'.substring(0, 1)); //'b'\nconsole.log('boseok'.substring(0)); //'boseok'\n\nconsole.log('boseok'.substring(-1)); //'boseok'\nconsole.log('boseok'.slice(-1)); //'k'\nconsole.log('boseok'.substring(1, 0)); //'b'\nconsole.log('boseok'.slice(1, 0)); //''\n\n\n```\n\n\n# toLocaleLowerCase\n\n```js\n/**\n * String.prototype.toLocaleLowerCase(option)\n * \n * this 문자열을 모두 소문자로 바꿔서 리턴합니다.\n * option파라미터로 locale을 정할수있는데, 여러개의 locale을 넣는다면, \n * best locale을 자동으로 선택한다고하네요.\n * 기본 locale은 해당호스트의 locale입니다.\n */\n\n console.log('BOSEOK'.toLocaleLowerCase('us')); //'boseok'\n```\n\n\n# toLocaleUpperCase\n\n```js\n/**\n * String.prototype.toLocaleUpperCase()\n * this 문자열을 모두 대문자로 바꿔서 리턴합니다.\n * option은 toLocaleLowerCase와 같습니다.\n */\n\nconsole.log('boseok'.toLocaleUpperCase('us')); //'BOSEOK'\n```\n\n\n# toLowerCase\n\n```js\n/**\n * String.prototype.toLowerCase()\n * \n * this문자열을 모두 소문자로 바꿔서 만들어진 문자열을 리턴합니다.\n */\n\n console.log('BOSEOK'.toLowerCase()); //'boseok'\n```\n\n\n# toString\n\n```js\n/**\n * String.prototype.toString()\n * \n * \n */\nconst v1 = 'boseok'.toString();\nconst v2 = '123'.toString();\nconsole.log(typeof v1, v1); //string 'boseok'\nconsole.log(typeof v2, v2); //string '123'\n\nvar x = new String('BOSEOK');\nconsole.log(typeof x, x.toString()); //object 'BOSEOK'\n```\n\n\n# toUpperCase\n\n```js\n/**\n * String.prototype.toUpperCase()\n * \n * this문자열을 모두 소문자로 바꿔서 만들어진 문자열을 리턴합니다.\n */\n\nconsole.log('boseok'.toUpperCase()); //'BOSEOK'\n```\n\n\n# trim\n\n```js\n/**\n * String.prototype.trim()\n * \n * this문자열의 양끝(시작과 끝)에서 공백을 제거하고 새롭게 만들어진 문자열을 리턴합니다.\n * 유사한 trimRight, trimLeft도 있습니다. \n * trimStart, trimEnd도 있지만 node.js에서는 동작하지않습니다.\n */\n\n console.log('    boseok  '.trim()) //'boseok'\n console.log('    boseok  '.trimRight()) //'    boseok'\n console.log('    boseok  '.trimLeft()) //'boseok  '\n```\n\n\n# valueOf\n\n```js\n/**\n * String.prototype.valueOf()\n * \n * toString과 같습니다. 주로 js내부적으로 사용하기위해 만들어졌습니다.\n */\n\n const v1 = '123';\n console.log(typeof v1.toString());\n console.log(typeof v1.valueOf());\n\n```","src/content/docs/js/String.prototype.mdx","8b7c359800aebdcf","js/arguments",{"id":624,"data":626,"body":631,"filePath":632,"digest":633,"deferredRender":15},{"title":627,"editUrl":15,"head":628,"template":17,"sidebar":629,"pagefind":15,"draft":19},"arguments",[],{"hidden":19,"attrs":630},{},"함수에는 보이지않지만 arguments라는 객체가 있습니다.\n\n```javascript\nfunction a(v1){\n  console.log(v1, arguments);\n}\n\na('var1');\n```\n\n## 결과\n\n\u003Cimg src=\"/images/arguments.png\" alt=\"arguments example image\"/>\n\n신기하게도 arguments라는 변수가 없는데,\n\n콘솔에 잘 나오죠?\n\n게다가 파라미터 변수에 대한 정보도 있고,\n\ncallee라는 함수도 보이네요.\n\n자기 자신의 함수죠.\n\n그 말은 arguments.callee 를 사용하면\n\n자기자신의 함수를 호출할 수 있겠네요.\n\n익명함수에서도 재귀함수를 구현할수있겠죠.\n\n하지만! 최신 자바스크립트 엔진에서 callee나 callee의 프로퍼티를 사용하는것은 자기 자신과 자신을 호출한 함수를 알아야 하기 때문에 더이상 인라인되지 않습니다.\n\n인라인이 안된다는의미는 최적화할수없다는의미이고, 성능을 포기해야한다는겁니다. 그래서 주의해서 사용해야합니다","src/content/docs/js/arguments.mdx","f357874565a2fc4e","js/array-like",{"id":634,"data":636,"body":641,"filePath":642,"digest":643,"deferredRender":15},{"title":637,"editUrl":15,"head":638,"template":17,"sidebar":639,"pagefind":15,"draft":19},"유사배열",[],{"hidden":19,"attrs":640},{},"# array-like 유사배열\n\n아래 예시의 likeArray처럼 배열처럼 생긴 객체를 유사배열이라고 한다.\n\n유사배열은 length프로퍼티와 숫자프로퍼티로 구성됨.\n\n```javascript\n// 유사배열 - 배열이 아닌 객체인데 length 프로퍼티가 있고 배열처럼 생겼다\nconst likeArray = {\n    length: 3,\n    0: 'boseok',\n    1: 'boseok1',\n    2: 'boseok2',\n};\n// 유사배열이 배열인가?\nconsole.log('likeArray === array?', Array.isArray(likeArray)); //false\n// 유사배열을 배열로 바꿔주는 Array의 from이라는 static 메소드\nconst arr = Array.from(likeArray);\n// from으로 변경한 배열이 진짜 배열인가?\nconsole.log('arr === array?', Array.isArray(arr)); //true\n```\n\n중간에 인덱스가 빠져있는 것은 undefined로 처리됨을 주의.\n\nlength프로퍼티가 없는 객체는 유사배열로 바꿔도 빈 배열로 변형됨.\n\n그래서 아래와 같은 약간의 트릭을 쓰면 유사배열을 안전하게 배열로 변형할수있다.\n\n```javascript\nconst newArray = 유사배열;\nnewArray.length = Object.keys(유사배열).length;\nArray.from(newArray); //정상적인 배열이 리턴됨\n```","src/content/docs/js/array-like.mdx","08726cbb22a9b2bc","js/arrow_function",{"id":644,"data":646,"body":651,"filePath":652,"digest":653,"deferredRender":15},{"title":647,"editUrl":15,"head":648,"template":17,"sidebar":649,"pagefind":15,"draft":19},"화살표함수",[],{"hidden":19,"attrs":650},{},"# 화살표함수 - arrow function\n\n화살표함수는 ES6 스펙이다\n\n람다의 자바스크립트버전이다.\n\n```js\nconst v = a => a + 1;\nv(1); //2\n```\n\n```js\nfunction v(a) {\n  return a + 1;\n}\n```\n\n위 두 코드는 '거의' 동일한 코드이다.\n\n차이점이라면 생성자로 쓸수없다는것,\n\nthis, arguments, super, new.target을 바인딩하지않는것. 그래서 arrow function내의 this는 상위스코프의 this를 가리킨다.\n\n바인딩하는게 많이 줄어들었으므로 당연히 좀 더 가벼울 것 같다.\n\n그리고 화살표함수는 항상 익명함수이다.\n\n첫 코드에서는 단순히 v라는 변수에 함수를 대입한것뿐이다.\n\n마지막으로 객체의 메소드로 쓰는건 좋지않다.\n\n```js\nconst obj = {\n  a: 1,\n  method1: () => this.a,\n};\nconsole.log(obj.method1()); //undefined\n```\n\n예제를 보면 왜 객체의 메소드로 arrow function이 좋지않은지 설명가능하다.\n\n콘솔에는 1이 찍혀야 정상이라고 생각할텐데, arrow function내의 this는 전역객체를 가리키고있으므로, undefined가 나오게된다.\n\n이 경우에는 \n\n```js\nconst obj = {\n  a: 1,\n  method1() {\n    return this.a;\n  },\n  method2: function() {\n    return this.a;\n  },\n};\nconsole.log(obj.method1()); //1\nconsole.log(obj.method2()); //1\n```\n\n이렇게 작성하는게 올바르다.\n\nmethod1은 method2의 축약형이다. ES6에서 사용할수있는 문법이다.\n\n물론 this를 사용하지않으면 문제될건 없다.\n\n객체의 프로토타입 메소드에 arrow function을 사용하는것 또한 동일한 문제가 나타난다.\n\n----------\n\n위의 첫번째코드를 보면, v(1)의 리턴값이 2이다.\n\n블럭으로 감싸지않으면, expression을 리턴한다.\n\n그 말은 블럭으로 감싸고 리턴을 하지 않으면, undefined를 리턴한다는 뜻이다.\n\n```js\nconst v = a => { a + 1 };\nv(1); //undefined\n```\n\n-------\n\n그리고 위의 코드에서는 매개변수를 괄호로 감싸지않았는데, 한개인경우에만 괄호를 생략할수있고\n\n매개변수가없거나 여러개면 괄호를 생략할 수 없다.\n\n또한 매개변수에 rest parameter나 destructuring이 가능하다.\n\n```js\nconst v = (a, ...rest) => rest;\nv(1, 2, 3); //[2, 3]\n```\n\n```js\nconst v = ([a, b]) => a + b;\nv([1, 2]); //3\n```","src/content/docs/js/arrow_function.mdx","177bb4eb937b2be0","js/closure",{"id":654,"data":656,"body":661,"filePath":662,"digest":663,"deferredRender":15},{"title":657,"editUrl":15,"head":658,"template":17,"sidebar":659,"pagefind":15,"draft":19},"클로져",[],{"hidden":19,"attrs":660},{},"# 클로져\\(Closure\\)\n\n함수와 그 함수가 선언될 당시의 환경정보 사이의 조합이라고 설명합니다.\n\n(함수를 선언할 당시의 환경에 함수를 묶어둔 자료구조 => 정적 스코프 static scope 혹은 어휘 스코프 lexical scope)\n\n대체 뭔소린지 알수가 없으므로 아래에서 쉽게 설명합니다.\n\n우선, 함수가 리턴하면 함수내의 변수들은 gc에 의해 사라집니다.\n\n\u003Cb>클로저를 사용하면, 최초 선언시의 정보들(참조)을 유지할 수 있습니다.\u003C/b>\n\n예를 들면, 함수내에 inner함수를 만들고 outer함수의 변수를 참조하게 만들고 outer함수에서 inner함수를 리턴하게되면\n\nouter함수가 리턴되더라도, outer함수내의 변수가 살아있게 됩니다.\n\n클로저가 형성되면, 그 내부의 환경을 기억하는 것 입니다. =&gt; 스코프와 밀접한 관련\n\n\\(참고 - java언어에서는, final로 선언된 constant만 내부함수에서 참조가 가능하게 되어있습니다.\\)\n\n아래는 아주 간단한 예제입니다.\n\n```javascript\nfunction createClosure(v) {\n  var v1 = v;\n  return function() {\n    return v1;\n  }\n}\n\nvar c1 = createClosure(1);\nconsole.log(c1()); //1\nvar c2 = createClosure('boseok');\nconsole.log(c2()); //\"boseok\"\n```\n\n이렇게 구현하면 형성된 클로저의 v1변수값을 얻을수있는데,\n\nv1변수를 직접 참조할 수는 없다. =&gt; 자바스크립트에서 private 변수를 만드는 방법\n\n## 메모리와 GC\n\n가비지콜렉터가 그 변수를 회수하지않기때문에, 메모리관리에 주의해야한다.\n\n왜 가비지 콜렉터가 그 변수를 회수하지않을까?\n\n직접 접근하지는 못하지만, 닿을 수 있는 오브젝트이기 때문이다.\n\n닿을 수 있는 오브젝트는 gc의 대상이 아니다.\n\n\"더 이상 필요없는 오브젝트\" == \"닿을 수 없는 오브젝트\"\n\n아래는 클로저를 이용한 모듈패턴으로,\n\nprivate변수를 만들수있고, 클로저를 설명하는 대표적인 예시이다.\n\n```javascript\nvar counter = (function() { \n  var privateCounter = 0; \n  function changeBy(val) { \n    privateCounter += val; \n  } \n  return { \n    increment: function(val) { \n      changeBy(val); \n    }, \n    value: function() { \n      return privateCounter; \n    } \n  }; \n})();\n\ncounter.value(); //0\ncounter.increment(2);\ncounter.value(); //2\ncounter.privateCounter; //undefined\n```\n\n하지만 클로저를 활용하는동안 GC가 메모리를 회수할수없다.\n\n카운터를 만들때마다 각각의 카운터의 인스턴스는 privateCounter를 생성하므로 메모리낭비이다.\n\n그러므로 다 사용하고나면 counter에 null을 대입하여 gc가 작동할수 있도록 해줘야한다.\n\n```javascript\ncounter = null;\n```","src/content/docs/js/closure.mdx","385fc20a01b637b0","js/async-await",{"id":664,"data":666,"body":671,"filePath":672,"digest":673,"deferredRender":15},{"title":667,"editUrl":15,"head":668,"template":17,"sidebar":669,"pagefind":15,"draft":19},"async, await",[],{"hidden":19,"attrs":670},{},"# async, await\n\n## 스펙\n\nnode.js는 8버전 이상부터 공식적으로 지원하고 있고, ES8 스펙입니다.\n\n## 기본 설명\n\nasync, await를 사용하면 비동기로직을 마치 동기적인것처럼 작성할 수 있습니다.\n\n기본적으로 async 라는 '키워드'는 함수 앞에 선언합니다.\n\n```javascript\nasync function() {}\n\nasync () => {}\n```\n\nawait는 async 함수내에서만 사용할 수 있습니다.\n\nawait는 'Promise'의 해결을 기다리고 반환한후 다시 async 함수를 실행합니다.\n\nawait 뒤의 표현식은 Promise객체가 와야겠죠?\n\n그리고 async function은 Promise를 반환합니다.\n\n```javascript\nconst somefunction = async () => {\n  const myNum = await Promise.resolve(111);\n  return myNum + 222;\n}\nsomefunction()\n  .then(console.log) //333\n```\n\n글을 이해하셨다면, 333이 나올거란걸 예상하셨겠죠?\n\n하지만 아래의 예제를 봅시다\n\n```javascript\nconst somefunction = async () => {\n  const myNum = await 111;\n  return myNum + 222;\n}\n\nsomefunction()\n  .then(console.log) //???\n```\n\n다 같은데, await뒤의 표현식이 promise가 아니라 Number입니다.\n\nawait는 Promise객체를 기다리는 것인데.. 숫자가오면 어떻게 될까요?\n\nasync function에서 await 뒤의 표현식은 암묵적으로 Promise.resolve\\(\\)로\n\nwrapping되기 때문에, 첫번째 예제와 같은 333이 콘솔에 찍히게 됩니다.\n\n동기적으로 작동하는 것처럼 보여서 가독성이 향상됩니다.\n\n하지만 사실 비동기로 작동한다는 점,\n\n에러핸들링을 하려면, try-catch를 사용하여야 한다는 점에서 오히려 불편할 수도 있습니다.\n\nMozila의 문서에 await를 잘 이해할 수 있을만한 좋은 예제가 있습니다\n\n```javascript\nfunction resolveAfter2Seconds(x) {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve(x);\n    }, 2000);\n  });\n}\n\nasync function add1(x) {\n  const a = await resolveAfter2Seconds(20);\n  const b = await resolveAfter2Seconds(30);\n  return x + a + b;\n}\n\nadd1(10).then(v => {\n  console.log(v);  // prints 60 after 4 seconds.\n});\n\nasync function add2(x) {\n  const p_a = resolveAfter2Seconds(20);\n  const p_b = resolveAfter2Seconds(30);\n  return x + await p_a + await p_b;\n}\n\nadd2(10).then(v => {\n  console.log(v);  // prints 60 after 2 seconds.\n});\n```\n\nadd2는 타이머를 먼저 생성하고있죠?\n\nadd1은 첫번째 타이머를 생성하고 2초를 기다려서 결과값을 받아옵니다.\n\nadd2에서는 생성해둔 타이머를 동시에 시작합니다.\n\n그래서 거의 비슷해보이는데도, 시간에 차이가 있죠.\n\n두 개 이상의 Promise를 동시에 await 시키고 싶다면,\n\nPromise.all을 사용하면 됩니다.\n\n[그 예제는 여기에 있습니다.](/js/promise)\n\n## Tip - for문과 promise\n\n어떠한 상황에서는 어떤 iterable객체에서 iterate하며\n\npromise를 사용하고 싶을때가 있습니다.\n\n예를들어\n\n```javascript\nconst API_LIST = [url1, url2, url3, ...];\n```\n\n이런식으로 호출해야할 api가 여러개라고 한다면,\n\nfor문을 사용해서 promise를 호출하는데,\n\n가독성을 위해 async await를 사용하고 싶다고 가정합니다.\n\n```javascript\nasync function someFunction(urls) {\n  for (const url of urls) {\n    const res = await fetch(url);\n    // do something\n  }\n}\n```\n\n이런식으로 코드를 작성하게되면, 깔끔하군요!\n\n하지만 한가지 문제가 있습니다.\n\n첫번째 api를 호출하고, 기다렸다가 두번째 api를 호출합니다.\n\n그 이후로도 마찬가지겠죠..\n\n이렇게 되면 의미가 없죠? 그래서 해결방법을 가져왔습니다.\n\n```javascript\nasync function someFunction(urls) {\n  const somePromises = urls.map(url => {\n    return fetch(url);\n  });\n\n  for (const apiPromise of somePromises) {\n    const res = await apiPromise;\n    //do something with res\n  }\n}\n```\n\n이런식으로 작성하게된다면, 순차적으로 기다릴일은 없겠네요!\n\nreference: https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/async_function","src/content/docs/js/async-await.mdx","6aa8c000195e4b2d","js/coding-tips",{"id":674,"data":676,"body":681,"filePath":682,"digest":683,"deferredRender":15},{"title":677,"editUrl":15,"head":678,"template":17,"sidebar":679,"pagefind":15,"draft":19},"코딩 가이드 & 팁",[],{"hidden":19,"attrs":680},{},"# 코딩 가이드 & 팁\n\n## Swap\n\n변수의 값을 서로 바꿀때\n\nes6 이전\n```js\nvar a = 1;\nvar b = 2;\nvar temp = a;\na = b;\nb = temp;\n```\n\nES6\n```js\nlet a = 1;\nlet b = 2;\n[b, a] = [a, b];\n```","src/content/docs/js/coding-tips.mdx","a17f8e6ef2ab058e","js/constructor",{"id":684,"data":686,"body":691,"filePath":692,"digest":693,"deferredRender":15},{"title":687,"editUrl":15,"head":688,"template":17,"sidebar":689,"pagefind":15,"draft":19},"생성자",[],{"hidden":19,"attrs":690},{},"# Constructor \\(생성자\\)\n\n```javascript\nfunction Boseok(age) {\n    this.age = age;\n}\n```\n\n그냥 함수로 호출하는것과, new 연산자로 객체를 생성하는것에 무슨 차이가 있는지 볼까여?\n\n```javascript\nconst boseok = Boseok(123);\nconsole.log(boseok.age); //error\n```\n\n당연히 예상처럼 함수에 리턴하는게 없으므로 boseok객체는 undefined입니다.\n\n그래서 age를 참조할수없는 에러를 뿜어냅니다.\n\n하지만 new 연산자를 사용하면 다르게 작동합니다.\n\n```javascript\nconst boseok = new Boseok(123);\nconsole.log(boseok.age); //123\n```\n\nnew 연산자를 사용하면 함수를 생성자로 호출합니다. 명시적인 return 구문이 없다면, this가 가리키는 객체를 반환합니다.\n\nnew Boseok\\(\\)은 Boseok.prototype을 상속받은 new 연산자를 사용하여 Boseok 객체의 인스턴스를 생성합니다.\n\n그래서 또 다른 방법으로 인스턴스를 생성하는 방법은 아래와 같습니다.\n\n```javascript\nObject.create(Boseok.prototype)\n```\n\n생성자에 객체를 만들어서 명시적으로 return하면 new 연산자에 관계없이 동작하는 생성자를 만들 수 있습니다.\n\nnew 키워드가 빠졌을때 발생하는 this 참조 에러를 예방할 수 있습니다.\n\n팩토리를 사용했을때는 위처럼 장점도 있지만, 단점도 존재합니다.\n\n```\nprototype으로 메소드를 공유하지 않으므로 메모리를 좀 더 사용한다.\n팩토리를 상속하려면 모든 메소드를 복사하거나 객체의 prototype에 객체를 할당해 주어야 한다.\nnew 키워드를 누락시켜서 prototype chain을 끊어버리는 것은 아무래도 언어의 의도에 어긋난다.\n```\n\n## new 연산자와 관계없이 동작하게 만들기\n\n생성자는 new 연산자와 관계없이 동작하는게 좋습니다.\n\n위에서 활용했던 코드를 수정해보겠습니다.\n\n```js\n/* 기존코드\nfunction Boseok(age) {\n    this.age = age;\n}\n*/\nfunction Boseok(age) {\n    const self = this.instanceof Boseok ? this : Object.create(Boseok.prototype);\n    self.age = age;\n    return self;\n}\n```\n\n이런식으로 \n\n## 빌트인객체에서의 constructor (new 연산자)\n\n```js\nNumber(10)\nnew Number(10)\n```\n\n결론부터 이야기하자면 new 키워드와 함께 Number 같은 기본 타입의 생성자를 호출하면 객체를 생성하지만 new 없이 호출하면 형 변환만 시킨다.\n\n```js\nconst num = Number(10);\nconst numObj = new Number(10);\nconsole.log(typeof num); // number\nconsole.log(typeof numObj); // object\nconsole.log(num === numObj); // false\n```\n\n빌트인객체에 프로토타입을 추가하고 new 연산자를 썼을때, 안썼을때, Array.from으로 유사배열을 배열로 바꾼경우를 모두 확인해봤다.\n\n```js\nArray.prototype.test = 'test';\n\nconst arr1 = Array(10); // [empty x 10]\nconst arr2 = new Array(10); // [empty x 10]\n\nconst arrayLike = {\n    length: 3,\n    0: 'boseok',\n    1: 'boseok1',\n    2: 'boseok2',\n};\n\nconst arr3 = Array(arrayLike);\nconst arr4 = new Array(arrayLike);\nconst arr5 = Array.from(arrayLike);\nconsole.log(arr3.test); //test\nconsole.log(arr4.test); //test\nconsole.log(arr5.test); //test\n```\n\n유사배열을 형변환하려면 Array.from을 사용해야한다. 변환되지않는다.\n\n프로토타입까지 공유하는걸봐서 빌트인객체에서는 형변환 외에 차이가없는것같다.","src/content/docs/js/constructor.mdx","5cd1a7b00255893f","js/core",{"id":694,"data":696,"body":701,"filePath":702,"digest":703,"deferredRender":15},{"title":697,"editUrl":15,"head":698,"template":17,"sidebar":699,"pagefind":15,"draft":19},"자바스크립트 코어",[],{"hidden":19,"attrs":700},{},"# 자바스크립트 코어\n\n자바스크립트 핵심 개념 정리\n## 이벤트루프 \\(Event Loop\\), 태스크큐\n\njs는 싱글스레드인데 동시에 많은 이벤트들을 어떻게 처리할까?\n\njs는 기본적으로 싱글스레드기반 언어이다.\n\n이벤트루프는 콜스택과 태스크큐를 지켜보고있다가 콜스택이 비어있으면\n\n태스크큐에서 첫번째 이벤트를 콜스택에 넣어주는 일을하고, 그것을 tick이라고한다.\n\n콜 스택이 비어 있고 태스크 큐에 콜백 함수가 있는 경우, 함수는 큐에서 제외되고 실행될 콜 스택으로 푸시됩니다.\n\n이벤트루프는 ECMAScript의 스펙이 아니다. 구동 환경측에서 구현해야한다.\n\n그래서 노드는 비동기 io를 지원하기 위해 libuv라이브러리를 사용하는것이다.\n\n브라우저도 마찬가지로 자바스크립트 엔진외에 별도 구현체가 있을것이다.\n\n이 말은 자바스크립트 엔진은 하나의 콜스택만 사용한다는 뜻이다.\n\n결국 자바스크립트 언어설계자체는 싱글스레드이므로 block되는 코드가 존재한다면 그냥 block된다.\n\n크롬같은경우는 내부적으로 여러 스레드를 사용하는데, [그것은 여기에서..](/browser/chrome)\n\n---\n\n\n## 호이스팅\\(Hoisting\\)\n\n```javascript\nconsole.log(a); // undefined\nvar a = 1;\n```\n\n일반적인 언어에서 위의 예제코드를 실행한다면 에러가 날것이다.\n\njs에서는 특이하게도 선언전에 변수를 참조해도 에러가 아니다. \\(var한정\\)\n\nES6에서는 이런 문제를 해결하기위해 let 사용을 권장하고 있다.\n\n```javascript\nconsole.log(b); // ref error - not defined\nlet b = 1;\n```\n\n### 오해\n\n위의 설명에서 보는것과 같이 선언전에 참조할 수 있으므로\n\n```변수 선언```이나 ```함수```가 코드 상단으로 끌어올려지는 것처럼 보인다.\n\n하지만 끌어올려지는게 아니다.\n\n코드는 그 위치에 그대로 있다.\n\n### 진짜 개념\n\n```컴파일 단계```에서 스코프가 생성되고 변수나 함수가 차지할 메모리를 즉시 할당한다.\n\n이것이 호이스팅이다.\n\n그래서 스코프내에서 선언 전에 참조할수있고, 선언이 끌어올려지는 것처럼 보인다.\n\n그래서 위의 예제같은 코드가 있으면 변수선언의 경우 undefined가 뜨지만,\n\n아래 예시처럼 함수표현식이 아닌 함수선언식으로하면, 함수가 동작한다.\n\n_참고_\n\n함수표현식\n\n```javascript\na() // not working\nconst a = function() {\n  //...some code\n}\n```\n\n함수 선언식\n\n```javascript\na() // working\nfunction a() {\n  //...some code\n}\n```\n\n---\n\n## 실행컨텍스트\n\n실행컨텍스트란 실행 가능한 코드를 형상화하고 구분하는 추상적인 개념이다.\n\n컴파일단계에서 전역 컨텍스트가 생기고 [호이스팅](#호이스팅\\(Hoisting\\))이 일어난다.\n\nES6는 함수레벨과 블록레벨의 [렉시컬스코프](/js/scope/#lexical-scope-static-scope-dynamic-scope)이다.\n\n함수마다 각각의 함수 컨텍스트가 생성된다.\n\n그리고 함수가 리턴하면 그 함수의 컨텍스트가 사라진다.\n\n전역 컨텍스트는 프로그램이 종료되면 사라진다.\n\n컨텍스트는 전역컨텍스트부터 스택형태로 쌓인다.\n\n각 컨텍스트객체에는 **VO, scope chain, this** 라는 3가지 프로퍼티가 생성된다.\n\nVO\\(Variable Object\\) - [arguments](/js/arguments), parameter를 포함한 variable이 존재\n\n[scope](/js/scope) - 접근가능한 VO의 유효범위\n\n[scope chain](/js/scope/#스코프체인)\n\n[this](/js/this) - this는 기본적으로 전역객체를 가리킨다가 함수를 어떻게 호출하느냐에따라 할당되는값이 결정된다.\n\n\n[추가적으로 참고할만한 좋은 글](https://velog.io/@tmmoond8/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%94%EB%93%9C-%EA%B0%9C%EB%B0%9C%EC%9E%90-%EC%9D%B8%ED%84%B0%EB%B7%B0-%ED%9B%84%EA%B8%B0-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EC%A0%95%EB%A6%AC-%EC%9E%91%EC%84%B1-%EC%A4%91#5.-%EC%8B%A4%ED%96%89%EC%BB%A8%ED%85%8D%EC%8A%A4%ED%8A%B8)\n\n---","src/content/docs/js/core.mdx","5078ac8a19e6e0b1","js/es6",{"id":704,"data":706,"body":711,"filePath":712,"digest":713,"deferredRender":15},{"title":707,"editUrl":15,"head":708,"template":17,"sidebar":709,"pagefind":15,"draft":19},"ES6+",[],{"hidden":19,"attrs":710},{},"# ES6+\n\n간단 정리\n\n---\n\n## destructuring\n\n배열의 경우 순서가 중요합니다.\n```js\nconst [a, b] = [1, 2]; //a: 1 b: 2\n```\n객체의 경우는 키 이름이 중요합니다.\n```js\nconst {b, a} = {a: 1, b: 2}; //a: 1, b: 2\n```\n\n함수 파라미터도 destructuring 할 수 있습니다.\n```js\nfunction A({a, b}) {\n  return a + b;\n}\nA({a:1, b:2}); //3\n```\n\n---\n\n## rest\n\n[디스트럭쳐링](#destructuring)이나 함수 파라미터에서 나머지 변수들을 유용하게 컨트롤할 수 있습니다.\n\n아래 예제 2개에서는 destructuring과 함께 썼지만, rest라는 변수 이름에 주목하시면 됩니다.\n\n```js\nconst [a, b, ...rest] = [1, 2, 3, 4]; //a: 1 b: 2, rest: [3, 4]\n```\n객체의 경우는 키 이름이 중요합니다.\n```js\nconst {b, a, ...rest} = {a: 1, b: 2, c: 3, d: 4}; //a: 1, b: 2, rest: { c: 3, d: 4 }\n```\n\n함수 파라미터에도 rest 구문을 사용할 수 있습니다.\n```js\nfunction A(a, ...rest) {\n  return rest;\n}\nA(1, 2, 3, 4); //[2, 3, 4]\n```\n\n## spread\n\nspread는 rest와 반대로 생각하시면 편리합니다.\n```js\nconst obj = {\n  a: 1,\n  b: 2,\n  c: 3,\n};\n\nconst extObj = {\n  ...obj, //spread\n  d: 4\n};\n\nconsole.log(extObj); // {a: 1, b: 2, c: 3, d: 4}\n```\n배열도 당연히 같은 방법으로 사용합니다.\n\n```js\nconst arr1 = [1, 2];\nconst arr2 = [...arr1, 3, 4]; // [1, 2, 3, 4]\n```\n\n---\n\n## for in, for of \n\n아래 예제에서 보이는 것처럼,\n\nfor in 구문은 custom 프로토타입을 포함한 모든것을 순회하고,\n\nfor of 는 콜렉션에 대해서만 순회합니다.\n\n~~\\[Symbol.iterator\\] 속성이 있는 모든 컬렉션 요소~~\n\n```javascript\nArray.prototype.someArrayFunc = () => {};\n\nlet someArray = [1, 2, 3];\nsomeArray.boseok = 'boseok123';\n\nfor (let i in someArray) {\n  console.log(i); // 0,1,2 'boseok', 'someArrayFunc'\n}\n\nfor (let i of someArray) {\n  console.log(i); //1,2,3\n}\n```\n\nin 구문은 객체의 value를 나열하는게 아니라, key를 나열한다고 생각하면 됩니다.\n\n\n---\n\n## Map\n\n[Array.prototype.map은 여기서..](/js/arrayprototype/#arrayprototypemap)\n\nes6에는 map 객체가 새로 추가됐다.\n\n```js\nnew Map(iterable);\n```\n\n기존 object와 비슷하지만 여러 문제를 해결해주는객체다.\n\n기존 object처럼 키-밸류를 요소로 갖는다.\n\n하지만 첫번째로 다른점은 key에 string이 아닌 다른 어떠한 값이나 객체도 가능하다.\n\n(객체의 키에는 객체를 할당할수없고, number를 넣더라도 string으로 타입캐스팅된다.)\n\n조금 특이하게 NaN을 키로 지정할때, NaN !== NaN이지만, Map의 키에서는 동일하다고 간주한다.\n\n나머지 값들은 === 연산자의 결과를 따른다.\n\n두번째는 Map 객체는 iterable객체이다. 객체도 iterable을 구현하거나 비슷한 동작을 하게할수있지만, 번거롭다.\n\n세번째는 순서보장이다. object는 브라우저마다 순서가 다를수있고, 삽입순으로 순서의 정렬이 보장되지않는다.\n\n네번째는 속성의 숫자. size혹은 length의 판별이다. map은 size라는 프로퍼티를 제공한다. 객체는 직접 판별해야한다.\n\n다섯번째는 객체는 프로토타입을 가져서, 키의 충돌위험성이 있다.\n\n여섯번째로 키를 추가하거나 제거할때의 성능은 Map이 더 좋다.\n\n## Set\n\nes6에서 map뿐만아니라 Set 객체도 추가되었다.\n\nmap이 object와 비슷하다면, set은 array와 비슷하지다.\n\n```js\nnew Set(iterable);\n```\n\nmap처럼 아무값이나 넣을수있고, 순서보장을 해준다. NaN을 map과 동일하게 처리한다. 유사한 점이 많다.\n\n다른점은 Set 내의 값은 유일하다. 동일한 값을 넣으면 무시된다.\n\nSet을 이용해서 집합연산을 구현한 예제 (Array.from은 생략가능)\n\n```js\n// 합집합\nconst getCombinedSet = (list1, list2) => Array.from(new Set([...list1, ...list2]));\n\n// 차집합\nconst getDifferenceSet = (list1, list2) => {\n  const set2 = new Set(list2);\n  return Array.from(new Set(list1.filter(x => !set2.has(x))));\n};\n\n// 교집합\nconst getIntersectionSet = (list1, list2) => {\n  const set2 = new Set(list2);\n  return Array.from(new Set(list1.filter(x => set2.has(x))));\n};\n```\n\nMap이나 Set모두 iterable객체이므로 spread operator를 사용할수있다.\n\n즉,\n\n```js\n[...someMap, ...someSet]\n```\n\n이런 코드가 가능.\n\n---\n\n## 이터러블, 이터레이터 (Iterable, Iterator Protocol)\n\n직역하면 반복가능한(객체), 반복자 규약이다.\n\n즉, 반복에 대한 내용이다.\n\niterable하다는 것은 객체가 @@iterator 메소드를 구현했다는 것이고, Symbol.iterator 속성(함수)을 가져야한다는 것이다.\n\n## Iterator Protocol\n\n어떤 객체가 next() 메소드를 갖고 있고, (프로토타입이 갖고 있더라도)\n\nnext 메소드는 done, value라는 속성을 가진 객체를 리턴하면 그 객체는 iterator라고 할 수 있다.\n\ndone은 생긴것처럼 마지막 반복을 마쳤다면 true, 아니면 false이다.\n\nvalue는 iterator로부터 반환되는 값이다. done이 true일경우 undefined.\n\n```js\nconst arr = [1, 2, 3];\nconst iterator = arr[Symbol.iterator]();\niterator.next(); // {value: 1, done: false}\niterator.next(); // {value: 2, done: false}\niterator.next(); // {value: 3, done: false}\niterator.next(); // {value: undefined, done: true}\n```\n\n## Iterable 객체\n\nString, Array, TypedArray, Map, Set 은 내장 iterable 객체이다.\n\n커스텀 iterable 객체의 구현은 간단히 `[Symbol.iterator]` 만 구현하면 됩니다.\n\n```js\nconst obj = { a: 1, b: 2, c: 3 };\n\nobj[Symbol.iterator] = function() {\n  const keys = Object.keys(obj);\n  return {\n    index: -1,\n    next() {\n      this.index++;\n      return { value: obj[keys[this.index]], done: this.index >= keys.length };\n    }\n  };\n}\n\nfor(const v of obj) {\n  console.log(v);\n}\n```\n\niterable 구현을 위한 예시일뿐이다..\n\n실제로 for of 에서 객체를 쓰고싶다면 Object.entries() 메소드를 사용하도록하자.\n\n```js\nfor(const [key, value] of Object.entries(obj)) {\n  // ...some code\n}\n```\n\n## 제너레이터 객체 (Generator)\n\n제너레이터 객체는 제너레이터 함수(function*)가 반환하는 객체이다.\n\niterable, iterator protocol을 따른다.\n\n따라서 제너레이터를 통해서도 iterable 객체를 구현할 수 있다. (는 아래에서..)\n\n## 제너레이터 함수\n\n제너레이터 함수는 호출해도 즉시 실행되지않고 iterator객체를 반환한다.\n\niterator 객체의 `next`메소드를 호출하면 `yield`를 만날때까지 실행되다가 멈춘다. 이걸 반복한다.\n\n`yield*`을 만나면 다른 Generator 함수가 위임된다.\n\n## iterable 객체 구현\n\n```js\nconst obj = {};\nobj[Symbol.iterator] = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n};\n[...obj]; // [1, 2, 3]\n\nconst iterator = obj[Symbol.iterator]();\niterator.next(); // {value: 1, done: false}\n```\n\n```js\nconst generatorObj = function* () {\n  yield 1;\n  yield 2;\n  yield 3;\n}();\n[...generatorObj]; // [1, 2, 3]\n```\n\n이렇게 만들어진 iterable 객체는 Array.from() 메소드로 쓰거나,\n\nMap, Set 등에 활용할 수 있습니다.\n\n------------\n\n## template-literals\n\n백틱\\(\\`\\) - 숫자 1 왼편에 있는 특수문자\n\n자바스크립트에서 백틱내에 작성한 문자열들은\n\n표현식\\(expression\\)이 포함될 수 있습니다.\n\n```javascript\n`string` //string\n\nconst boseok = 'Boseok123';\n`string ${boseok} end` //string Boseok123 end\n```\n\n이런식으로 변수를 끼워넣을수도 있고,\n\n```javascript\nconst boseok = 'boseok';\n\n`some ${boseok.toUpperCase()} end` //string BOSEOK end\n```\n\n이런식으로 메소드 사용도 가능합니다.\n\n표현식이라면 뭐든지 넣을 수 있습니다.\n\n개행도 가능합니다.\n\n```javascript\n'boseok1\\n'+\n'boseok2'\n\n`boseok1\nboseok2`\n```\n\n## Tagged Templates\n\n태그를 사용하면 템플릿 리터럴을 함수로 파싱 할 수 있습니다.\n\n```javascript\nconst var1 = 'some var1';\nconst var2 = 'some var2';\nfunction someTag(strings, ...params) {\n  //strings => ['some ', ' is ', ' end']\n  //params => [var1, var2]\n  return 'something';\n}\nconst someOutput = someTag`some ${var1} is ${var2} end`;\nconsole.log(someOutput); //something\n```\n\n위의 예제처럼 파라미터로 문자열과 표현식이 넘어옵니다.\n\n함수를 선언해두고 특이한 방식으로 호출하고 있네요.\n\nreact styled-component에서 tagged template을 사용하기때문에,\n\nreact개발자라면 알아두는게 좋습니다.\n\n---","src/content/docs/js/es6.mdx","498d93f3e5b37c58","js/functional",{"id":714,"data":716,"body":721,"filePath":722,"digest":723,"deferredRender":15},{"title":717,"editUrl":15,"head":718,"template":17,"sidebar":719,"pagefind":15,"draft":19},"함수형 자바스크립트",[],{"hidden":19,"attrs":720},{},"# 함수형 자바스크립트\n\n요즘 함수형 프로그래밍이 인기가 많아서, 함수형 자바스크립트에 대해 간단하게 설명하려고 한다!\n\n우선 함수형 프로그래밍은 상태를 공유하는것과 데이터변조를\\(예상치 못한, 사이드이펙트\\) 방지할수있다.\n\n그리고 사실 함수형은 자바스크립트에서 중요한 컨셉중 하나다. \\(나머지 하나는 프로토타입\\)\n\n```\n1. 순수 함수\n2. 불변성\n3. 사이드이펙트 방지\n4. 단순한 함수의 구성\n5. 함수형 언어들: Haskell, Scala, Lisp, F Sharp, ...\n```\n\n## 순수 함수의 특징\n\n- 참조 투명성 => 함수가 동일한 입력을 받으면 동일한 출력을 내보낸다. => 외부 변수를 제거한다. => 전체 로직을 파악하기 쉽고 테스트가 쉽다.\n\n이어서..\n\n자바스크립트가 함수형을 지원하는 기능들\n\n자바스크립트에서 함수는 일급객체이다.\n\n고차함수와 FP기법(커링.. etc)을 활용\n\n## high order funtion\n\n1. 함수를 파라미터로 전달받는 함수\\(functions as arguments\\) =&gt; Array.prototype.map 을 떠올리면 된다.\n2. 함수를 리턴받는 함수\\(functions as values\\) =&gt; 커링을 생각하시면 된다.\n\n## 순수함수\n\n같은 input이라면 항상 같은 리턴값을 가지는 함수.\n\n외부의 값을 변경하지않는다. Date.now 같은 함수도 내부에서 사용하지않고(호출할때마다 매번 결과값이 달라지므로), Disk IO, network IO등 사이드이펙트가 없어야한다.\n\n조합하기좋다. 함수를 다른함수의 인자로 넘길수있다.\n\n모듈화하기좋고 테스트코드작성하기 좋다.\n\n함수들이 단순해진다.\n\n결국 안전한 함수를 추구하는것이다.\n\n함수형 자바스크립트라는 책에서는 아래처럼 설명하고 있습니다.\n\n```\n- 주어진 입력에만 의존할 뿐,평가 도중 또는 호출 간 변경될 수 있는 숨겨진 값이나 외부상태와 무관하게 작동합니다.\n\n- 전역 객체나 레퍼런스로 전달된 매개변수를 수정하는 등 함수 스코프 밖에서 어떠한 변경도 일으키지 않습니다.\n```\n\nside-effect\n```\n• 전역 범위에서 변수,속성，자료구조를 변경\n• 함수의 원래 인수 값을 변경\n• 사용자 입력을 처리\n• 예외를 일으킨 해당 함수가 붙잡지 않고(catch) 그대로 예외를 던짐(throw)\n• 화면 또는 로그 파일에 출력\n• HTML 문서， 브라우저 쿠키， DB에 질의\n```\n\n## 커링\n\n함수의 인수를 미리 세팅하거나 부분 평가하기 위해 함수 기능을 추상화한다.\n\n여러 함수들로 분리하여 함수 크기를 줄이고, 함수의 합성을 쉽게하여 재활용성을 높일 수 있습니다.\n\n함수를 합성하려면 side-effect가 없어야합니다.\n\n필요한 것은 인수를 통해 전달받습니다.","src/content/docs/js/functional.mdx","e0966a3507e06919","js/host-object",{"id":724,"data":726,"body":731,"filePath":732,"digest":733,"deferredRender":15},{"title":727,"editUrl":15,"head":728,"template":17,"sidebar":729,"pagefind":15,"draft":19},"호스트 객체",[],{"hidden":19,"attrs":730},{},"# 호스트 객체\n\n호스트 객체(Host object)는 window, document, XMLHTTPRequest 등과 같이 런타임 환경 \\(브라우저 또는 노드\\)에 의해 제공됩니다.","src/content/docs/js/host-object.mdx","e56ff2a47eec26f0","js",{"id":734,"data":736,"body":741,"filePath":742,"digest":743,"deferredRender":15},{"title":737,"editUrl":15,"head":738,"template":17,"sidebar":739,"pagefind":15,"draft":19},"Javascript",[],{"hidden":19,"attrs":740},{},"js는 브라우저에서 다양한 인터렉션을 위해 탄생한 언어입니다.\n\n단시간에 만들어진 언어라 설계에 몇몇 문제가 있지만, 그럼에도 불구하고 브라우저에서 동작하는 언어로서 특히 fe개발자에게 중요한 언어입니다.\n\nJavascript 개발자들이 알아야할 기본적인 것들을 정리해놨습니다.\n\n[리스트에 없는 몇몇 브라우저의 API는 여기서 소개합니다](/browser)\n\n아래는 핵심적인 개념들을 설명합니다.\n\n## 프로그래밍 패러다임\n\n1. 프로토타입기반의 상속모델과 객체지향 프로그래밍\n2. [함수형 프로그래밍](/js/functional/)\n3. 동적이고 유연하다\n\n## 클래스 상속모델과 프로토타입 상속모델\n\n핵심은 프로토타입 상속모델로 클래스상속모델을 구현하는것은 매우 간단한 일이고, \\(실제로 ES6엔 class 키워드가 있다.\\)\n\n반대로 클래스 상속 모델로 프로토타입 상속모델을 구현하는것은 매우 힘든 일이다.\n\n## 비동기란? 그리고 자바스크립트에서 이것이 중요한 이유\n\n비동기 프로그래밍이란 엔진이 이벤트루프에서 실행된다는 의미이다.\n\n동기적인 프로그래밍에서는 네트워크 요청이나 disk io 같은 시간이 오래걸리는\n\n작업들이 실행되면 처리가 완료될때까지 블로킹된다.\n\n싱글스레드를 채택하는 자바스크립트의 특징에서, 무거운 작업을 만나서 블로킹이 된다면,\n\n다음작업을 실행할수없다. 브라우저상에서 네트워크 요청중에 아무작업도 할 수 없다면 얼마나 불편할까?\n\n그래서 비동기가 등장하게 됐다.\n\n노드에서도 기본적으로는 동시에 여러작업을 할 수는 없겠지만\\(워커를 사용하면 가능\\), 네트워크요청을 기다리고 처리하는동안 다른 리퀘스트를 받는 정도는 가능하다는 것이다. 비동기의 우수성은 이미 다른 언어나 환경에서도 채택할정도로 이미 입증됐다.\n\n## Just In Time Compilation (JITC)\n\n현재 메이저 브라우저의 js엔진은 인터프리터가 아닌 JITC입니다.\n\n자바스크립트 코드를 파싱하여 bytecode 형태로 변환하고, 기본적으로는 인터프리터가 한줄씩 코드를 해석 실행하지만 자주 반복되는(Hot Spot)이라면 native code로 컴파일하여 실행합니다.\n\n[V8엔진의 Bytecode를 더 이해하고싶다면..](https://medium.com/dailyjs/understanding-v8s-bytecode-317d46c94775)\n\nnodejs는 8.x버전대 이상을 사용한다면 바이트코드를 직접 프린트해볼수도있습니다.\n\n```bash\nnode --print-bytecode --eval 1+1\n```","src/content/docs/js/index.mdx","2de41770b380d7fc","js/inherit",{"id":744,"data":746,"body":751,"filePath":752,"digest":753,"deferredRender":15},{"title":747,"editUrl":15,"head":748,"template":17,"sidebar":749,"pagefind":15,"draft":19},"inherit",[],{"hidden":19,"attrs":750},{},"# 상속\n\nES5\n```js\nfunction Person(name, age) {\n  this.name = name;\n  this.age = age;\n}\n```\n\n```js\nfunction Student(name, age, grade) {\n  Person.call(this, name, age);\n  this.grade = grade;\n}\n\nStudent.prototype = Object.create(Person.prototype);\n// Object.create() 메서드는 지정된 프로토타입 객체 및 속성(property)을 갖는 새 객체를 만듭니다.\n// Object.create(proto[, propertiesObject])\nStudent.prototype.constructor = Student;\n// 확인!\nconst student = new Student('boseok', 10, 'SSS');\nstudent instanceof Student; // true\nstudent instanceof Person; // true\n```\n\n---\n\nES6\n```js\n// ES\nclass Student extends Person {\n  constructor(name, age, grade) {\n    super(name, age);\n    this.grade = grade;\n  }\n}\n```\n\n```js\n// ES6\nclass Person {\n  constructor(name, age) {\n    this.name = name;\n    this.age = age;\n  }\n}\n```","src/content/docs/js/inherit.mdx","d548964f0c38752d","js/module",{"id":754,"data":756,"body":761,"filePath":762,"digest":763,"deferredRender":15},{"title":757,"editUrl":15,"head":758,"template":17,"sidebar":759,"pagefind":15,"draft":19},"js module",[],{"hidden":19,"attrs":760},{},"## export, import\n\n### es6 모듈\n\nexport, import\n\nes6모듈의 import 키워드와 webpack, parcel같은 번들러의 dynamic import 메소드를 구분하자.\n\n### nodejs 모듈\n\ncommonJS와 거의 동일하지만 자체적인 모듈을 사용\n\n```\nmodule.exports\n\nrequire()\n```\n\n## export와 코드의 실행순서\n\nconstants들을 따로따로 구분지어서 작성해놓았을때, 서로 import해야하는 상황이 온다.\n\n그럴때 import를 해도 undefined가 나오는경우가 간혹있는데,\n\n당연히 실행순서에 문제가 있기때문이다.\n\n```js\nconsole.log(\"1\");\nexport * from \"./someConstants\";\n```\n\n```js\n// someConstants.js\nconsole.log(\"2\");\n```\n\n콘솔에는 1 2 어떤 것이 나올지 헷갈릴수있는데, 2 1로 나온다.\n\n\"export\" 하는시점에 값을 추출해온다.\n\n## import \\* as \\{Alias}, import \\{Alias} 차이\n\n```js\n// a.js\nexport const a = 1;\nexport const b = 2;\nexport default 3;\n```\n\n```js\nimport A from \"./a\";\nimport * as B from \"./a\";\nconsole.log(A); //3\nconsole.log(B); //Module {a:1, b:2, default:3, ...}\n```","src/content/docs/js/module.mdx","72e3e134d3cbfa49","js/number",{"id":764,"data":766,"body":771,"filePath":772,"digest":773,"deferredRender":15},{"title":767,"editUrl":15,"head":768,"template":17,"sidebar":769,"pagefind":15,"draft":19},"Number",[],{"hidden":19,"attrs":770},{},"# Number\n\njs에서는 정수 값과 실수 값의 타입을 구분하지않는다.\n\n그래서 js는 모든 숫자를 실수로 표현하고 IEEE 754 표준에서 정의한 ```64비트 실수``` 형태로 표현한다.\n\n```+-2의 53```승 사이의 정수 값을 정확하게 표현할 수 있다.\n\n(하지만 배열 인덱싱이나 비트 연산은 32비트 정수로 수행한다고 한다.)\n\n### 부동소수점\n\n부동소수점 리터럴은 실수를 표현하는 전통적인 문법을 따른다.\n\n실수는 정수 부분과 소수점, 소수점 이하 부분으로 표현한다.\n\n자바스크립트에서 실수 연산을 할 때는 근사 값으로 표현한다.\n\n위에서 언급한 IEEE-754 부동소수점 표현방식은 1/2, 1/8, 1/1024 같은 분수를 정확하게 표현할 수 있는 이진 표현법(binary representation)이다.\n\n이 표현 방식은 고정소수점에 비해 더 넓은 범위의 숫자를 표현할 수 있다는 큰 장점이 있다.\n\n고정소수점은 본래 10자리를 표현할 수 있던 자료형의 5자리를 떼어 소수부에 나눠준다면\n\n그 자료형이 표현할 수 있는 수의 범위는 정수부 기준 다섯자리밖에 안된다는 뜻이다.\n\n예를 들면 0.003 과 같은 값을 3x10^-3 과 같은 방법으로 표기한다.\n\n하지만 컴퓨터는 10 제곱은 사용할 수 없고, 이진법을 사용하므로 가장 많이 사용하는 1/10(0.1)과 같은 간단한 값인 10진 분수는 정확하게 표현할 수 없다. (2제곱의 분수만 정확하게 표현한다.)\n\n따라서 정확하게 표현할 수 없는 숫자인 이 녀석들은 ```0.1 + 0.2 === 0.3 // false``` 과 같은 결과를 볼 수 있다.\n\n---\n\nref: js완벽가이드 책, 삼성sw멤버쉽블로그","src/content/docs/js/number.mdx","5252b5a21d9bacc8","js/object-literal",{"id":774,"data":776,"body":781,"filePath":782,"digest":783,"deferredRender":15},{"title":777,"editUrl":15,"head":778,"template":17,"sidebar":779,"pagefind":15,"draft":19},"객체 생성",[],{"hidden":19,"attrs":780},{},"# Object literal, new Object\n\n## 객체 생성의 두가지 방법과 차이\n\n```\n객체를 생성할때, new Object, {} 두 가지 방법으로 객체를 생성한다.\n두가지 방법에 대해 얼핏 봤을때 차이가 없어보이고, 일반적으로 리터럴 방법으로 객체를 생성한다.\n그리고 그 어디에도 이런 차이점에 대해서는 별로 설명하고 있지않다.\n(사실 내용이 별로 없고 당연해서 설명할 필요도 없긴하다.)\n하여튼 차이점에 대해 아래에 정리해보려고한다.\n```\n\n## new 연산자를 사용해서 객체를 만드는 경우\n\n### 유리한점\n\n```\n프로토타입상속을 활용할때 유용하다.\n(리터럴 구문으로 객체를 생성하면 상속체인을 관리하기 힘들다.)\n프로토타입 메소드가 많다고 가정하면 이해하기쉽다.\n```\n\n### 불리한점\n\n```\n실제로 얼마 차이가 나진않지만 코드가 더 길고 귀찮다.\n객체를 생성할때 속도가 리터럴 방식보다 느리다.\n```\n\n끄읏.","src/content/docs/js/object-literal.mdx","697aec0406019a30","js/optimizing",{"id":784,"data":786,"body":791,"filePath":792,"digest":793,"deferredRender":15},{"title":787,"editUrl":15,"head":788,"template":17,"sidebar":789,"pagefind":15,"draft":19},"최적화",[],{"hidden":19,"attrs":790},{},"# 자바스크립트 최적화\n\n최적화하는 방법은 너무나 많고, 당연한 것들은 쉽게 지나칠수있으니 조금씩 추가하도록 하겠습니다.\n\n1. 쓸데없는 변수의 사용을 줄여서 메모리관리\n\n2. 동기와 비동기함수를 고를수있는 상황이라면 대부분의 경우 비동기 함수를 고르는게 좋다.\n\n3. 객체의 프로퍼티를 읽을때 소소한 최적화.\n\n아래의 코드를 보자.\n\n이런식으로 미세하지만 조금 더 효율적인 코드로 변경할 수 있다.\n\n```js\nfunction someFunc() {\n  const { scrollX, scrollY } = window;\n  // ...some code\n}\n```\n\n위의 코드 또한 아주 무거운 window객체에서 프로퍼티를 여기저기서 매번 읽을거라면\n\n변수에 담아두고 활용하면 효율적이고, 코드도 깔끔하다. 프로퍼티 참조하는것도 비용이다.\n\n# memory leak (메모리릭)\n\n메모리릭은 더 이상 '닿을 수 없는' 참조가 해제되지 않을 때(gc가 일어나지 않아서) 발생한다.\n\n쉽게 말해서 쓸데없이 자원을 낭비하고 있는거다.\n\n어떤 변수를 썼을때 자동으로 해제되지않는 경우들이다. (그래서 원시타입 변수는 무시하면 된다.)\n\n- 전역변수는 당연히 쓰지마라.\n\n- 타이머는 사용하고나면 clear해야한다.\n\n- 클로져는 해제하지않는 참조변수가 있으므로 필요한곳에만 적당히 쓰자.\n\n- 이벤트리스너를 add하고 remove하지 않은 경우\n \n- dom tree에서 삭제했지만 dom node에는 남아있는 경우\n\n## hotspot - 자주 반복돼서 수행되는 구간\n\njit 컴파일 오버헤드. hotspot이 많을때 유리하다. 컴포넌트 기반 개발 방식은 코드를 재활용하기 좋다. jit컴파일이 코드를 최적화하는 오버헤드가 있더라도, 기존 코드를 재활용하여 개발하면, 성능상 이점을 가져올수있다.\n\njit컴파일이 코드를 최적화할때 오버헤드가 발생한다. (보다 효율적인 로직으로 코드를 실행하기위해서) 그런데 js는 페이지 레이아웃을 건드리거나, 사용자 입력에 반응하는 방식의 프로그램이 많은데, 한두번만 수행되는 코드가 많으면, 비효율적이다. 왜냐면 위에서 언급했듯이, 코드를 실행하기전에 컴파일러가 코드를 최적화하는데 드는 오버헤드가 있으므로. 그런데 컴포넌트 기반 개발을 하면서 코드가 재활용되는 경우가 많으므로. 한번이상 활용되는 함수같은것은 따로 빼서 관리하는것이, 최적화과정을 한번만 거치기때문에 유리하다. 깨끗한코드와 협업을 위해서도 좋다.\n\nadaptive jitc 는 타입프로파일링을 수행하므로, 변수의 타입이 변하지않는다면 높은 성능을 얻을수있다.\n\njs는 타입이 없다. 하지만 엔진 내부적으로는 타입이 존재한다. profiler는 사용되는 변수들의 타입이나 값을 profile해 두었다가 optimizing jit를 적용할때 이들 정보를 이용하여 예전 jitc에서 생성했던 예외처리 루틴들을 대폭 생략한 효율적인 코드를 생성한다. 이런 코드를 생성할때, 예외적으로 loop를 n번 수행하는동안 x라는 변수가 계속 int였다가, 그다음 iteration에서 갑자기 string으로 바뀌어버리는 경우, optimizing jitc로 생성된 그 효율적이었던 코드는 유효하지않게된다. 그래서 다시 예전 baseline-jitc로 생성한 코드로 수행하게된다. 예외상황이 발생하면 overhead가 커진다.\nTypescript와 함께 형변환을 최대한 줄이면 실제로 성능이 좋아진다.\n\nprofiling을 수행하는동안 특정변수의 타입이 변하지않으면, 그 이후에도 그 변수는 타입이 변하지않을 가능성이 높다 라는 가정하에 최적화를 하기때문에, js에서 변수의 타입을 바꾸는것은 성능상 매우매우 좋지않다. 따라서 변수의 타입을 바꾸지말아야한다. 변수의 타입이야기가 나왔는데, ==는 변수의 타입이 다르면 변환후 비교하기때문에 명시적으로 변환하여 ===로 비교하는게 낫다.","src/content/docs/js/optimizing.mdx","7deec3cf4a975721","js/phaser3",{"id":794,"data":796,"body":801,"filePath":802,"digest":803,"deferredRender":15},{"title":797,"editUrl":15,"head":798,"template":17,"sidebar":799,"pagefind":15,"draft":19},"Phaser3",[],{"hidden":19,"attrs":800},{},"# Phaser3\n\nPhaser3 js 게임엔진에 대한 포스트입니다.\n\n\n# 물리엔진\n\n## Arcade Physics\n\nArcade Physics는 Phaser에서 기본적으로 제공하는 물리엔진이다. Arcade Physics는 물리엔진이라고 하기에는 너무 단순하고, 무거운 물체들의 충돌을 계산하는데는 적합하지 않다. 하지만, 빠르고 간단하게 충돌을 계산할 수 있기 때문에, 게임의 대부분의 요소들에 적합하다.\n\n```Physics.body.setImmovable()``` 메서드를 사용하면, 물리엔진이 해당 물체를 움직이지 않도록 할 수 있다.\n\nimmovable이 설정된 객체들끼리의 collider를 설정하면 서로 충돌이 발생하지 않는다.\n\n---\n# UI 만들기\n\nPhaser3에서 UI를 쉽게 만들고 관리하는 방법에 대해 정리하려고 한다.\n\n## UI Scene 분리하기\n\nUI만을 위한 Scene을 만들어서 관리하는 것이 좋다.\n\n단순히 Scene을 하나 추가하고 scene을 launch하는 것으로 UI Scene을 분리할 수 있다.\n\nUI만의 Scene을 갖게되면 코드를 분리할 수 있고, UI를 show, hidden처리, camera zoom에 영향을 안받게 하는 처리등 제어가 쉬워진다.\n\n```js\n// in InGameScene create method\nthis.scene.launch('InGameUIScene');\n```\n\n## 타이머 예제\n\n뷰포트 상단에 타이머를 표시하고, 타이머가 끝나면 callback을 호출하는 예제이다.\n\n```js\n// InGameUIScene.ts\ncreateTimer(min: number, callback: () => void) {\n  let remainingTime = min * 60;\n  const inGameScene = this.scene.get('InGameScene') as InGameScene;\n\n  const remainingTimeText = this.add\n    .text(this.cameras.main.centerX, 10, convertSecondsToMinSec(remainingTime), {\n      fontSize: '20px',\n      color: '#ffffff',\n      stroke: '#000000',\n      strokeThickness: 2,\n    })\n    .setOrigin(0.5, 0)\n    .setScrollFactor(0);\n\n  const timer = this.time.addEvent({\n    delay: 1000,\n    callback: () => {\n      if (inGameScene.player.body.isDestroyed()) {\n        return;\n      }\n      remainingTime--;\n      remainingTimeText.setText(convertSecondsToMinSec(remainingTime));\n      if (remainingTime \u003C 0) {\n        callback();\n        remainingTimeText.destroy();\n        timer.destroy();\n      }\n    },\n    loop: true,\n  });\n}\n```\n\n```js\n// InGameScene.ts\nconst inGameUIScene = this.scene.get('InGameUIScene') as InGameUIScene;\ninGameUIScene.createTimer(10, () => {\n  // do something when timer is over\n});\n```\n\n## DOM을 이용한 UI그리기\n\nhtml의 button이나 input처럼 interaction이 필요하다면 DOM을 이용한 방법이 좋고, interaction이 필요하지 않다면 Phaser의 Graphics를 이용한 방법이 좋다.\n\nDOM을 이용한 방법은 Phaser의 Scene에 DOM을 추가하는 방법이다.\n\nDOM을 추가하는 방법은 다음과 같다.\n\n```javascript\nthis.add.dom(x, y, element);\n```\n\nDOM을 추가하면 Phaser의 Scene에 DOM이 추가되고, Phaser의 Scene에 추가된 DOM은 Phaser의 Scene에 추가된 Sprite처럼 Phaser의 Scene에 추가된다.\n\n프론트 개발자라면 DOM을 이용한 방법이 더 친숙할것이다. API가 매우 유사하기 때문이다.\n\nHTML element는 실제 html로 작성하고, phaser에서 불러오면 된다.\n\n```js\nthis.load.html('upgrade', 'phaser/upgrade.html');\n\nnew Phaser.GameObjects.DOMElement(scene, 50, 50).createFromCache('player_state');\n```\n\nhtml, body 등의 태그도 굳이 필요없다. 실제 필요한 코드조각만 추가하자.\n---\n\n# 바닥 만들기\n\n어떤 아케이드 게임을 만든다고 가정했을때, 적들이 부딪혀도 피해를 받지않는 바닥이 필요할때 유용할거같은 코드다.\n\ntiled에서 오브젝트 레이어를 생성하고 그 좌표에 rect를 생성한다.\n\n```js\nconst safeAreaPoints = map.filterObjects(\"SafeArea\", ({ name }) => {\n  return name.includes(\"SafeArea\");\n});\n```\n\n맵에서 필터링된 오브젝트들(여러개라면)의 좌표를 가져온다.\n\n```js\nthis.safeAreas = safeAreaPoints.map(({ x, y, width, height }) => {\n  const safeArea = this.add.rectangle(x, y, width, height);\n  // safeArea.setFillStyle(0x00ff00, 0.5);\n\n  return new Phaser.Geom.Rectangle(\n    safeArea.x,\n    safeArea.y,\n    safeArea.width,\n    safeArea.height\n  );\n});\n```\n\n좌표를 가져와서 ```Phaser.Geom.Rectangle``` 객체를 생성한다.\n\n눈으로 확인하고싶다면 ```setFillStyle``` 메서드를 사용해서 색을 채워보자.\n\n```js\nconst isSafe = this.safeAreas.some((safeArea) => {\n  return Phaser.Geom.Rectangle.Contains(\n    safeArea,\n    this.player.x,\n    this.player.y\n  );\n});\n```\n\n```Contains``` 메서드를 사용해서 플레이어의 좌표가 safeArea에 포함되어있는지 확인한다.\n\n이런 방법으로 활용해보면 좋다.\n\n\n---\n# tiled\n\ntiled map editor를 사용하여 맵을 만들고, Phaser에서 사용하는 방법을 알아보자.\n\n## tiled map editor\n\ntiled map editor는 맵을 만들어주는 툴이다. [tiled map editor](https://www.mapeditor.org/)에서 다운로드 받을 수 있다.\n\n## Phaser에서 tiled map editor 사용하기\n\n### 맵 만들기\n\ntiled map editor를 실행하고, 새로운 맵을 선택한다. encoding은 base64(uncompression)로 설정\n\n맵을 완성하고나면 별도로 export 할 필요는 없고 json타입으로 저장해두면 된다.\n\n### Phaser에서 맵 사용하기\n\n```js\npreload() {\n  this.load.tilemapTiledJSON(\"map4\", \"assets/tiled/3.json\");\n  this.load.image(\"Terrian\", \"assets/tiled/Tile1.0.1/Terrian.png\");\n  this.load.image(\"vegetation\", \"assets/tiled/Tile1.0.1/vegetation.png\");\n  this.load.spritesheet(\"player\", \"assets/Char2/Char2_idle_16px.png\", {\n    frameWidth: 16,\n    frameHeight: 16,\n  });\n  this.load.spritesheet(\"exit\", \"assets/tiled/Tile1.0.1/Dungeon.png\", {\n    frameWidth: 16,\n    frameHeight: 16,\n    startFrame: 86,\n    endFrame: 86,\n  });\n  this.load.spritesheet(\"pixel_animals\", \"assets/pixel_animals.png\", {\n    frameWidth: 16,\n    frameHeight: 16,\n  });\n}\ncreate() {\n  const map = this.make.tilemap({\n    key: \"map4\",\n  });\n  const vegetationTiles = map.addTilesetImage(\"vegetation\", \"vegetation\");\n  const terrianTiles = map.addTilesetImage(\"Terrian\", \"Terrian\");\n  map.createLayer(\"bg\", terrianTiles);\n\n  const collision_layer = map.createLayer(\"bg_collision\", [\n    terrianTiles,\n    vegetationTiles,\n  ]);\n  collision_layer.setCollisionByExclusion([-1]);\n\n  const playerSpawnPoint = map.findObject(\"PlayerSpawn\", ({ name }) => {\n    return name === \"PlayerSpawn1\";\n  });\n  const exitPoint = map.findObject(\"Exit\", ({ name }) => {\n    return name === \"Exit\";\n  });\n  const duckSpawnPoints = map.filterObjects(\"Duck\", ({ name }) => {\n    return name.includes(\"Duck\");\n  });\n}\n```\n\njson파일을 로드한다고해서 tiled 에디터에서 사용했던 이미지 바이너리가 json에 포함될리가 없으므로 같이 로드해줘야한다.\n\n특이점으로는 ```this.make.tilemap``` 에서 key는 씬에 관계없이 고유한 값이어야한다.","src/content/docs/js/phaser3.mdx","5fe5c628ad85feb3","js/promise",{"id":804,"data":806,"body":811,"filePath":812,"digest":813,"deferredRender":15},{"title":807,"editUrl":15,"head":808,"template":17,"sidebar":809,"pagefind":15,"draft":19},"Promise API",[],{"hidden":19,"attrs":810},{},"# Promise\n\nES6에서 표준이 된 스펙입니다.\n\n비동기 동작이 완료된 후 결과 값이나 실패를 handling하기 유용합니다.\n\n### Promise의 상태\n\n1. 대기\\(pending\\): 이행되거나 거부되지 않은 초기 상태.\n2. 이행\\(fulfilled\\): 연산이 성공적으로 완료됨.\n3. 거부\\(rejected\\): 연산이 실패함.\n\n_**Promise는 thenable 하다**_\n\nPromise는 then 메소드로 결과값을 받을 수 있습니다.\n\n이것을 thenable하다고 표현합니다.\n\n```javascript\nPromise.prototype.then(onFulfilledCallback, onRejectedCallback)\n```\n\npromise객체는 then메소드로 체이닝하여 값을 반환 받을 수 있고 에러 콜백 또한 존재합니다.\n\nthen은 promise객체를 반환합니다\n\n```javascript\nPromise.prototype.catch(onRejectedCallback)\n```\n\n에러제어를 위한 catch 메소드도 존재합니다.\n\nthen처럼 체이닝할수있습니다.\n\ncatch도 then처럼 promise객체를 반환합니다.\n\n### Promise 생성 방법\n\n```javascript\nfunction post(uriParams, body) {\n    return new Promise((resolve, reject) => \n      fetch(`${BASE_URL}/${uriParams}`, {\n        method: 'POST',\n        headers: {'Content-Type': 'application/json'},\n        body: JSON.stringify(body)\n      }).then(res => res.json())\n        .then(res => resolve(res))\n        .catch(err => reject(err))\n    );\n  }\n```\n\n```javascript\n//call\npost(${url}, {boseok: 'fe'}).then(res => {...});\n```\n\n[fetch API](/browser/fetch)에서 설명했던 예제 코드입니다.\n\nPromise의 생성자에 Callback이 있죠?\n\n파라미터로는 resolve, reject가 있습니다.\n\n원하는 결과값을 resolve하면 되고, 에러는 reject하면 됩니다.\n\nreject는 보통 오류객체를 반환합니다.\n\n### 더 간단한 예제\n\n```javascript\nconst myPromise = () => {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      resolve('2second');\n    }, 2000);\n  });\n};\n\nmyPromise()\n  .then(res => console.log('myPromise', res))\n```\n\n약 2초후 myPromise 2second가 콘솔에 찍히는 예제입니다.\n\n간단하면서도 아주 강력하죠?\n\n### 그 외 메소드들\n\n```javascript\nPromise.all(iterable)\n/*\niterable 내의 모든 프로미스가 이행한 뒤 이행하고, 어떤 프로미스가 거부하면 즉시 거부하는 프로미스를 반환합니다.\n이 말은 reject가 있으면 reject를 반환하고, resolve되면 resolve된 값들을 배열로 반환한다는 의미입니다.\n이 메서드는 여러 프로미스의 결과를 모을 때 유용합니다.\n아래 예제가 있습니다.\n*/\nPromise.race(iterable)\n//iterable 내의 어떤 프로미스가 이행하거나 거부하는 즉시 스스로 이행하거나 거부하는 프로미스를 반환합니다. \n// 예를 들어, 프로미스가 여러개있을때 어떤 프로미스가 작업이 끝나면, 다른 프로미스들은 resolve 혹은 reject 되지않는다는 의미입니다. 이걸 활용하면 프로미스에 타임아웃을 구현할수있습니다.\nPromise.reject(reason)\n//주어진 이유로 거부하는 Promise 객체를 반환합니다.\nPromise.resolve(value)\n/*\n주어진 값으로 이행하는 Promise 객체를 반환합니다.\n*/\n```\n\n아래의 스크린샷은 Promise.all을 사용한 예제입니다.\n\n\u003Cimg src=\"/images/promise-all-resolve.png\"/>\n\u003Cimg src=\"/images/promise-all-reject.png\"/>\n\n## Promise.race 예제\n\n```javascript\nconst p1 = () => new Promise(resolve => {\n  console.log('p1');\n  setTimeout(()=>{\n    resolve('p1 resolved');\n  }, 1000);\n});\n\nconst p2 = () => new Promise(resolve => {\n  console.log('p2');\n  setTimeout(()=>{\n    resolve('p2 resolved');\n  }, 2000);\n});\n\nconst result = Promise.race([p1(), p2()]).then(console.log);\n```\n\n위 코드는 순서대로 콘솔에\n\n```bash\np1\np2\np1 resolved\n```\n\n이렇게 프린팅합니다\n\nreference: https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise","src/content/docs/js/promise.mdx","9b37fd3d8091994c","js/prototype",{"id":814,"data":816,"body":821,"filePath":822,"digest":823,"deferredRender":15},{"title":817,"editUrl":15,"head":818,"template":17,"sidebar":819,"pagefind":15,"draft":19},"프로토타입 (prototype)",[],{"hidden":19,"attrs":820},{},"# 프로토타입 (prototype)\n\n```\n프로토타입을 공유하면 객체간에 속성이나 메소드를 공유할 수 있습니다.\n\n생성자로 객체를 생성하지않고, 팩토리 패턴으로 객체를 생성할때는\n\n속성을 공유하지않으므로 메모리를 조금 더 사용한다.\n```\n\n보통 클래스 스타일의 상속 모델을 사용하는데, 자바스크립트는 역시나 특이하게도 프로토타입 상속모델을 사용합니다.\n\n스코프에도 체인이 있듯이, 프로토타입에도 체인이 있습니다. 이것으로 상속을 구현합니다.\n\n그리고 자바스크립트에는 메소드가 없지만, 편의상 속성에 함수가 바인딩 된거라면 메소드라고 하겠습니다.\n\n## 프로토타입 체인\n\n```\n객체에서 어떤 프로퍼티를 참조하려고할때(in 연산자, iterate 포함), \n\n그 객체 자체 속성을 탐색하다가 못 찾으면 자신의 프로토타입에서 속성을 찾고, 그것을 반복한다.\n\n`[[Prototype]]`이라는 private 속성은 자신의 프로토타입이 되는 다른 객체를 가리킨다.\n\n만약 프로토타입을 계속 거슬러 올라가다가\n\nnull을 프로토타입으로 가지는 오브젝트를 만나면 그제서야 프로퍼티 참조를 멈춘다.\n```\n\n자바스크립트 콘솔에서 객체를 열어본적 있으신가요?\n\n```javascript\nconsole.log(window);\n```\n\n이렇게 객체를 콘솔로그를 남기고 열어보시면,\n\nwindow 객체의 수많은 프로퍼티들과 프로토타입, `__proto__` 프로퍼티가 있는걸 확인할 수 있습니다! \\(예제에서는 빈 객체이므로 프로토타입 체인만 보입니다.\\)\n\n아래는 자바스크립트로 구현한 Linked List의 일부분입니다.\n\n```javascript\nfunction LinkedList() {\n  this.head = null;\n  this.length = 0;\n}\n\nLinkedList.prototype.add = function (data) {\n  const node = new Node(data);\n  let current = this.head;\n  if (current) {\n    while (current.next) {\n      current = current.next;\n    }\n    current.next = node;\n  } else {\n    this.head = node;\n  }\n  this.length++;\n  return this;\n}\n```\n\n6라인을 보시면 LinkedList function 프로토타입에 add라는 프로퍼티가 있죠?\n\n프로토타입은 보통 이런식으로 사용합니다.\n\nadd라는 LinkedList.prototype의 속성에 바인딩된 함수를 빌려쓰는거죠.\n\n```javascript\nnew LinkedList().add()\n```\n\n프로토타입 체인은,\n\n```javascript\nLinkedList.prototype = 1;\n```\n\n프로토타입 체인을 만드는데 사용하고 어떤값이든 넣어도 괜찮지만,\n\n위 코드처럼 primitive 값을 대입하면 무시됩니다.\n\n## 프로토타입 탐색\n\n객체의 프로퍼티를 참조하려고하면 js엔진은 해당 이름을 가진 프로퍼티를 찾을때까지\n\n프로토타입 체인을 거슬러 올라가면서 탐색합니다.\n\n없는 프로퍼티를 참조하려고하면, 프로토타입 체인 전체를 탐색합니다.\n\n## hasOwnProperty\n\n어떤 객체의 프로퍼티가 자기 자신의 프로퍼티인지, 프로토타입 체인에 있는것인지 확인하는 메소드입니다.\n\n(다른말로, 이것으로 객체 메소드와 프로토타입 메소드를 구분할 수 있습니다.)\n\nhasOwnProperty메소드는 프로토타입 체인을 탐색하지 않고 프로퍼티를 다룰수있는 유일한 방법입니다.\n\nfor in 문으로 객체를 탐색할때, 적절히 사용할 수 있다.\n\n```javascript\n//공통코드\nObject.prototype.c = 3;\nconst obj = { a: 1, b: 2 };\n```\n\n```javascript\n// 예제1\nfor(let key in obj) {\n  if(obj.hasOwnProperty(key)) {\n    console.log(key);\n  }\n}\n// output\n// a\n// b\n```\n\n```javascript\n// 예제2\nfor(let key in obj) {\n  console.log(key);\n}\nconsole.log(obj); // { a: 1, b: 2 }\n// output\n// a\n// b\n// c\n```\n\n브라우저마다 객체 순회 방법이 달라서 iteration 순서는 중요하지않지만, c가 출력되는것이 문제가 되는 경우도 있다.\n\n## 프로토타입을 사용할때 주의해야할점\n\n프로토타입 체인이 너무 길지 않도록 적절히 사용하고\n\npolyfill이나 ponyfill 같은 목적이 아니라면 네이티브 프로토타입을 확장하지말것 =&gt; Monkey Patching =&gt; 캡슐화를 망친다.","src/content/docs/js/prototype.mdx","ee7c3299ead22f28","js/scope",{"id":824,"data":826,"body":831,"filePath":832,"digest":833,"deferredRender":15},{"title":827,"editUrl":15,"head":828,"template":17,"sidebar":829,"pagefind":15,"draft":19},"스코프",[],{"hidden":19,"attrs":830},{},"# Scope - 스코프 - 유효범위\n\n스코프는 유효범위를 뜻하는 단어입니다.\n\n자바스크립트는 특이하게 다른언어\\(c, java\\)처럼 블럭스코프가 아닌 함수스코프를 갖습니다\n\n```javascript\nvar a = 1;\nfunction A() {\n  var b = 2;\n}\nconsole.log(a); //1\nconsole.log(b); //b is not defined\n```\n\nb는 함수내에 선언했으므로 외부에서 접근하려고하면 에러입니다.\n\n그리고, 이런 코드가 동작합니다.\n\n```javascript\nif(true) {\n  var c = 3;\n}\nconsole.log(c); //3\n```\n\n이런.. 좋지않습니다.\n\n그래서 ES6에는 블럭스코프를 지원하기위한 let, const 키워드가 등장했습니다.\n\n위의 if문 예제의 var를 let이나 const로 변경하면 에러죠.\n\n그리고 아래 예제를 보면 더욱 이해하기 쉽습니다\\(?\\)\n\n```javascript\nlet d = 4;\nif(true) {\n  let d = 5;\n  console.log(d); //5\n}\nconsole.log(d); //4\n```\n\n함수얘기가 나왔으니, 실행컨텍스트와 호이스팅, 클로저를 함께보면\n\n자바스크립트 작동을 이해하기 더 쉽습니다.\n\n전역변수는 사실 잘 사용하지도 않고, 설명할것도없지만 버그가 생길 가능성이 큰\n\n암묵적 전역변수만 아래에서 설명합니다.\n\n```javascript\nfunction A() {\n  a = 1;\n}\nA();\nconsole.log(a); //1\n```\n\nA 함수를 실행하지않으면 오류입니다.\n\n하지만 실행하면 a는 전역변수가 됩니다. \\(글로벌객체의 프로퍼티\\)\n\n그래서 let, const 키워드를 꼭 붙여서 사용해야합니다.\n\n그래서 개인적으로\n\n```javascript\nlet a = 1,\n    b = 2,\n    c = 3;\n```\n\n위와 같은 코드를 선호하지않습니다.\n\n실수로 콤마를 빼먹으면 에러도 뱉지않는 전역변수가 되고 버그를 유발하며, 쓸데없는 메모리를 낭비하게 됩니다.\n\n## lexical scope \\(static scope\\), dynamic scope\n\n렉시컬 스코프는 함수를 어디에서 선언하였는지에 따라 상위 스코프가 결정됩니다.\n\n다이나믹 스코프는 반대로\\(?\\) 함수를 어디에서 호출하였는지에 따라 상위 스코프가 결정됩니다.\n\n```javascript\nvar a = 1;\n\nfunction A() {\n  var a = 2;\n  B();\n}\n\nfunction B() {\n  console.log(a);\n}\n\nA(); //1\nB(); //1\n```\n\n다이나믹 스코프였다면, 결과는 다를겁니다.\n\n```javascript\nA(); //2\nB(); //1\n```\n\n## 스코프체인\n\nid\\(식별자\\)를 찾기 위해 필요한것.\n\n스코프가 유효범위라고 했죠?\n\n스코프체인은 식별자가 어느정도 유효범위를 가지는지 알게해줍니다.\n\n예를들어\n\n```javascript\nfunction a(){\n  var v1 = 1;\n  console.log(v2); //ref error - not defined\n  function b(){\n    console.log(v1); //1\n    var v2 = 2;\n  }\n}\n```\n\n위의 코드에서 b라는 함수의 스코프에서는 변수 v1, v2를 참조할수있죠?\n\nb의 스코프에는 v2변수 밖에 없는데, 어떻게 v1을 참조할까요?\n\n바로 스코프체인때문입니다.\n\n스코프내에 다른 스코프가 있다면, 그것을 스코프체인 프로퍼티에 저장해놓는거죠.\n\n그래서 b함수 스코프에서 v1을 사용하면, v1을 b함수 스코프에서 탐색하고,\n\n없으면 이제 상위 스코프를 찾게되는데, 그 외부 스코프에 대한정보를 스코프체인이 갖고 있습니다.\n\n한마디로 _스코프체인의 탐색은 해당하는 이름을 찾거나 외부 스코프의 참조가 null이 될때 탐색을 멈춥니다._\n\n\n### 클로저를 설명할때 자주 쓰이는 예시들\n\n클로저를 설명할때 자주 쓰이는 예시들이지만 스코프에 더 중점을 두고 생각해봐야하는 것 같다.\n\n중요한 포인트는 클로저는 외부변수의 값을 기억하는게 아니라, 참조를 기억한다.\n\n```js\nfunction iter() {\n  for(var i = 0; i \u003C 5; i++) {\n    setTimeout(() => {\n      console.log('i', i);\n    }, 0);\n  }\n}\niter();\n```\n\n위 코드를 보면 순서대로 0~4가 나와야할거같지만 그렇지않고 '5'가 5번 출력된다.\n\n우선, 타이머 딜레이가 0이어도 setTimeout은 비동기함수이다. (게다가 타이머는 평균 4ms정도의 지연시간도 갖는다.)\n\nconsole.log가 호출되면 i를 찾기위해 상위 스코프(iter함수의 스코프)에서 i를 찾는다.\n\n그 시점은 for문이 이미 5번 실행되고 난 다음이다. (setTimeout은 단순히 태스크큐에 쌓여있다.)\n\n그래서 iter 함수스코프의 변수 i의 값은 이미 5이다. 그 후에 차례차례 태스크큐에서 setTimeout을 꺼내 실행하므로 5만 5번 출력한다.\n\n#### 해결방법\n\n이걸 해결하는방법은 여러가지다.\n\n단순히 var키워드를 let으로 변경하는 방법.\n\n```js\nfunction iter() {\n  for(let i = 0; i \u003C 5; i++) {\n    setTimeout(() => {\n      console.log('i', i);\n    }, 0);\n  }\n}\niter();\n```\n\n위의 예제는 예상한대로 0~4까지 콘솔에 찍힌다.\n\nsetTimeout이 실행되는 시점에 i변수를 상위 스코프에서 찾는데, for구문의 블록스코프에서 변수 i를 찾는다.\n\nfor구문 내에서 let으로 선언한 i변수는 각 for구문내에서 각각의 값을 기억하다가 우리가 기대한 값을 돌려주고 있다.\n\n다시 말해서, 5개의 각 스코프에 i변수가 하나씩 있기때문이다.\n\n```js\nfunction iter() {\n  let i = 0;\n  for(; i \u003C 5; i++) {\n    setTimeout(() => {\n      console.log('i', i);\n    }, 0);\n  }\n}\niter();\n```\n\n위의 예제는 5라는 숫자만 5개 찍힌다.\n\n이유는 변수선언이 var일때의 설명과 같다.\n\n```js\nfunction iter() {\n  for(var i = 0; i \u003C 5; i++) {\n    (function(index) {\n      setTimeout(() => {\n        console.log('index', index);\n      }, 0);\n    })(i);\n  }\n}\niter();\n```\n\n이 방법 또한, i변수를 함수의 인자로 넘겨버려서, 스코프마다 고유한 index라는 독립적인 자유변수를 생성했기때문에 원하는 결과를 얻을 수 있습니다.\n\nIIFE로 만든 5개의 스코프에 각각 다른값인 index가 생긴겁니다.","src/content/docs/js/scope.mdx","41d16dc698cbfb41","js/standard-built-in-object",{"id":834,"data":836,"body":841,"filePath":842,"digest":843,"deferredRender":15},{"title":837,"editUrl":15,"head":838,"template":17,"sidebar":839,"pagefind":15,"draft":19},"표준 내장 객체",[],{"hidden":19,"attrs":840},{},"# 표준 내장 객체\n\n표준 내장 객체(built-in 빌트인 객체 혹은 Standard Built-in object)는 ECMAScript 사양에 정의된 JavaScript 언어의 일부인 객체입니다. \\(예: String, Math, RegExp, Object, Function 등\\)\n\n## BigInt\n\nnumber는 최대 2^53-1 까지 표현할 수 있는 원시타입인데, 이것을 극복하기 위해서 만들어진 내장 객체이다.\n\n거의 필요하지않았으므로.. 꽤 최근에 나온 스펙이다. caniuse를 잘 살펴보고 사용하자\n\n사용방법은 아래와 같다.\n\n```js\nconst bigInt1 = BigInt('123123');\nconst bigInt2 = 123123n;\n\nbigInt1 === bigInt2 //true\n\ntypeof bigInt1 // 'bigint'\n```\n\n위처럼 명확히 number와 타입이 구분되어있고, 마치 primitive type처럼 비교도 가능하다.\n\n다만 BigInt는 Math객체를 사용 할 수 없고, Number와 연산하면 안된다.\n\n연산하려면 Number를 BigInt로 변환하는게 안전하다. BigInt를 Number로 변환하면 정확성을 보장할 수 없다.\n\n그리고 기본적으로는 직렬화 할 수 없다. 하고싶다면 toJSON prototype을 구현하면 된다.\n\n```js\nBigInt.prototype.toJSON = function() {\n  return this.toString();\n}\n```","src/content/docs/js/standard-built-in-object.mdx","3c5caa3f0410d461","js/sync-async",{"id":844,"data":846,"body":851,"filePath":852,"digest":853,"deferredRender":15},{"title":847,"editUrl":15,"head":848,"template":17,"sidebar":849,"pagefind":15,"draft":19},"sync-async",[],{"hidden":19,"attrs":850},{},"# sync-async\n\njavascript에는 Worker API를 제외하면 멀티스레드를 활용할 수 없다.\n\n애초에 설계가 싱글스레드기반이다.\n\n싱글스레드이기때문에, 한번에 한가지 작업밖에 할수없는데,\n\nDOM을 제어하다가 시간이 오래걸리는 로직을 만나게되면,\n\nui가 멈추게된다. 이런 문제를 해결하기위해 비동기라는 기술이 생겼다.\n\n먼저 동기, 비동기의 장단점을 보자.\n\n## 비동기의 장점\n\n```\n한정된 자원을 효율적으로 사용할 수 있다.\n```\n\n## 비동기 단점\n\n```\n동기식 코드보다는 복잡하다.\n상대적으로 가독성이 떨어진다.\n설계가 어렵다\n```\n\n## 동기의 장점\n\n```\n프로그램의 흐름을 순차적으로 코딩할 수 있다.\n디버깅이 쉽다.\n```\n\n## 동기의 단점\n\n```\n비동기에 비해 한정된 자원을 효율적으로 사용하지 못한다.\n```\n\n다시 돌아와서 비동기는 싱글스레드인데,\n\n어떻게 많은 작업을 처리할 수 있을까.\n\n비동기함수는 단순히 작업을 뒤로 미루는것이다.\n\n자바스크립트라고해서 모든 코드가 비동기로 작동하는 것은 아니고,\n\n비동기함수만 비동기로 작동한다.\n\n이 말은 js에서 동기적인 코드는 순차적으로 실행되다가,\n\n비동기 함수를 만나게되면, 그냥 뒤로 미뤄버린다. \\(비동기끼리도 순서가 있는데, 아래에서 소개하겠다\\)\n\n그래서 동기적인 코드들이 먼저 다 실행되고, 비동기가 실행되므로,\n\nui blocking을 해결할 수 있다.\n\n동기적인 로직들이 너무너무 커서, 다른 스레드의 힘을 빌려야할때 [Worker API](/browser/worker-api/)를 사용하면 된다.","src/content/docs/js/sync-async.mdx","b3e94d83549007b1","js/this",{"id":854,"data":856,"body":861,"filePath":862,"digest":863,"deferredRender":15},{"title":857,"editUrl":15,"head":858,"template":17,"sidebar":859,"pagefind":15,"draft":19},"this",[],{"hidden":19,"attrs":860},{},"# this\n\n자바스크립트에서는 특이하게도 this가 원하지않는대로 작동할수도있다.\n\n대부분의 경우 this의 값은 함수를 호출한 방법이 결정한다. (this에 바인딩할 객체가 동적으로 결정된다.)\n\n그래서 호출 컨텍스트라는 용어가 맞는것같지만.. **함수컨텍스트**라는 용어를 쓴다.\n\n```js\nfunction a() {\n  this.p1 = 1;\n  this.p2 = 2;\n  console.log(this);\n}\n\nconst A = a();\nconst B = new a();\n\nconsole.log(A); // undefined\nconsole.log(B); // {p1:1, p2:2}\n```\n\n**첫번째**로 함수가 constructor로 작동할때, 그렇지않을때의 차이이다.\n\na함수의 리턴값이 없으므로 A의 경우는 undefined이고,\n\nB의 경우에는 new 연산자를 사용하였으므로 constructor로 작동하면서\n\n인스턴스 객체의 프로퍼티가 보여진다.\n\n**두번째**로 A의 경우, a함수 내부의 this는 global객체이다.\n\n위의 예제가 일반적이지만 엄격모드(use strict)에서는 this는 글로벌객체가 아닌 undefined를 나타낸다.\n\n**세번째**로, 전역 실행 문맥(global execution context)에서는 this는 global객체이다.\n\n**네번째**로, 함수를 어떤 객체의 메서드로 '호출'하면 this의 값은 그 객체를 사용한다.\n\n```js\nconst obj = {\n  p1: 1,\n  getP1() {\n    return this.p1;\n  }\n};\nobj.getP1(); // 1\n```\n\n호출이라는 단어에 항상 조심해야한다.\n\n위 코드에 이어서 아래 코드를 보자.\n\n```js\nconst fn = obj.getP1;\nfn(); // 1이 아님\n```\n\nfn을 호출하면 window.p1 값으로 평가된다.\n\n이처럼 호출할때 값이 결정된다.\n\n**다섯번째**로, apply, call, bind, arrow function.\n\n```js\nFunction.prototype.apply\nFunction.prototype.call\nFunction.prototype.bind\n```\n위 세가지 메소드는 첫번째 파라미터로 this로 설정할 객체를 넘기면 된다.\n\n참고: [Function.call.bind 관련 재밌는 글](https://stackoverflow.com/questions/50478967/what-is-array-mapfunction-call-number)\n\n그럼 해당 메소드의 this는 넘긴 객체로 동작한다.\n\narrow function은 this를 바인딩하지않는다. => 상위스코프의 this를 가리킨다.\n\n**마지막**으로, 메소드 내부에 함수가 또 있으면 그 내부의 this는 또 다르다. 두번째랑 같은 맥락이다.\n\n```js\nconst obj = {\n  p1: 1,\n  getP1: function() {\n    function someFunction() {\n      console.log(this); // global\n    }\n    return this.p1;\n  }\n};\nobj.getP1(); //1\n```\n\n다른 언어에 익숙한 사람은 function대신 [arrow function](/js/arrow_function/)을 사용하는게 원하는대로 작동해서 정신건강에 이롭다. (객체의 메소드로 쓰면 좋지않고, 생성자로는 쓸수없다.)\n\n혹은 ES5 스펙의 Function.prototype.bind를 써도 좋다.\n\n----\n\n### this와 관련해서..\n\n실제로 메소드의 별칭을 만들어서(메소드를 외부 변수에 할당) 사용하는 것은 매우 위험하다.\n\njs의 특성상 this의 바인딩이 늦다. 이 말은 메소드를 할당한 변수를 호출했을때,\n\n내부의 this가 더이상 원래 가리키던 객체가 아니게 된다.\n\n설명한것은 아래의 코드와 같다.\n\n```js\nconst someObj = {\n  a: 1,\n  someMethod() {\n    return this.a;\n  }\n};\n\nconsole.log('someObj.someMethod', someObj.someMethod()); // 1\nconst v1 = someObj.someMethod;\nconsole.log('v1', v1()); // undefined\n```","src/content/docs/js/this.mdx","09ec9889a21dbb91","js/type",{"id":864,"data":866,"body":871,"filePath":872,"digest":873,"deferredRender":15},{"title":867,"editUrl":15,"head":868,"template":17,"sidebar":869,"pagefind":15,"draft":19},"type",[],{"hidden":19,"attrs":870},{},"# type\n\n자바스크립트는 타입이 없는 (척하는) 언어이다.\n\n단순히 변수선언만 var, let, const를 이용해서 한다.\n\n상황에 알맞게 형변환이 가능하다.\n\njs의 primitive type\n\n```\nboolean\nstring\nnumber\nnull\nundefined\n```\n참고 - number는 최대 2^53-1 => 더 큰 정수를 표현하려면 [BigInt](/js/standard-built-in-object/#bigint) Standard built-in object를 사용\n\n\nSymbol 같은 경우에는 ES6에서 새롭게 추가된 스펙이다.\n\n[설명이 길어지므로 여기에서는 제외하고 하단에서 설명한다.](#symbol)\n\n### 이상한 null\n\n자바스크립트에서 null은 조금 이상하다.\n\n```\ntypeof null // \"object\"\n```\n\nnull은 자바스크립트를 깊숙하게 건드리지않는 이상 undefined와 차이가 없다고 봐도 된다.\n\nnull의 사용은 prototype을 끊을때 외에는 undefined를 사용해도 된다.\n\n\n```js\nsomeObj.prototype = null;\n```\n\n---\n\ntypeof 연산자를 쓰다보면 function이라는 타입이 있다고 착각할수도 있다.\n\n```\ntypeof function(){} // \"function\"\n```\n\n하지만 단순히 \"1급 객체\", \"호출 가능한 객체\"일 뿐이다. 실제로는 object의 하위 타입일뿐이다.\n\n\nnull과 undefined를 제외한 3가지는 primitive wrapper가 존재한다.\n\n단순히 첫글자가 대문자일뿐이다.\n\n```javascript\nBoolean\nString\nNumber\n```\n\n```javascript\nnew String('boseok')\n```\n\n## boxing, unboxing\n\n예를 들자면\n\n```javascript\n1 === new Number(1) //false\n1 === Number(1) //true\n1 == new Number(1) //true\ntypeof new Number(1) //object\n```\n\n== 연산자는 내부적으로 형변환해서 비교하기때문에 아예 안쓰는 연산자이지만 예를 들기위해서 사용하였음.\n\n[new 연산자의 설명은 여기서](/js/constructor/)\n\n여튼 위의 코드를 보면, wrapper 객체로 새롭게 생성한 Number의 객체의 타입은 당연히 숫자가 아니라 객체다.\n\n그렇다면 아래와 같은 코드를 보자.\n\n```javascript\nconst one = new Number(1);\nconst two = 2;\nconst three = one + two;\nconsole.log(three, typeof three); //3 number\n```\n\none은 객체고, two는 숫자이다.\n\n객체와 숫자를 + 연산자로 합칠수있나?\n\n콘솔로그를 보면 3이 찍히는걸 확인할 수 있다. 그리고 타입도 숫자이다.\n\n이 말은 자동으로 형변환이 이루어진 것인데, wrapper가 벗겨져서 숫자가 된것이므로, 언박싱이라고 한다.\n\n반대로 숫자가 객체로 변환된다면 그것은 박싱이다.\n\n결론은 타입캐스팅을 자동으로 해준다.\n\n그리고 객체가 아니라 단순히 값이나 리터럴을 사용하면 타입 변환이 더 많이 일어난다.\n\n가능한 정확하게 타입을 변환해주는 것이 최선이다.\n\n참고 - 박싱, 언박싱은 자바에서도 마찬가지다.\n\n---\n\n## 쉽고 빠른 타입캐스팅\n\n숫자와 문자열 - 빈문자열과 +연산자 사용\n\n```js\n'' + 1 === '1'; //true\n```\n\n```js\n+'1' === 1; // true\n```\n\nBoolean\n\n```js\n!!undefined //false\n!!null //false\n!!0 //false\n!!1 // true\n!!'' // false\n!!'0' // true\n!!'1' // true\n```\n\nundefined, null, 0, '' 은 false처럼 작동한다. - 암묵적 타입변환\n\n```js\nif(0) {\n  //실행될수없음\n}\n\nif('') {\n  //실행될수없음\n}\n```\n\nif문과 마찬가지로, &&연산자도 마찬가지다.\n\n```js\n0 && someFunction(); //아무일도일어나지않음\n```\n\n## && 연산자의 작동방식\n\n위의 예제를 보면, someFunction을 호출하는 코드가 있는데 함수가 호출되지않는다.\n\n&& 연산자는 앞의 expression을 평가해서, false처럼 작동한다면 && 뒤의 expression은 아예 실행조차하지않는다.\n\n비슷하게 || 연산자는 앞의 expression이 true처럼 작동한다면 || 뒤의 expression은 실행하지않는다.\n\n---\n\n# Symbol\n\nES6에 새롭게 추가된 스펙이다\n\nSymbol은 새로운 primitive 타입이며,\n\n기존에 object의 key로는 string only였는데, Symbol도 가능하게되었다.\n\nobject의 key는 어떤값을 넣던 string으로 타입캐스팅이 되면서 여러가지 문제점들이 있었는데,\n\nES6가 등장하면서 Map, Symbol등이 그 이슈들을 굉장히 좋은방법들로 해결해준다.\n\nSymbol은 생성자가 없다. 그래서 함수호출형태로만 사용한다.\n\nnew 연산자를 못쓴다는 의미이다. wrapper객체를 생성하는 방법은 있긴하지만(Object(Symbol()))\n\n원래의 심볼 목적인 객체 프로퍼티 키로 쓰려고하는 것에 어긋난다.\n\n파라미터는 description이 유일하다. 어떤 용도인지 간단하게 메모하는정도이다. 값은 디버깅외에는 의미없다.\n\n실제로 같은 desc를 넣고(숫자 1), 심볼을 2개 생성해서 객체의 키로 각각 설정해주고 콘솔로그를 보면,\n\n똑같이 생긴 심볼 2개가 각각 객체 키로 설정되어있다. 내부적으로는 키값이 다른것이다.\n\ns1과 s2를 비교해봐도 마찬가지로 다르다.\n\n매 함수호출마다 다른 심볼들을 생성한다.\n\n```js\nconst s1 = Symbol(1);\nconst s2 = Symbol(1);\nconst obj = {\n  [s1]: 1,\n  [s2]: 2\n}\nconsole.log(obj); // {Symbol(1): 1, Symbol(1): 2}\ns1 === s2; // false\n```","src/content/docs/js/type.mdx","1bbb5183ec594b30","js/v8-engine",{"id":874,"data":876,"body":881,"filePath":882,"digest":883,"deferredRender":15},{"title":877,"editUrl":15,"head":878,"template":17,"sidebar":879,"pagefind":15,"draft":19},"V8 & JITC",[],{"hidden":19,"attrs":880},{},"# V8 엔진\n\nV8은 구글이 주도적으로 개발한 고성능의 자바스크립트&웹어셈블리 오픈소스엔진입니다.\n\nC++로 작성되었으며, 대표적으로 크롬브라우저, node.js에서 사용합니다.\n\n엔진은 주요 아키텍쳐인 x64, ARM을 지원합니다. 나머지는 비공식적으로 지원한다고 합니다.\n\nV8은 JavaScript 소스 코드를 컴파일 및 실행하고 객체에 대한 메모리 할당을 처리하며, 가비지 콜렉터를 동작시킵니다.\n\nDOM API는 V8의 스펙이 아니고, 브라우저에서 구현해야하는 스펙입니다.\n\nV8은 자바스크립트가 실행되는 런타임 환경을 제공합니다.\n\n# JITC\n\n초기 자바스크립트 엔진은 인터프리터로 동작했지만,\n\n자바스크립트의 앱이 점점 커짐에 따라 실행속도가 점점 느려졌습니다.\n\n그래서 최신 자바스크립트 엔진은 실행 속도를 높이기 위해 내부적으로 JIT(Just In Time) 컴파일을 사용합니다.\n\n\n\nreference: https://v8.dev/docs\n\nhttps://webkit.org/blog/3362/introducing-the-webkit-ftl-jit","src/content/docs/js/v8-engine.mdx","a4d617b551e0c281","js/var-let-const",{"id":884,"data":886,"body":891,"filePath":892,"digest":893,"deferredRender":15},{"title":887,"editUrl":15,"head":888,"template":17,"sidebar":889,"pagefind":15,"draft":19},"var, let, const",[],{"hidden":19,"attrs":890},{},"# var-let-const\n\nvar는 함수레벨 스코프를 가져서 블록레벨스코프에 변수를 선언해도 함수레벨어디서나 사용해도된다. \\(레퍼런스에러가 안난다는 의미\\)\n\n그리고 재선언과 재할당이 가능하다.\n\nES6를 사용할수있는 환경이라면, 쓰지말도록하자.\n\nlet과 const로 완벽대체 가능.\n\nlet은 블록레벨 스코프의 변수이다. 다른언어들처럼.. const와 다르게 재할당 가능.\n\n선언시 값을 대입해줄 필요가없음.\n\n없는것을 참조하려고하면 레퍼런스에러가난다.\n\nconst도 블록레벨 스코프의 변수이고, 재할당이 불가능하다.\n\n선언시 값을 대입해줘야함\n\n```javascript\nlet a; //ok\nconst b; //error\nconst c = 1; //ok\n```\n\nconst는 primitive에 대해서는 immutable이다.\n\nobject을 대입하면, immutable object는 아니다.\n\n하지만 주소값은 변경할 수 없음. \\(재할당할수없음\\)\n\n예를 들면 const 에 숫자나 문자열을 대입하면, 변경할수없다.\n\n하지만 배열이나 오브젝트를 대입하고, 배열이나 오브젝트에 값을 추가하거나 뺄수있다.\n\n```javascript\nconst numA = 1;\nnumA = 2; //에러\n\nconst objA = {};\nobjA = {name: '쥬얼리'}; //에러\nobjA.name = '쥬얼리'; //에러아님\n```","src/content/docs/js/var-let-const.mdx","f95ec7b3078d1ab4","secret/gallup_top5",{"id":894,"data":896,"body":901,"filePath":902,"digest":903,"rendered":904},{"title":897,"editUrl":15,"head":898,"template":17,"sidebar":899,"pagefind":15,"draft":19},"Gallup Top 5 CliftonStrengths",[],{"hidden":19,"attrs":900},{},"## 가장 높은 특성 5개\n\n### 절친(Relator) 테마\n\n절친(Relator) 테마는 대인관계에 대한 당신의 태도를 설명해 줍니다.\n간단히 말해, 이 절친(Relator) 테마로 인해 당신은 이미 알고 있는 사람들에게 더 큰 관심을 느낍니다.\n그렇다고 당신이 꼭 새로운 사람을 만나기를 피한다는 뜻은 아닙니다.\n사실 다른 테마의 작용으로 인해 낯선 사람들을 사귀는 것을 무척 좋아할 수도 있습니다. 하지만 당신이 친한 친구들에게서 많은 기쁨과 힘을 얻는 것은 분명합니다. 당신은 친밀함을 편안하게 느낍니다. 따라서 일단 관계가 형성되면, 상대를 더 깊게 알기 위해서 일부러 노력합니다. 당신은 친구들이 느끼는 정서와 두려움, 그리고 추구하는 목표와 꿈을 이해하고 싶어하고, 마찬가지로, 친구들도 당신의 이런 부분을 이해해 주기를 바랍니다. 당신은 이런 종류의 친밀감에 이용 당할 위험이 어느 정도 내포되어 있음을 알고 있습니다. 하지만 그러한 위험을 기꺼이 감수합니다. 당신에게 관계는 진실해야만 가치가 있습니다. 그리고 관계가 진실한지 판단할 수 있는 유일한 방법은 상대방을 믿고 자신을 드러내는 길 밖에는 없습니다. 서로 더 많이 공유할수록, 위험도 더 많이 공유하게 될 것입니다. 이렇게 위험을 함께 감수하는 과정을 거치면서, 각자의 마음이 진실하다는 것이 더 확실히 증명됩니다. 이것이 진정한 우정을 만들어 가는 당신의 절차입 니다. 그리고 당신은 기꺼이 이 절차들을 밟아갑니다.\n\n---\n\n### 최상화(Maximizer) 테마\n\n당신의 기준은 평균이 아니라 최상입니다. 평균 이하를 평균보다 약간 높은 수준으로 끌어올리는 데에는 많은 노력이 소요됩니다. 하지만 이런 개선에 당신은 큰 보람을 느끼지 못합니다. 반면에 우수한 수준을 최상의 수준으로 끌어올리는 데에는 이와 비슷한 노력이 드는데도 불구하고 훨씬 큰 흥미를 느낍니다. 당신은 사람 들의 강점들에 매력을 느낍니다. 그것이 자신의 강점이든 다른 이의 강점이든 말이죠. 마치 진주를 찾는 잠수 부처럼, 당신은 강점을 찾고 강점을 알리는 단서를 예의 주시합니다. 배우지도 않았는데 탁월한 능력을 발휘 한다든지, 배우는 속도가 유난히 빠르다든지 아니면 정식 단계를 밟지 않고도 어떤 기술에 통달한다든지 등 이 강점을 드러내는 단서입니다. 그리고 강점을 발견하면, 당신은 이를 갈고 닦아 최상의 수준으로 끌어올리 고 싶어 합니다. 당신은 진주가 반짝일 때까지 닦고 또 닦습니다. 강점을 찾고 선별하는 성향 때문에 다른 사 람들은 당신이 차별한다고 생각할 수 있습니다. 당신은 본인 특유의 강점을 알아주고 인정해 주는 사람들과 어울리기를 좋아하기 때문입니다. 당신은 자신의 강점을 발견하여 개발한 사람들에게 매력을 느끼는 반면, 부족한 점들을 고쳐서 당신을 평균적인 사람으로 만들려고 하는 사람들은 피하고 싶어 합니다. 자신의 부족 한 점들에 집착해서 평생 한탄하며 살고 싶어하지 않습니다. 그보다는 스스로 타고난 재능을 적극 활용하고 싶어 합니다. 그 편이 훨씬 즐겁고 더 효율적이니까요. 또한 예상과는 다르게 더 많은 노력과 땀이 필요한 길 이기도 합니다.\n\n---\n\n### 발상(Ideation) 테마\n\n당신은 아이디어에 매료되어 있습니다. 아이디어란 무엇일까요? 이는 세상사를 가장 잘 설명해 주는 어떤 원 리나 이념이라고 볼 수 있습니다. 당신은 복잡한 현상의 근본 원인을 설명해 주는 명쾌하고 단순한 원리를 발 견할 때 기쁨을 느낍니다. 아이디어는 연결 고리입니다. 당신은 항상 연결고리를 찾으려 합니다. 그래서 서로 관련이 없어 보이는 별개의 현상들이 눈에 띄지 않는 연결 고리로 연결되어 있음을 발견할 때 흥미를 느낍니 다. 아이디어는 또한 익숙한 문제를 바라보는 새로운 시각입니다. 당신은 우리 모두가 알고 있는 세계를 뒤집 어서 전혀 새로운 각도, 즉 생소한 깨우침을 주는 시각으로 보는 데서 즐거움을 느낍니다. 당신은 이런 모든 종류의 발상과 아이디어들을 사랑합니다. 왜냐하면 이들은 심오하고, 참신하고, 엉뚱하며 기존과는 다른 시 각과 명확성을 제공하기 때문이지요. 이런 모든 이유로 인해, 당신은 새로운 아이디어가 떠오를 때마다 기운 이 샘솟는 것을 느낍니다. 사람들은 당신이 \"창의적이다\", \"독창적이다\", \"발상력이 풍부하다\" 또는 \"똑똑하 다\"고 표현할 수도 있습니다. 어쩌면 당신은 이 모두에 해당될 수도 있습니다. 어느 누가 확신할 수 있겠습니 까? 하지만 확실한 것 하나는 아이디어가 당신을 신바람 나게 만든다는 점입니다. 이것만으로 당신은 만족합니다.\n\n---\n\n### 미래지향(Futuristic) 테마\n\n미래가 이러이러하면 좋지 않을까? 당신은 당면한 현실 너머를 바라보기를 무척 좋아하는 사람입니다. 당신 은 미래에 매혹됩니다. 마치 벽에 투사되는 그림을 보는 것처럼, 당신의 눈에는 미래가 어떨지 상세하게 보입 니다. 이 상세한 그림에 끌려 당신은 앞을 향해, 내일을 향해 나아갑니다. 그림의 구체적인 내용은 당신이 가 진 다른 강점들과 관심사에 따라 달라지겠지만, 이 그림은 언제나 당신에게 더 좋은 제품, 더 훌륭한 팀, 더 행복한 인생, 혹은 더 나은 세상 등에 대한 영감을 줍니다. 당신은 미래의 가능한 모습을 꿈꾸는 사람이며 이러한 비전을 소중히 여깁니다. 현재 상황이 너무 힘들고, 주변 사람들이 너무 현실에만 치중할 때면, 당신은 미래에 대한 비전을 떠올려 보는 방법으로 기운을 냅니다. 이런 당신의 비전은 다른 이들에게도 활력을 줄 수 있습니다. 사실, 사람들은 당신이 미래에 대한 비전을 이야기해 주기를 자주 기대합니다. 그들은 희망과 활기 를 얻을 수 있는 청사진을 원합니다. 당신은 그들에게 이런 비전을 제공해줄 수 있습니다. 연습하십시오. 단 어를 신중히 선택하고, 비전이 최대한 생생하게 전달 될 수 있도록 하십시오. 사람들은 당신이 가져다 주는 희망을 품고 싶어할 것입니다.\n\n---\n\n### 책임(Responsibility) 테마\n\n책임(Responsibility) 테마를 가진 당신은 하겠다고 한 것은 끝까지 책임지려고 합니다. 큰 일이든 작은 일이 든 일단 약속한 것에 대해서는 이를 이행해야 한다는 의무감을 느낍니다. 당신은 자신의 평판이 여기에 달려 있다고 봅니다. 그리고 어떤 이유로든 책임을 이행하지 못하면, 자동적으로 상대방에게 보상할 방법을 찾기 시작합니다. 사과로는 충분하지 않습니다. 변명하고 합리화하는 것은 절대로 용납할 수 없습니다. 만회하고 보상할 때까지 직성이 풀리지 않습니다. 이러한 성실성, 일을 제대로 해야 한다는 강력한 의식, 완전무결한 윤리관 때문에 당신은 \"절대적으로 믿을 수 있는 사람\"이라는 평을 듣습니다. 새로 임무를 맡길 때, 사람들은 제일 먼저 당신을 찾아옵니다. 당신이 그것을 완수해 줄 적임자임을 알고 있기 때문입니다. 가까운 미래에 도 움을 청하러 오는 사람들이 있을 것입니다. 이렇게 도움을 청하러 왔을 때, 당신은 반드시 선별해서 책임을 맡아야 합니다. 그러지 않는다면, 도와주고 싶은 마음에 이끌려 감당할 수 없을 만큼 너무 많은 일을 떠맡게 될지도 모르니까요.","src/content/docs/secret/gallup_top5.md","678cbb066c6407c7",{"html":905,"metadata":906},"\u003Cdiv class=\"sl-heading-wrapper level-h2\">\u003Ch2 id=\"가장-높은-특성-5개\">가장 높은 특성 5개\u003C/h2>\u003Ca class=\"sl-anchor-link\" href=\"#가장-높은-특성-5개\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “가장 높은 특성 5개”\u003C/span>\u003C/a>\u003C/div>\n\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"절친relator-테마\">절친(Relator) 테마\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#절친relator-테마\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “절친(Relator) 테마”\u003C/span>\u003C/a>\u003C/div>\n\u003Cp>절친(Relator) 테마는 대인관계에 대한 당신의 태도를 설명해 줍니다.\n간단히 말해, 이 절친(Relator) 테마로 인해 당신은 이미 알고 있는 사람들에게 더 큰 관심을 느낍니다.\n그렇다고 당신이 꼭 새로운 사람을 만나기를 피한다는 뜻은 아닙니다.\n사실 다른 테마의 작용으로 인해 낯선 사람들을 사귀는 것을 무척 좋아할 수도 있습니다. 하지만 당신이 친한 친구들에게서 많은 기쁨과 힘을 얻는 것은 분명합니다. 당신은 친밀함을 편안하게 느낍니다. 따라서 일단 관계가 형성되면, 상대를 더 깊게 알기 위해서 일부러 노력합니다. 당신은 친구들이 느끼는 정서와 두려움, 그리고 추구하는 목표와 꿈을 이해하고 싶어하고, 마찬가지로, 친구들도 당신의 이런 부분을 이해해 주기를 바랍니다. 당신은 이런 종류의 친밀감에 이용 당할 위험이 어느 정도 내포되어 있음을 알고 있습니다. 하지만 그러한 위험을 기꺼이 감수합니다. 당신에게 관계는 진실해야만 가치가 있습니다. 그리고 관계가 진실한지 판단할 수 있는 유일한 방법은 상대방을 믿고 자신을 드러내는 길 밖에는 없습니다. 서로 더 많이 공유할수록, 위험도 더 많이 공유하게 될 것입니다. 이렇게 위험을 함께 감수하는 과정을 거치면서, 각자의 마음이 진실하다는 것이 더 확실히 증명됩니다. 이것이 진정한 우정을 만들어 가는 당신의 절차입 니다. 그리고 당신은 기꺼이 이 절차들을 밟아갑니다.\u003C/p>\n\u003Chr>\n\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"최상화maximizer-테마\">최상화(Maximizer) 테마\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#최상화maximizer-테마\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “최상화(Maximizer) 테마”\u003C/span>\u003C/a>\u003C/div>\n\u003Cp>당신의 기준은 평균이 아니라 최상입니다. 평균 이하를 평균보다 약간 높은 수준으로 끌어올리는 데에는 많은 노력이 소요됩니다. 하지만 이런 개선에 당신은 큰 보람을 느끼지 못합니다. 반면에 우수한 수준을 최상의 수준으로 끌어올리는 데에는 이와 비슷한 노력이 드는데도 불구하고 훨씬 큰 흥미를 느낍니다. 당신은 사람 들의 강점들에 매력을 느낍니다. 그것이 자신의 강점이든 다른 이의 강점이든 말이죠. 마치 진주를 찾는 잠수 부처럼, 당신은 강점을 찾고 강점을 알리는 단서를 예의 주시합니다. 배우지도 않았는데 탁월한 능력을 발휘 한다든지, 배우는 속도가 유난히 빠르다든지 아니면 정식 단계를 밟지 않고도 어떤 기술에 통달한다든지 등 이 강점을 드러내는 단서입니다. 그리고 강점을 발견하면, 당신은 이를 갈고 닦아 최상의 수준으로 끌어올리 고 싶어 합니다. 당신은 진주가 반짝일 때까지 닦고 또 닦습니다. 강점을 찾고 선별하는 성향 때문에 다른 사 람들은 당신이 차별한다고 생각할 수 있습니다. 당신은 본인 특유의 강점을 알아주고 인정해 주는 사람들과 어울리기를 좋아하기 때문입니다. 당신은 자신의 강점을 발견하여 개발한 사람들에게 매력을 느끼는 반면, 부족한 점들을 고쳐서 당신을 평균적인 사람으로 만들려고 하는 사람들은 피하고 싶어 합니다. 자신의 부족 한 점들에 집착해서 평생 한탄하며 살고 싶어하지 않습니다. 그보다는 스스로 타고난 재능을 적극 활용하고 싶어 합니다. 그 편이 훨씬 즐겁고 더 효율적이니까요. 또한 예상과는 다르게 더 많은 노력과 땀이 필요한 길 이기도 합니다.\u003C/p>\n\u003Chr>\n\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"발상ideation-테마\">발상(Ideation) 테마\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#발상ideation-테마\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “발상(Ideation) 테마”\u003C/span>\u003C/a>\u003C/div>\n\u003Cp>당신은 아이디어에 매료되어 있습니다. 아이디어란 무엇일까요? 이는 세상사를 가장 잘 설명해 주는 어떤 원 리나 이념이라고 볼 수 있습니다. 당신은 복잡한 현상의 근본 원인을 설명해 주는 명쾌하고 단순한 원리를 발 견할 때 기쁨을 느낍니다. 아이디어는 연결 고리입니다. 당신은 항상 연결고리를 찾으려 합니다. 그래서 서로 관련이 없어 보이는 별개의 현상들이 눈에 띄지 않는 연결 고리로 연결되어 있음을 발견할 때 흥미를 느낍니 다. 아이디어는 또한 익숙한 문제를 바라보는 새로운 시각입니다. 당신은 우리 모두가 알고 있는 세계를 뒤집 어서 전혀 새로운 각도, 즉 생소한 깨우침을 주는 시각으로 보는 데서 즐거움을 느낍니다. 당신은 이런 모든 종류의 발상과 아이디어들을 사랑합니다. 왜냐하면 이들은 심오하고, 참신하고, 엉뚱하며 기존과는 다른 시 각과 명확성을 제공하기 때문이지요. 이런 모든 이유로 인해, 당신은 새로운 아이디어가 떠오를 때마다 기운 이 샘솟는 것을 느낍니다. 사람들은 당신이 “창의적이다”, “독창적이다”, “발상력이 풍부하다” 또는 “똑똑하 다”고 표현할 수도 있습니다. 어쩌면 당신은 이 모두에 해당될 수도 있습니다. 어느 누가 확신할 수 있겠습니 까? 하지만 확실한 것 하나는 아이디어가 당신을 신바람 나게 만든다는 점입니다. 이것만으로 당신은 만족합니다.\u003C/p>\n\u003Chr>\n\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"미래지향futuristic-테마\">미래지향(Futuristic) 테마\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#미래지향futuristic-테마\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “미래지향(Futuristic) 테마”\u003C/span>\u003C/a>\u003C/div>\n\u003Cp>미래가 이러이러하면 좋지 않을까? 당신은 당면한 현실 너머를 바라보기를 무척 좋아하는 사람입니다. 당신 은 미래에 매혹됩니다. 마치 벽에 투사되는 그림을 보는 것처럼, 당신의 눈에는 미래가 어떨지 상세하게 보입 니다. 이 상세한 그림에 끌려 당신은 앞을 향해, 내일을 향해 나아갑니다. 그림의 구체적인 내용은 당신이 가 진 다른 강점들과 관심사에 따라 달라지겠지만, 이 그림은 언제나 당신에게 더 좋은 제품, 더 훌륭한 팀, 더 행복한 인생, 혹은 더 나은 세상 등에 대한 영감을 줍니다. 당신은 미래의 가능한 모습을 꿈꾸는 사람이며 이러한 비전을 소중히 여깁니다. 현재 상황이 너무 힘들고, 주변 사람들이 너무 현실에만 치중할 때면, 당신은 미래에 대한 비전을 떠올려 보는 방법으로 기운을 냅니다. 이런 당신의 비전은 다른 이들에게도 활력을 줄 수 있습니다. 사실, 사람들은 당신이 미래에 대한 비전을 이야기해 주기를 자주 기대합니다. 그들은 희망과 활기 를 얻을 수 있는 청사진을 원합니다. 당신은 그들에게 이런 비전을 제공해줄 수 있습니다. 연습하십시오. 단 어를 신중히 선택하고, 비전이 최대한 생생하게 전달 될 수 있도록 하십시오. 사람들은 당신이 가져다 주는 희망을 품고 싶어할 것입니다.\u003C/p>\n\u003Chr>\n\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"책임responsibility-테마\">책임(Responsibility) 테마\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#책임responsibility-테마\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “책임(Responsibility) 테마”\u003C/span>\u003C/a>\u003C/div>\n\u003Cp>책임(Responsibility) 테마를 가진 당신은 하겠다고 한 것은 끝까지 책임지려고 합니다. 큰 일이든 작은 일이 든 일단 약속한 것에 대해서는 이를 이행해야 한다는 의무감을 느낍니다. 당신은 자신의 평판이 여기에 달려 있다고 봅니다. 그리고 어떤 이유로든 책임을 이행하지 못하면, 자동적으로 상대방에게 보상할 방법을 찾기 시작합니다. 사과로는 충분하지 않습니다. 변명하고 합리화하는 것은 절대로 용납할 수 없습니다. 만회하고 보상할 때까지 직성이 풀리지 않습니다. 이러한 성실성, 일을 제대로 해야 한다는 강력한 의식, 완전무결한 윤리관 때문에 당신은 “절대적으로 믿을 수 있는 사람”이라는 평을 듣습니다. 새로 임무를 맡길 때, 사람들은 제일 먼저 당신을 찾아옵니다. 당신이 그것을 완수해 줄 적임자임을 알고 있기 때문입니다. 가까운 미래에 도 움을 청하러 오는 사람들이 있을 것입니다. 이렇게 도움을 청하러 왔을 때, 당신은 반드시 선별해서 책임을 맡아야 합니다. 그러지 않는다면, 도와주고 싶은 마음에 이끌려 감당할 수 없을 만큼 너무 많은 일을 떠맡게 될지도 모르니까요.\u003C/p>",{"headings":907,"localImagePaths":928,"remoteImagePaths":929,"frontmatter":930,"imagePaths":932},[908,912,916,919,922,925],{"depth":909,"slug":910,"text":911},2,"가장-높은-특성-5개","가장 높은 특성 5개",{"depth":913,"slug":914,"text":915},3,"절친relator-테마","절친(Relator) 테마",{"depth":913,"slug":917,"text":918},"최상화maximizer-테마","최상화(Maximizer) 테마",{"depth":913,"slug":920,"text":921},"발상ideation-테마","발상(Ideation) 테마",{"depth":913,"slug":923,"text":924},"미래지향futuristic-테마","미래지향(Futuristic) 테마",{"depth":913,"slug":926,"text":927},"책임responsibility-테마","책임(Responsibility) 테마",[],[],{"title":897,"layout":931,"nocomment":15},"../../../layouts/BlogPost.astro",[],"secret/interview",{"id":933,"data":935,"body":940,"filePath":941,"digest":942,"rendered":943},{"title":936,"editUrl":15,"head":937,"template":17,"sidebar":938,"pagefind":15,"draft":19},"인터뷰 스킬",[],{"hidden":19,"attrs":939},{},"### 상대방을 설득하는 나만의 노하우\n\n어떤 이슈가 있어서 회의를 할 때, 먼저 상대방이 하는 이야기를 잘 들어요.\n\n상대방을 설득할때는 공식문서의 자료나, 성능이라던지 이런 지표를 기반으로 근거있는 설득을 지향합니다.\n\n### 능동적, 책임감\n\n1년간 재직했던 스타트업에서 6개월간 근무하며 사원에서 임원으로 승진한 경험이 있으며,\n\nSK11번가에서 2년 넘는 기간동안 풀재택근무를 하였지만 2021년도에 스페셜 리텐션을 받을정도로 자유로운 환경에서 책임감있고 성실하게 일합니다.\n\n### 일정\n - 먼저 jira를 사용해왔는데, 기능별로 due date 산정을 해서 일정을 정하고 협의합니다.\n - 비즈니스를 이유로 피할 수 없는 일정이라면, SK11번가 아마존 프로젝트를 했던 때 처럼, 야근과 주말근무는 피할 수 없는 것 같습니다. 데드라인이 빡빡해도 끝까지 해내는 성격입니다.\n\n### 내 강점?\n - 중견기업에서 인턴, 15명 규모의 스타트업에서 리드 개발자 & 기술면접관, SK11번가에서 핵심 프로젝트 리딩 & 기술면접관을 하고, 카카오스타일에서 재직했던 경험등 다양한 규모의 조직 경험이 있습니다.\n - 테스트코드 열심히 작성합니다. 익숙해져서 나름 빠르고 효율적으로 개발합니다.\n - SK11번가 아마존을 개발할때 넓은 범위의 인앱 웹뷰를 개발했었습니다. 경험과 노하우가 개발팀에서 도움이 될 것 같습니다.\n - 다른 팀의 일도 줄여줄 수 있으면 줄여주려고 노력합니다. 예를 들면, 11번가 아마존 풀 웹뷰.\n - 솔직한 comm. 을 지향합니다.\n    - 솔직하면서도 조심스럽게 커뮤니케이션하는게 제 강점이라고 생각합니다.\n    - 충돌이 있더라도 상대방의 기분을 나쁘지않게 말할 수 있고, 솔직하고 근거 있는 논의로 더 나은결과를 만들어내고 싶어합니다.\n- 사용자의 관점에서 개발\n    - 프론트엔드 개발자는 사용자가 눈으로 보는 화면을 구성합니다.\n    - 사용자의 입장에서 불편함 없는 서비스를 개발하려고 노력합니다.\n\n### 단점\n\n- 개발문서정도는 읽을 수 있지만 다소 취약한 영어.\n- 부끄러움이 많고 긴장을 잘 하는 편.","src/content/docs/secret/interview.md","b8bd530acc39af32",{"html":944,"metadata":945},"\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"상대방을-설득하는-나만의-노하우\">상대방을 설득하는 나만의 노하우\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#상대방을-설득하는-나만의-노하우\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “상대방을 설득하는 나만의 노하우”\u003C/span>\u003C/a>\u003C/div>\n\u003Cp>어떤 이슈가 있어서 회의를 할 때, 먼저 상대방이 하는 이야기를 잘 들어요.\u003C/p>\n\u003Cp>상대방을 설득할때는 공식문서의 자료나, 성능이라던지 이런 지표를 기반으로 근거있는 설득을 지향합니다.\u003C/p>\n\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"능동적-책임감\">능동적, 책임감\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#능동적-책임감\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “능동적, 책임감”\u003C/span>\u003C/a>\u003C/div>\n\u003Cp>1년간 재직했던 스타트업에서 6개월간 근무하며 사원에서 임원으로 승진한 경험이 있으며,\u003C/p>\n\u003Cp>SK11번가에서 2년 넘는 기간동안 풀재택근무를 하였지만 2021년도에 스페셜 리텐션을 받을정도로 자유로운 환경에서 책임감있고 성실하게 일합니다.\u003C/p>\n\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"일정\">일정\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#일정\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “일정”\u003C/span>\u003C/a>\u003C/div>\n\u003Cul>\n\u003Cli>먼저 jira를 사용해왔는데, 기능별로 due date 산정을 해서 일정을 정하고 협의합니다.\u003C/li>\n\u003Cli>비즈니스를 이유로 피할 수 없는 일정이라면, SK11번가 아마존 프로젝트를 했던 때 처럼, 야근과 주말근무는 피할 수 없는 것 같습니다. 데드라인이 빡빡해도 끝까지 해내는 성격입니다.\u003C/li>\n\u003C/ul>\n\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"내-강점\">내 강점?\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#내-강점\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “내 강점?”\u003C/span>\u003C/a>\u003C/div>\n\u003Cul>\n\u003Cli>중견기업에서 인턴, 15명 규모의 스타트업에서 리드 개발자 &#x26; 기술면접관, SK11번가에서 핵심 프로젝트 리딩 &#x26; 기술면접관을 하고, 카카오스타일에서 재직했던 경험등 다양한 규모의 조직 경험이 있습니다.\u003C/li>\n\u003Cli>테스트코드 열심히 작성합니다. 익숙해져서 나름 빠르고 효율적으로 개발합니다.\u003C/li>\n\u003Cli>SK11번가 아마존을 개발할때 넓은 범위의 인앱 웹뷰를 개발했었습니다. 경험과 노하우가 개발팀에서 도움이 될 것 같습니다.\u003C/li>\n\u003Cli>다른 팀의 일도 줄여줄 수 있으면 줄여주려고 노력합니다. 예를 들면, 11번가 아마존 풀 웹뷰.\u003C/li>\n\u003Cli>솔직한 comm. 을 지향합니다.\n\u003Cul>\n\u003Cli>솔직하면서도 조심스럽게 커뮤니케이션하는게 제 강점이라고 생각합니다.\u003C/li>\n\u003Cli>충돌이 있더라도 상대방의 기분을 나쁘지않게 말할 수 있고, 솔직하고 근거 있는 논의로 더 나은결과를 만들어내고 싶어합니다.\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003Cli>사용자의 관점에서 개발\n\u003Cul>\n\u003Cli>프론트엔드 개발자는 사용자가 눈으로 보는 화면을 구성합니다.\u003C/li>\n\u003Cli>사용자의 입장에서 불편함 없는 서비스를 개발하려고 노력합니다.\u003C/li>\n\u003C/ul>\n\u003C/li>\n\u003C/ul>\n\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"단점\">단점\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#단점\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “단점”\u003C/span>\u003C/a>\u003C/div>\n\u003Cul>\n\u003Cli>개발문서정도는 읽을 수 있지만 다소 취약한 영어.\u003C/li>\n\u003Cli>부끄러움이 많고 긴장을 잘 하는 편.\u003C/li>\n\u003C/ul>",{"headings":946,"localImagePaths":960,"remoteImagePaths":961,"frontmatter":962,"imagePaths":963},[947,950,953,955,958],{"depth":913,"slug":948,"text":949},"상대방을-설득하는-나만의-노하우","상대방을 설득하는 나만의 노하우",{"depth":913,"slug":951,"text":952},"능동적-책임감","능동적, 책임감",{"depth":913,"slug":954,"text":954},"일정",{"depth":913,"slug":956,"text":957},"내-강점","내 강점?",{"depth":913,"slug":959,"text":959},"단점",[],[],{"title":936,"layout":931,"nocomment":15},[],"secret/mentor",{"id":964,"data":966,"body":971,"filePath":972,"digest":973,"rendered":974},{"title":967,"editUrl":15,"head":968,"template":17,"sidebar":969,"pagefind":15,"draft":19},"멘토링",[],{"hidden":19,"attrs":970},{},"### JS 개발자 면접을 위한 멘토링 자료 정리\n\n- [인터뷰 스킬](/secret/interview)\n\n- [FE 개발자가 되기위한 mdn 학습서](https://developer.mozilla.org/ko/docs/orphaned/Learn/Front-end_web_developer)\n\n- [JS 구성요소](https://developer.mozilla.org/ko/docs/Learn/JavaScript/Building_blocks)","src/content/docs/secret/mentor.md","e2de93cc39fb83e2",{"html":975,"metadata":976},"\u003Cdiv class=\"sl-heading-wrapper level-h3\">\u003Ch3 id=\"js-개발자-면접을-위한-멘토링-자료-정리\">JS 개발자 면접을 위한 멘토링 자료 정리\u003C/h3>\u003Ca class=\"sl-anchor-link\" href=\"#js-개발자-면접을-위한-멘토링-자료-정리\">\u003Cspan aria-hidden=\"true\" class=\"sl-anchor-icon\">\u003Csvg width=\"16\" height=\"16\" viewBox=\"0 0 24 24\">\u003Cpath fill=\"currentcolor\" d=\"m12.11 15.39-3.88 3.88a2.52 2.52 0 0 1-3.5 0 2.47 2.47 0 0 1 0-3.5l3.88-3.88a1 1 0 0 0-1.42-1.42l-3.88 3.89a4.48 4.48 0 0 0 6.33 6.33l3.89-3.88a1 1 0 1 0-1.42-1.42Zm8.58-12.08a4.49 4.49 0 0 0-6.33 0l-3.89 3.88a1 1 0 0 0 1.42 1.42l3.88-3.88a2.52 2.52 0 0 1 3.5 0 2.47 2.47 0 0 1 0 3.5l-3.88 3.88a1 1 0 1 0 1.42 1.42l3.88-3.89a4.49 4.49 0 0 0 0-6.33ZM8.83 15.17a1 1 0 0 0 1.1.22 1 1 0 0 0 .32-.22l4.92-4.92a1 1 0 0 0-1.42-1.42l-4.92 4.92a1 1 0 0 0 0 1.42Z\">\u003C/path>\u003C/svg>\u003C/span>\u003Cspan class=\"sr-only\">Section titled “JS 개발자 면접을 위한 멘토링 자료 정리”\u003C/span>\u003C/a>\u003C/div>\n\u003Cul>\n\u003Cli>\n\u003Cp>\u003Ca href=\"/secret/interview\">인터뷰 스킬\u003C/a>\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Ca href=\"https://developer.mozilla.org/ko/docs/orphaned/Learn/Front-end_web_developer\">FE 개발자가 되기위한 mdn 학습서\u003C/a>\u003C/p>\n\u003C/li>\n\u003Cli>\n\u003Cp>\u003Ca href=\"https://developer.mozilla.org/ko/docs/Learn/JavaScript/Building_blocks\">JS 구성요소\u003C/a>\u003C/p>\n\u003C/li>\n\u003C/ul>",{"headings":977,"localImagePaths":981,"remoteImagePaths":982,"frontmatter":983,"imagePaths":984},[978],{"depth":913,"slug":979,"text":980},"js-개발자-면접을-위한-멘토링-자료-정리","JS 개발자 면접을 위한 멘토링 자료 정리",[],[],{"title":967,"layout":931,"nocomment":15},[],"server-side/aws",{"id":985,"data":987,"body":992,"filePath":993,"digest":994,"deferredRender":15},{"title":988,"editUrl":15,"head":989,"template":17,"sidebar":990,"pagefind":15,"draft":19},"Amazon Web Service",[],{"hidden":19,"attrs":991},{},"# Amazon Web Service\n\nAmazon Web Service\\(이하 AWS\\)는 사용자에게 클라우드환경을 제공한다.\n\n서버환경을 구축하려면 하드웨어를 포함한 다양한 인프라구축이 필요한데,\n\n사용자마다 설정을 통해 원하는 하드웨어 스펙을 선택할수도있고, 서버인스턴스의 os까지 설정할 수 있다.\n\n이런 부분을 설정에서 선택만 하면 자동으로 os까지 설치해주고, ssh를 통해 접속해서 사용하기만 하면 된다.\n\n사용자 입장에서는 하드웨어와 다양한 low-level 네트워크\\(라우터 등..\\)를 설정하지않아도 되므로 신경쓸일이 거의 없다.\n\n확장성에서도 훨씬 유리하다. 하드웨어를 갈아끼우듯이 서버를 일시정지시키고, 서버 스펙을 늘릴수도있다.\n\n네트워크 대역이라던지.. 이런것은 말할필요도 없다.\n\n한마디로 사이징\\(sizing\\)에서 너무나 유리하다.\n\n사이즈를 크게 잡으면 비용낭비이다. 그렇다고 작게 잡으면 단기간에 늘리기 쉽지않다.\n\n결정적으로 직접 서버환경을 구축하는 on-premise방식보다 결과적으로 금전적으로도 이득이라고 한다.\n\n클라우드를 안 쓸 이유가 없다. \\(대형 게임사의 게임서버 제외\\)\n\n## MAC\\(OS X\\)에서 EC2를 접속하기\n\n터미널 프로그램 \\(기본 터미널 : command + space -&gt; ter -&gt; 엔터\\) EC2 키파일\\(.pem\\) 준비 되었다면 아래와 같이 세팅합니다.\n\n키파일을 원하는 위치에 복사하고 퍼미션을 400으로 조정합니다. \\(저는 ~/Desktop/key/로 정했습니다.\\)\n\n```bash\nchmod 400 ~/Desktop/key/keyfile.pem\n```\n\n터미널에서 키파일 옵션을 추가한 명령으로 ssh 접속\n\n```bash\nssh -i ~/Desktop/key/keyfile.pem ec2-user@[서버 아이피 또는 도메인]\n```\n\n아래는 참고 사항입니다.\n\n```\npem 파일이 아닌 ppk를 키파일로 사용하는 경우 : SSH 키 비밀번호를 입력을 요구하면서 인증 에러 발생\nssh접속 시 도메인에 아이디를 붙이지 않는 경우 : Permission denied (publickey) 에러 발생\n```\n\n아무 이상이없는데 permission denied가 계속 뜬다?\n\n그럼 아래의 known\\_hosts 파일을 확인해보자\n\n```\nvi ~/.ssh/known_hosts\n```\n\n이 파일을 봐도 모르겠다면 그냥 내용을 싹다 날리고 저장하자. 그럼 접속이 잘 된다.\n\n---\n\nReference\n\nhttp://blog.freezner.com/archives/1249","src/content/docs/server-side/aws.mdx","f1963f81bb8248cd","server-side/certbot",{"id":995,"data":997,"body":1002,"filePath":1003,"digest":1004,"deferredRender":15},{"title":998,"editUrl":15,"head":999,"template":17,"sidebar":1000,"pagefind":15,"draft":19},"Certbot",[],{"hidden":19,"attrs":1001},{},"## Certbot, aws https setting with wildcard\n\n```bash\nsudo apt update && sudo apt install certbot\n\nsudo certbot certonly --manual --preferred-challenges dns -d \"*.{domain}\" -d \"{domain}\" --server https://acme-v02.api.letsencrypt.org/directory\n```\n\n과정들을 따라하다보면...\n\n```\nPlease deploy a DNS TXT record under the name\n_acme-challenge.{domain} with the following value:\n\n{요기 나오는 문자들!}\n\nBefore continuing, verify the record is deployed.\n```\n\n요기나오는 문자들을 복사하여,\n\n\\_acme-challenge 라는 이름으로 TXT레코드를 생성하고 붙여넣으면된다.\n\n그리고나서 아래 명령어로 DNS TXT가 변경됐는지 확인\n\n```bash\nnslookup -q=TXT _acme-challenge.{domain}\n```\n\n변경되고나면 아까 진행하던 커맨드라인에서 엔터를 누르면 된다.\n\n이것이 DNS로 인증하는방법.\n\npem인코딩 내용들은 아래서 확인한다.\n\n```bash\nsudo cat /etc/letsencrypt/live/{domain}/privkey.pem\nsudo cat /etc/letsencrypt/live/{domain}/cert.pem\nsudo cat /etc/letsencrypt/live/{domain}/chain.pem\n```\n\naws NLB에서 사용했다.\n\n로드밸런서를 구성할때 참 편-안한 방법인것같다","src/content/docs/server-side/certbot.mdx","a0e180f3522cdd70","server-side/auto-deploy",{"id":1005,"data":1007,"body":1012,"filePath":1013,"digest":1014,"deferredRender":15},{"title":1008,"editUrl":15,"head":1009,"template":17,"sidebar":1010,"pagefind":15,"draft":19},"deploy with webhook",[],{"hidden":19,"attrs":1011},{},"### CI/CD 가 아닌, 간단한 예제입니다.\n\n~~아래 예제는 github actions 릴리즈 이후로 전혀 쓸모없지만..~~ webhook은 여전히 쓸모있다.\n\ngithub 이전의 나의 개인 블로그의 프론트와 백엔드는 분리되어서 개발되어있었는데,\n\n매번 소스코드를 수정하고 커밋푸시 후에는, 리눅스서버에 접속하여\n\n프론트만해도 git pull, npm install, npm run build, service nginx restart 명령어를 실행해줘야한다.\n\n무려 4개의 명령어를 실행해야하므로 너무 귀찮다. 당연히 &&로 명령어를 연결하여 실행하긴하는데,\n\n항상똑같은.. 너무 기계적인 작업이라 귀찮다.\n\n프로젝트 초기에는 그냥 했는데 이제 너무 귀찮아져서 자동화를 결심했다.\n\nci를 사용하려고 했는데 그 정도까지는 아직 필요성을 못느끼겠다.\n\n그래봤자 명령어 4개.\n\n실력향상겸\\(?\\) 직접 만들기로했다.\n\n첫번째는 내가 사용할 명령어를 쉘스크립트로 동작할수있게 코드를 작성했다.\n\n```bash\n## front.sh\n#!/bin/sh\necho \"boseok_log auto build start\"\n\neval \"cd /var/www/boseok_log && sudo git pull && sudo npm install && sudo npm run build && sudo service nginx restart\"\n\necho \"boseok_log auto build end\"\n```\n\n이런식으로.. 로그도 남겼다. 핵심은 당연히 eval이 있는 2번째줄.\n\n그리고 nodejs로 간단한 서버를 만들었다.\n\n해당 서버를 요청하게되면 쉘스크립트를 실행하도록했다.\n\n```javascript\nconst http = require('http');\nconst shell = require('shelljs');\n\nhttp.createServer((req, res) => {\n  const {url} = req;\n  if(url === '/favicon.ico')\n    return;\n\n  console.log(`request ${url} build`);\n\n  if(validateURL(url)){\n    console.log(`start building => ${url}`);\n    shell.exec(`.${url}.sh`);\n    res.write(`build end => ${url}`);\n    console.log('build end');\n  } else {\n    res.write(`${url} not found\\n`);\n  }\n  res.end();\n}).listen(8887);\n\nconst validateURL = url => ['front', 'back'].some(param => `/${param}`=== url);\n```\n\n```\n서버주소:8887/front\n서버주소:8887/back\n```\n\n위의 주소로 요청을 날리면 된다.\n\n이 서버요청이 필요한 이유는,\n\n소스코드를 github나 bitbucket을 사용하여 저장하고있는데\n\n거기서 webhook이라는 기능을 지원한다.\n\n소스코드를 remote repository에 푸시하면,\n\nwebhook에 등록한 url을 요청한다.\n\n거기에 방금 작성한 서버 url을 등록해서,\n\n수정된 소스코드를 푸시하면, 자동으로 빌드, 배포를 할수있다.","src/content/docs/server-side/auto-deploy.mdx","085ef738c9efb072","server-side/letsencrypt",{"id":1015,"data":1017,"body":1022,"filePath":1023,"digest":1024,"deferredRender":15},{"title":1018,"editUrl":15,"head":1019,"template":17,"sidebar":1020,"pagefind":15,"draft":19},"letsencrypt",[],{"hidden":19,"attrs":1021},{},"letsencrypt 라는 서비스는,\n\nhttps를 사용하기위한 인증서를 무료로 사용할 수 있게 해줍니다!\n\n하지만 3개월마다 갱신을 해줘야하는데~ 쉘스크립트&크론탭을 사용하면 자동화시킬수있습니다.\n\nubuntu18 lts 기준으로 작성하였습니다~\n\n```bash\nsudo apt update && sudo apt install letsencrypt\n```\n\n혹시 80, 443 포트가 사용중이라면 안전한 ssl 세팅을 위해 잠시 중지해주세요.\n\n```bash\nsudo letsencrypt certonly --standalone -d 도메인\n```\n\n끝\n\n맥에서는 방법이 조금 다릅니다.\n\nhomebrew에 letsencrypt 모듈이 없고,\n\ncertbot을 대신 사용하면 됩니다.\n\n## crontab을 이용한 auto renew\n\n3개월마다 인증서를 갱신해야하는데, 매번하는건 귀찮기도하고 까먹을수도 있으므로\n\n쉘스크립트와 크론탭을 사용하여 자동화시켜보겠다.\n\n```bash\nsudo wget https://dl.eff.org/certbot-auto && sudo chmod a+x certbot-auto && sudo mv certbot-auto /etc/letsencrypt/\nsudo crontab -e\n```\n\n```bash\nsudo vi /etc/letsencrypt/renewal/${domain}.conf\n```\n\n아래 라인을 찾아서 앞에 \\#을 붙여서 주석처리해준다\n\n```\n# standalone_supported_challenges = \"tls-sni-01,http-01\"\n```\n\n에디터를 선택하고 열면, 아래 스크립트를 작성한다. nginx기준 일주일에 한번, 2:45 시간에 맞춰서 자동으로 스크립트가 동작할것이다.\n\n```\n45 2 * * 6 sudo service nginx stop && /etc/letsencrypt/certbot-auto renew && sudo service nginx start\n```\n\nref: https://www.onepagezen.com/letsencrypt-auto-renew-certbot-apache/#step1\n\n### 트러블슈팅\n\n```\nTo fix these errors, please make sure that your domain name was\n   entered correctly and the DNS A/AAAA record(s) for that domain\n   contain(s) the right IP address. Additionally, please check that\n   your computer has a publicly routable IP address and that no\n   firewalls are preventing the server from communicating with the\n   client. If you're using the webroot plugin, you should also verify\n   that you are serving files from the webroot path you provided.\n```\n\n이런 에러메시지와 마주치게된다면..\n\n```bash\ncertbot certonly -d 도메인 --manual --preferred-challenges dns\n```\n\n```\nNOTE: The IP of this machine will be publicly logged as having requested this\ncertificate. If you're running certbot in manual mode on a machine that is not\nyour server, please ensure you're okay with that.\n\nAre you OK with your IP being logged?\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n(Y)es/(N)o: Y\n```\n\n```\nPlease deploy a DNS TXT record under the name\n_acme-challenge.somedomain.com with the following value:\n\n여기에 나오는 키를 복사해두세요!!\nsadfadsf6a8s7df67a8sd6f78 \u003C\u003C요런거\n\nBefore continuing, verify the record is deployed.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nPress Enter to Continue\n```\n\nDNS 서버에 TXT 레코드를 등록하는데, 호스트의 prefix로 \\_acme-challenge를 쓰는걸 빼먹지마세요!!\n\n```\nhost => _acme-challenge.somedomain.com\n```\n\nTXT의 value에 아까 복사한걸 붙여넣으시면 됩니다.\n\n새로운 터미널에서 등록됐는지 먼저 확인한다음에\n\n```\nnslookup -q=TXT _acme-challenge.somedomain.com\n```\n\n원래 진행하던 터미널에서 엔터누르고 발급하면 끝\n\n트러블슈팅 reference: [https://www.lesstif.com/pages/viewpage.action?pageId=59343172](https://www.lesstif.com/pages/viewpage.action?pageId=59343172)","src/content/docs/server-side/letsencrypt.mdx","6f27c7cdfa030d25","server-side/mysql",{"id":1025,"data":1027,"body":1032,"filePath":1033,"digest":1034,"deferredRender":15},{"title":1028,"editUrl":15,"head":1029,"template":17,"sidebar":1030,"pagefind":15,"draft":19},"mysql 설치",[],{"hidden":19,"attrs":1031},{},"현재 오픈소스 DB중에 가장 인기많은 데이터베이스다.\n\n아래는 ubuntu 18.04 lts 기준으로 작성하였다.\n\n요즘은 aws RDS를 사용해서 mysql을 많이 사용하지만, 직접 서버에 mysql을 설치하고 셋팅하는 방법도 알아두자.\n\n```bash\nsudo apt-get update\nsudo apt-get install mysql-server\n\nsudo ufw allow 3306\n\nmysql -u root -p\n```\n\n## ip 바인딩\n\n데이터베이스에 접근할수있는 ip를 설정한다.\n\n```bash\nsudo vi /etc/mysql/my.cnf\n혹은 sudo vi /etc/mysql/mysql.conf.d/mysqld.cnf\n```\n\n```\n[client]\nuser=root(유저네임)\npassword=실제패스워드\nport=3306\nsocket=/var/run/mysql/mysql.sock\n[mysqld]\nbind-address=ip주소 #0.0.0.0은 모두 허용\n```\n\n## 패스워드 관련 문제 해결\n\n```sql\nGRANT ALL ON *.* TO 'user'@'localhost' IDENTIFIED BY 'passwd' WITH GRANT OPTION;\nGRANT ALL ON *.* TO 'user'@'%' IDENTIFIED BY 'passwd' WITH GRANT OPTION;\nFLUSH PRIVILEGES;\nEXIT;\n```\n\n```bash\nsudo service mysql restart\n```\n\nor\n\n```\nStop mysql:\n1. service mysql stop\n\nRun mysql with skip grants to be able to login without any password\n2. mysqld_safe --skip-grant-tables &\n\nLogin as root\n3. mysql -u root\n\n4. mysql commands:\nmysql> use mysql;\nmysql> update user set password=PASSWORD(\"NEW-ROOT-PASSWORD-HERE\") where User='root';\nmysql> flush privileges;\nmysql> quit\n\nStop mysql\n5. service mysql stop\n\nStart mysql normally:\n6. service mysql start\n\nTry to login using your new password:\n7. mysql -u root -p\n```\n\n이런에러가 발생하면 아래와같은 명령어를 터미널에서 실행하자.\n\n```bash\nERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement.\n```\n\n```bash\nmysql> SET PASSWORD = PASSWORD('비밀번호');\n```","src/content/docs/server-side/mysql.mdx","b7f5043b216b43c9","server-side/nginx",{"id":1035,"data":1037,"body":1042,"filePath":1043,"digest":1044,"deferredRender":15},{"title":1038,"editUrl":15,"head":1039,"template":17,"sidebar":1040,"pagefind":15,"draft":19},"nginx",[],{"hidden":19,"attrs":1041},{},"# nginx\n\nstatic 파일을 제공할 수 있는 웹서버이다.\n\n대표적인 웹서버 아파치와는 다르게 비동기로 작동한다.\n\n서버에 많은 부하가 생길 경우의 성능을 예측하기 쉽게 해준다.\n\n## 설치\n\nubuntu 16 기준으로 작성하였습니다.\n\nubuntu 18에서는 apt-get 명령어가 apt로 변경되었습니다.\n\n```\nsudo apt-get update\nsudo apt-get install nginx\n```\n\n웹브라우저에 ip주소를 입력하고 접속하면 welcome to nginx 화면이 나온다.\n\n```\n1. 서비스 목록을 확인\n - service --status-all|grep +\n2. 방화벽 확인\n - sudo ufw app list\n - sudo ufw allow 'Nginx HTTP'\n - sudo ufw status\n3. 서비스되는지 확인\n - systemctl status nginx\n4. 서비스 정지\n - sudo systemctl stop nginx\n - stop 외에 start, restart, reload, disable, enable 명령어가 있다.\n5. cd /var/www/html => build 된 project를 deploy하면 된다.\n6. 로그 확인\n - /var/log/nginx/access.log 혹은 error.log\n```\n\n## 간단한 설정 방법\n\nubuntu 16버전 이상 기준 설정파일이 있는곳\n\n```\nvi /etc/nginx/sites-available/default\nvi /etc/nginx/nginx.conf\n```\n\nnginx에 여러개의 웹이 올라갈거라면\n\ndefault 대신에 도메인을 정의하고\n\n정의한 도메인을 default에 설정해주면 된다.\n\n모듈로 관리해서 편해진다.\n\n```\nserver {\n  listen  80;\n  server_name boseok.me;\n  return 301 https://$host$request_uri;\n  # https로 redirect. or proxy_pass를 사용하자.\n}\n\nserver {\n  # SSL configuration\n  listen 443 ssl default_server;\n  listen [::]:443 ssl default_server;\n  # https 기본포트로 설정. 다른 포트를 입력하면 접속할때 도메인 뒤에 포트번호가 붙어야한다.\n\n  ssl_certificate /인증서경로/fullchain.pem;\n  ssl_certificate_key /인증서경로/privkey.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n  ssl_ciphers HIGH:!aNULL:!MD5;\n  # 인증서 설정\n\n  root /var/www/boseok_log/build;\n  # 설정한 포트로 접속할때, 기본 path\n\n  server_name boseok.me;\n\n  # path뒤에 param을 설정할 수 있다. ex) location /boseok {...} \n  location / { \n    # SPA이기때문에 설정해놓았습니다.\n    try_files $uri $uri/ /index.html;\n  }\n\n}\n```\n\n## nginx https 설정\n\n인증서 발급이나 기본적인 인증서 설정은 [여기를 참고하세요 =&gt; letsencrypt](/server-side/letsencrypt/)\n\nubuntu18 기준\n\n```bash\nsudo vi /etc/letsencrypt/sites-available/default\n```\n\n아래 코드에 섞여있는 도메인과 서버이름은 알맞게 바꾸세요~\n\n```\nserver {\n       listen         80;\n       server_name    boseok.me;\n       return         301 https://$host$request_uri;\n}\n\nserver {\n    listen 443 ssl default_server;\n    listen [::]:443 ssl default_server;\n\n    ssl_certificate /etc/letsencrypt/live/boseok.me/fullchain.pem;\n    ssl_certificate_key /etc/letsencrypt/live/boseok.me/privkey.pem; ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\nssl_ciphers HIGH:!aNULL:!MD5;\n}\n```\n\n```bash\nsudo service nginx restart\n```","src/content/docs/server-side/nginx.mdx","d80a21e882c9934d","server-side/nlb",{"id":1045,"data":1047,"body":1052,"filePath":1053,"digest":1054,"deferredRender":15},{"title":1048,"editUrl":15,"head":1049,"template":17,"sidebar":1050,"pagefind":15,"draft":19},"nlb",[],{"hidden":19,"attrs":1051},{},"# nlb\n\n## Network Load Balance \\(AWS\\)\n\n\\*AWS의 NLB를 사용법을 간단하게 알려드리려고 합니다!\n\n```\n퍼블릭'만'을 사용하는것을 전제로 합니다.\n\n그래서 이 방법은 엄격히 따지면 정석이 아님을 알려드립니다.\n\n먼저 *VPC 설정부터 시작합니다.\n\nAWS에서 VPC 서비스를 선택합니다.\n```\n\n### 1. VPC 생성\n\n```\n이름태그: 알아볼수있게 입력하세요 (리전-서비스이름-vpc)\n\nIPv4 CIDR 블록: 172.16.0.0/16\n\n나머지 기본값\n```\n\n### 2. 서브넷 생성\n\n```\n이름태그: 알아볼수있게 입력하세요 (리전-서비스이름-subnet)\n\nVPC: 아까 생성한 VPC 선택\n\n가용 영역: 하나를 선택합니다. 혹시 모르니 기억해두세요\n\nIPv4 CIDR 블록: 172.16.0.0/24\n```\n\n### 3. 라우팅 테이블\n\n```\n이름태그: 알아볼수있게 입력하세요 (리전-서비스이름-rt)\n\nVPC: 아까 생성한 VPC 선택\n```\n\n### 4. 인터넷 게이트웨이\n\n```\n인터넷 게이트 웨이 생성\n\n이름태그: 알아볼수있게 입력하세요 (리전-서비스이름-igw)\n```\n\n```\n생성된 igw를 아까 생성한 VPC에 연결\n```\n\n### 5. 라우팅 테이블 설정\n\n```\n아까 생성한 라우팅 테이블을 설정합니다.\n\n해당 rt를 선택합니다.\n\n서브넷 연결탭 => 서브넷 연결 편집 버튼 클릭\n\n아까 생성한 서브넷에 체크하고 저장\n\n라우팅 탭에서 라우팅 편집 버튼을 클릭합니다\n\n라우팅 추가 버튼을 클릭\n\n대상으로 먼저 0.0.0.0/0 입력\n\n두번째 대상으로 Internet gateway 선택, 아까 생성한 igw 선택\n```\n\n### 6. 네트워크 ACL 확인\n\n```\n네트워크 ACL에서 해당 VPC가 연결된 네트워크 ACL을 선택하고 인바운드, 아웃바운드 규칙을 확인합니다.\n\n여기서 규칙번호의 숫자가 낮은것이 우선적으로 적용됩니다\n```\n\n## Load Balancer\n\n```\n본격적인 AWS의 EC2 서비스에서 로드밸런서를 생성하고 설정해보겠습니다\n```\n\n### 1. 로드 밸런서 생성\n\n```\n로드밸런서메뉴에서 로드밸런서 생성 버튼 클릭\n\nNetwork Load Balancer 선택\n\n알아볼수있는 이름 입력 (리전-서비스이름-nlb)\n\n체계: 인터넷 연결\n\n리스너는 TLS만 우선 선택합니다\n\n가용영역에서는 위에서 생성한 VPC를 선택하도록 합니다\n\n그리고 아까 기억해뒀던 가용영역을 선택합니다. (어차피 과정을 따라했다면 그것밖에 없지만..)\n\nIPv4 주소는 탄력적 IP(EIP)를 선택합니다. 없으면 생성.\n\n실험차 생성해봤는데, EIP를 생성해도 탄력적 IP 선택이 불가능한데,\n\n새로고침해야 선택할수있습니다..\n\n두번째로 보안 설정 구성인데, 저는 유료 인증서가 없으므로, certbot를 사용합니다\n\ncertbot을 사용하면 letsencrypt인증서를 생성하고, 편하게 [IAM으로 인증서업로드] 과정을 진행할수있습니다\n```\n\n[certbot에 대한 내용은 여기서 확인하세요](/server-side/certbot/)\n\n```\n세번째는 라우팅 구성인데, 이건 앞으로 서브넷에 ec2를 생성하고 그 ec2에 연결할것이므로\n\n대상유형에 ip를 지정하고 서브넷에 생성한 ec2들을 지정하면 됩니다.\n\n예를들어 ec2의 첫번째 인스턴스의 3000번 포트를 사용하고싶다하면 해당 인스턴스 private ip와 포트를 작성해주면됩니다.\n\n그리고 네번째 대상그룹인데, 여기서 이제 두번째, 세번째, ...인스턴스들을 추가해주면 됩니다.\n```\n\nL4 레벨에서 로드밸런싱을 해준다니 좋은 기능인것같습니다. 그래서 특히나 통합으로 인증서를 관리하는건\n\nletsencrypt특성상 3개월마다 인증서 갱신을 확인하는 절차가 사라져서 편리합니다.","src/content/docs/server-side/nlb.mdx","6e984201ed4d1f80","server-side/rest",{"id":1055,"data":1057,"body":1062,"filePath":1063,"digest":1064,"deferredRender":15},{"title":1058,"editUrl":15,"head":1059,"template":17,"sidebar":1060,"pagefind":15,"draft":19},"restful api",[],{"hidden":19,"attrs":1061},{},"2000년도 =&gt; http의 주요 저자 중 한명인 로이 필딩이 창시\n\n## 왜 이제서야 각광받게 되었나?\n\n요즘 시대에는 디바이스의 종류가 다양하다.\n\npc, 스마트폰, 태블릿 등등..\n\n디바이스마다 앱을 따로 만들어야하는데, 같은 로직을 가진 서버까지 디바이스마다 개발?\n\n클라이언트와 서버를 분리해서 개발하는 것이 트렌드가 됨\n\n서버는 API만 제공 =&gt; 클라이언트가 받아서 처리\n\nAPI를 설계하다보니, 좋은 설계의 REST API가 이제서야 각광받게 됨.\n\n## 특징\n\n1\\) Uniform \\(유니폼 인터페이스\\) Uniform Interface는 URI로 지정한 리소스에 대한 조작을 통일되고 한정적인 인터페이스로 수행하는 아키텍처 스타일을 말합니다.\n\n2\\) Stateless \\(무상태성\\) REST는 무상태성 성격을 갖습니다. 다시 말해 작업을 위한 상태정보를 따로 저장하고 관리하지 않습니다. 세션 정보나 쿠키정보를 별도로 저장하고 관리하지 않기 때문에 API 서버는 들어오는 요청만을 단순히 처리하면 됩니다. 때문에 서비스의 자유도가 높아지고 서버에서 불필요한 정보를 관리하지 않음으로써 구현이 단순해집니다.\n\n3\\) Cacheable \\(캐시 가능\\) REST의 가장 큰 특징 중 하나는 HTTP라는 기존 웹표준을 그대로 사용하기 때문에, 웹에서 사용하는 기존 인프라를 그대로 활용이 가능합니다. 따라서 HTTP가 가진 캐싱 기능이 적용 가능합니다. HTTP 프로토콜 표준에서 사용하는 Last-Modified태그나 E-Tag를 이용하면 캐싱 구현이 가능합니다.\n\n4\\) Self-descriptiveness \\(자체 표현 구조\\) REST의 또 다른 큰 특징 중 하나는 REST API 메시지만 보고도 이를 쉽게 이해 할 수 있는 자체 표현 구조로 되어 있다는 것입니다.\n\n5\\) Client - Server 구조 REST 서버는 API 제공, 클라이언트는 사용자 인증이나 컨텍스트\\(세션, 로그인 정보\\)등을 직접 관리하는 구조로 각각의 역할이 확실히 구분되기 때문에 클라이언트와 서버에서 개발해야 할 내용이 명확해지고 서로간 의존성이 줄어들게 됩니다.\n\n6\\) 계층형 구조 REST 서버는 다중 계층으로 구성될 수 있으며 보안, 로드 밸런싱, 암호화 계층을 추가해 구조상의 유연성을 둘 수 있고 PROXY, 게이트웨이 같은 네트워크 기반의 중간매체를 사용할 수 있게 합니다.\n\n## REST API의 설계\n\n1\\) URI =&gt; 자원을 표현 =&gt; 동사를 사용하지않고 명사를 사용함 2\\) 자원에 대한 행위 =&gt; HTTP Method\\(GET, POST, PUT, DELETE\\)로 표현\n\n```bash\nGET : 조회\nPOST : 생성\nPUT : 수정\nDELETE : 삭제\n```\n\n```bash\nGET users/1 # user id 1에 해당하는 유저 정보 가져오기 \nPUT users/1 # user id 1에 해당하는 유저 정보 수정\n```\n\nreference:\n\nhttp://meetup.toast.com/posts/92\n\nhttps://github.com/iljun/DevNote/tree/master/common/restFulAPI","src/content/docs/server-side/rest.mdx","522ed18f17021f4c","godot4/tilemap",{"id":1065,"data":1067,"body":1072,"filePath":1073,"digest":1074,"deferredRender":15},{"title":1068,"editUrl":15,"head":1069,"template":17,"sidebar":1070,"pagefind":15,"draft":19},"TileMapLayer",[],{"hidden":19,"attrs":1071},{},"## TileMapLayer란?\n\n2D 게임에서 타일맵을 사용하여 맵을 구성할 때, 여러 레이어를 활용하여 다양한 시각적 효과와 기능을 구현할 수 있습니다.\n\nGodot 4에서는 TileMapLayer를 통해 이러한 레이어를 쉽게 관리할 수 있습니다.\n\nTileMapLayer는 각 레이어에 대해 독립적인 타일맵을 생성하고 조작할 수 있는 기능을 제공합니다.\n\n이를 통해, 배경, 중간 배경, 전경 등 다양한 레이어를 구성하여 게임의 깊이감을 높일 수 있습니다.\n\n물론 배경은 ParallaxBackground 노드를 사용하는 방법도 있습니다.\n\n바닥에 타일을 생성하는것 뿐만 아니라, collision등을 추가할수도 있고, 애니메이션이 포함된 타일도 사용할 수 있습니다.\n\n심지어 상호작용할 오브젝트도 타일맵으로 생성할 수 있습니다. 일반 노드를 사용하는것 보단 복잡할 수도 있겠지만,\n\n단순히 부숴지는 블럭이라던지, 이런것들을 배치할땐 타일맵이 유리할 수 있습니다.\n\n## 사용법\n\n먼저 씬에 TileMapLayer 노드를 추가해야 합니다. 사용하고싶은 레이어가 많다면 여러개 추가하면 됩니다.\n\n각 TileMapLayer 노드에는 타일셋을 설정할 수 있는 옵션이 있습니다. 타일셋은 타일맵에서 사용할 타일들의 모음을 정의합니다.\n\n타일셋은 TileMapLayer 노드와 독립적입니다. 즉, 여러 TileMapLayer 노드가 동일한 타일셋을 공유할 수 있고,\n\n각 레이어마다 다른 타일셋을 사용할 수도 있습니다. collision 등의 physics와 같은 속성은 타일셋에서 정의합니다\n\n\u003Cimg src=\"/images/godot/tilemap1.png\" alt=\"tilemap1\" />\n\n타일셋을 설정한 후, 타일맵 에디터를 사용하여 각 레이어에 타일을 배치할 수 있습니다.\n\n특정 타일에 collision을 추가하려면, 타일셋에서 미리 physics layer를 추가한 이후,\n\n타일맵 에디터에서 Select탭을 선택하고, 원하는 타일을 선택한 후, physics를 선택하면\n\n아까 타일셋 physics layer가 보일겁니다. 그걸 선택하면 해당 타일에 collision을 편집하고 추가할 수 있습니다.\n\n\u003Cimg src=\"/images/godot/tilemap2.png\" alt=\"tilemap2\" />\n\n그 외에도 다양한 기능들이 있으니, 공식 문서나 튜토리얼을 참고하여 TileMapLayer를 활용한 멋진 2D 게임 맵을 만들어보세요!\n\n특히 auto tile 기능을 꼭 확인하세요! 가장자리나 모서리 타일을 자동으로 배치해주는 기능입니다.","src/content/docs/godot4/tilemap.mdx","04bb0885f9a5e6de","tip/git",{"id":1075,"data":1077,"body":1082,"filePath":1083,"digest":1084,"deferredRender":15},{"title":1078,"editUrl":15,"head":1079,"template":17,"sidebar":1080,"pagefind":15,"draft":19},"Git",[],{"hidden":19,"attrs":1081},{},"## Git 설치 및 설정\n\ngit이 설치되어있지않다면, mac 환경이라면 우선 homebrew를 이용하여 git을 설치하자.\n\n```bash\nbrew install git\n```\n\ngit flow를 사용한다면\n\n```bash\nbrew install git-flow\n```\n\n```bash\ngit config --global user.name \"jewelism\"\ngit config --global user.email \"boseokjung@gmail.com\"\n```\n\n## pr을 통해 코드 리뷰하는 절차\n\n1. 원본의 remote repository를 자신의 repository로 fork\n2. 자신의 git repository clone\n3. git remote add upstream 원본 원격 저장소의 주소\n4. 소스수정..\n5. git add 수정한파일 \\(git add . 은 모두\\)\n6. git commit -m \"커밋메시지\"\n7. git pull upstream 브랜치이름\\(3번에서 추가한 upstream이라는 이름과 일치해야함\\)\n8. git push origin 브랜치이름\n9. 원격저장소 웹에서 pull request 작성\n\n혹은\n\n1. remote repository clone\n2. 소스수정..\n3. git add 수정한파일 \\(git add . 은 모두\\)\n4. git commit -m \"커밋메시지\"\n5. git pull origin 브랜치\n8. git push origin 브랜치이름\n9. 원격저장소 웹에서 pull request 작성\n\n\n## 대소문자 구분을 안하는 git\n\ngit은 대소문자 구분을 하지않아서, 파일이나 디렉토리 이름을 변경할때\n\n단순 대소문자만 변경하는 경우 (common => Common 이런식) 변경으로 구분하지 않는다.\n\n```bash\ngit mv common tmp && git mv tmp Common\n```\n\n```bash\ngit mv {파일이름} tmp && git mv tmp {변경하고싶은이름}\n```\n\n이런식으로 꼼수써서 변경할 수 있다.\n\n## .gitignore 파일 사용법\nrepository에 소스를 올릴때, .gitignore 파일에 특정 디렉토리나 파일 이름을 작성해놓으면,\n\n그 디렉토리나 파일은 제외된다.\n\n.gitignore 예시\n\n```\n/node_modules\n.DS_STORE\n.idea\n\n.env\n```\n\n## 이미 커밋된 파일을 git ignore 하는 방법\n\ngitignore파일을 수정하고 다음명령어를 실행한다.\n\n```bash\ngit rm --cached /path/to/file\n```\n\n그 후 커밋하고 푸시하면 된다.\n\n## Git 자격증명 삭제\n\n```bash\ngit config --global --unset credential.helper\ngit config --system --unset credential.helper\n```\n\n위 명령어를 통해 저장된 자격증명을 삭제할 수 있다.\n\n## Git 패스워드 변경후 에러\n\nremote의 패스워드를 변경하면 로컬에서 푸시할때 아래와 같은 에러가 난다.\n\n로컬에 저장되어있는 패스워드와 리모트 패스워드가 다르기때문.\n\n```bash\nremote: Invalid username or password.\nfatal: Authentication failed for 'https://github.com/jewelism/boseok-note.git/'\n```\n\n그냥 아래처럼 초기화해주면 된다.\n\n```bash\ngit config --unset credential.helper\n```\n\n이런 문제도 있고, 귀찮기때문에 ssh키를 이용하는걸 추천한다.\n\n## git remote \n\nremote 확인\n\n```bash\ngit remote -v\n```\n\nremote url 변경\n\n```bash\ngit remote set-url {alias} {url}\n```\n\n\n## ssh key 생성 및 설정\n\nbitbucket에서 mac 사용시.. \\(linux도 해당됨\\)\n\n```bash\nssh-keygen\n```\n\npassphase는 입력하지말고 그냥 빈값으로 계속 엔터만 눌러주자.\n\n그래야 나중에 안귀찮아진다.\n\n```bash\ncat ~/.ssh/id_rsa.pub\n```\n\n이걸 프로젝트의 access keys가 아닌, 자신의 계정의 bitbucket의 SSH key에 가서 추가한다.\n\n```bash\neval 'ssh-agent'\n```\n\n```bash\n#mac\nssh-add -K ~/.ssh/id_rsa\n\nvi ~/.ssh/config\n```\n\n아래내용을 붙여넣는다\n\n```\nHost *\n  UseKeychain yes\n```\n\n```bash\n#linux\nssh-add ~/.ssh/id_rsa\n```\n\nubuntu 에서 사용할 쉘스크립트를 작성해보았다.\n\n주의할점은 ssh-keygen의 default path가 mac과는 다르게\\(home\\) /root 이다.\n\n```bash\n#!/bin/bash\n\nssh-keygen;\n\neval 'ssh-agent';\nssh-add /root/.ssh/id_rsa;\ncat /root/.ssh/id_rsa.pub;\nexit;\n```","src/content/docs/tip/git.mdx","e5e824c026131753","tip/vscode_tips",{"id":1085,"data":1087,"body":1092,"filePath":1093,"digest":1094,"deferredRender":15},{"title":1088,"editUrl":15,"head":1089,"template":17,"sidebar":1090,"pagefind":15,"draft":19},"vscode tips",[],{"hidden":19,"attrs":1091},{},"## VSCode Change Case 플러그인\n\nvscode에서, 영문의 대소문자를 편하게 바꾸거나 camel, constants 등등\n\n영문자를 타이핑하고 원하는 케이스로 변경시켜주는 플러그인이 있다.\n\n[change-case](https://marketplace.visualstudio.com/items?itemName=wmaurer.change-case)\n\n플러그인을 설치하고 숏컷으로 등록해놓자.\n\ncommand + shift + U 가 제일 쓸만한 숏컷.\n\n## VScode 숏컷\n\n맥 기준입니다.. 윈도우 사용자는 command키를 control키로 생각하시면 될거같습니다.. 아마..\n\n### command 창\n\ncommand + shift + P\n\n숏컷으로 등록해놓지않은 명령어를 찾아서 실행시킬 수 있습니다\n\n혹은 \\> 를 지우게되면, 파일을 바로 검색해서 찾아갈 수 있더라구요. 제일 유용합니다. 인텔리제이에서 쉬프트 두번 누르는거하고 비슷해요. 그거보단 좀 손이 더 가고 느리지만..\n\n### 같은 단어 한꺼번에 블록\n\ncommand + shift + L\n\nreplaceAll 같은걸 사용해도 좋지만 저게 더 편하거나 빠를때도 있습니다\n\n## vscode user snippet\n\n역시나 맥 기준입니다\n\nvscode에는 user snippet 기능이 있습니다\n\nsnippet은 대충 미리 코드뭉치를 만들어놓고 계속해서 생성해서 사용하는 개념이에요\n\nreact에서 매번 컴포넌트를 찍어낼때마다 공통적으로 반복해서 작성해야하는 코드들이 있죠.\n\n예를 들어서\n\nTopBottom.tsx 파일을 생성했다고 합시다.\n\n그러면 파일 내부에 가장 먼저 작성하게되는 내용이 \n\n```js\nconst TopBottom = () => {\n  return \u003Cdiv>TopBottom\u003C/div>;\n};\n\nexport default TopBottom;\n```\n\n이런 모습이죠.\n\n파일이름을 가지고 기본 컴포넌트의 내용을 만들어주는 user snippet 기능을 생성해봅시다.\n\n## 활용방법\n\n```\n1. command + shift + P\n2. snippet 타이핑\n3. Preferences: Configure User Snippets\n```\n글로벌로 생성할지, 특정 프로젝트에만 생성할지 결정합시다. 저는 몇개 안써서 글로벌로 합니다.\n\n특정 프로젝트에 생성하게되면, 프로젝트 내부에 .vscode 디렉토리에 스니펫이 저장됩니다.\n\n이걸로 팀원들과 vscode snippet을 공유할수도 있겠죠.\n\n아래처럼 내용을 수정합니다.\n\n```json\n{\n\t// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and \n\t// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope \n\t// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is \n\t// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: \n\t// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. \n\t// Placeholders with the same ids are connected.\n\t// Example:\n\t\"rcc\": {\n\t\t// \"scope\": \"javascript,typescript\",\n\t\t\"prefix\": \"rcc\",\n\t\t\"body\": [\n\t\t\t\"const $TM_FILENAME_BASE = () => {\",\n\t\t\t\"  return (\",\n\t\t\t\"    \u003Cdiv>$TM_FILENAME_BASE\u003C/div>\",\n\t\t\t\"  );\",\n\t\t\t\"}\",\n\t\t\t\"\",\n\t\t\t\"export default $TM_FILENAME_BASE;\"\n\t\t],\n\t\t\"description\": \"Create React Component\"\n\t}\n}\n```\n\n```$TM_FILENAME_BASE```는 파일 이름을 뜻합니다. 작성하기가 좀 귀찮은 구조로 되어있지만.. 쉽죠?\n\n이제 vscode에서 rcc를 타이핑하면, 자동완성기능이 스니펫을 사용할지 물어봐줍니다!","src/content/docs/tip/vscode_tips.mdx","f1aa9f2161bcc8fc","server-side/node_js",{"id":1095,"data":1097,"body":1102,"filePath":1103,"digest":1104,"deferredRender":15},{"title":1098,"editUrl":15,"head":1099,"template":17,"sidebar":1100,"pagefind":15,"draft":19},"nodejs",[],{"hidden":19,"attrs":1101},{},"## nodejs에서 dynamodb 사용하기\n\n### 환경설정\n\nubuntu18 기준으로 작성하였습니다.\n\n```bash\nsudo apt install awscli\n```\n\n```bash\naws configure\n```\n\n실행하면 아래처럼 input이 차례대로 4개 나옵니다.\n\naws계정을 참고해서 복붙하세요~ 아래는 예시입니다.\n\n```bash\nAWS Access Key ID [None]: someAccessKey\nAWS Secret Access Key [None]: someSecretKey\nDefault region name [None]: ap-northeast-2\nDefault output format [None]: json\n```\n\n이렇게하면 aws cli는 끝입니다.\n\n노드에서 aws-sdk를 사용할때, 방금 설정한 configure를 사용하게 됩니다.\n\n노드 프로젝트에서 아래 명령어를 실행합니다.\n\n```bash\nnpm install aws-sdk -S\n```\n\n### 테이블 생성\n\n```javascript\n// config/dynamo.js\nconst {AWS_REGION} = require('../../constants');\n\nconst AWS = require('aws-sdk');\n\nAWS.config.update({\n  region: AWS_REGION,\n});\n\nconst docClient = new AWS.DynamoDB.DocumentClient();\n\nmodule.exports = {AWS, docClient};\n```\n\n```javascript\n// constants/index.js\nconst AWS_REGION = 'ap-northeast-2';\nconst SURVEY_TABLE = 'moqa_web_survey';\n\nmodule.exports = {AWS_REGION, SURVEY_TABLE};\n```\n\n```javascript\n// scripts/createSurveyTable.js\nconst {AWS} = require('../../config/dynamo');\n\nconst {SURVEY_TABLE} = require(\"../../../constants\");\n\nconst dynamodb = new AWS.DynamoDB();\n\nconst params = {\n  TableName: SURVEY_TABLE,\n  KeySchema: [\n    {AttributeName: '_id', KeyType: 'HASH'},\n  ],\n  AttributeDefinitions: [\n    {AttributeName: '_id', AttributeType: 'S'},\n  ],\n  ProvisionedThroughput: {\n    ReadCapacityUnits: 10,\n    WriteCapacityUnits: 10\n  }\n};\n\ndynamodb.createTable(params, function (err, data) {\n  if (err) {\n    console.error('Unable to create table. Error JSON:', JSON.stringify(err, null, 2));\n  } else {\n    console.log('Created table. Table description JSON:', JSON.stringify(data, null, 2));\n  }\n});\n```\n\n코드를 작성하고, 아래 명령어를 실행시킵니다.\n\n```bash\nnode scripts/createSurveyTable.js\n```\n\n테이블이름 같은 경우는, get post put delete할때도 써야하므로 별도의 constants.js에서 관리합니다.\n\n## 테이블에서 데이터 조회\n\n```javascript\nconst findAll = () => {\n  return new Promise((resolve, reject) => {\n    const params = {\n      TableName: SURVEY_TABLE,\n    };\n\n    docClient.scan(params, function (err, data) {\n      if (err) {\n        console.error(\"Unable to read item. Error JSON:\", JSON.stringify(err, null, 2));\n        const {message, time} = err;\n        reject({message, time});\n      } else {\n        resolve(data.Items);\n      }\n    });\n  });\n};\n```\n\n위 코드 블럭은 해당 테이블의 **모든 데이터**를 조회하는 function입니다.\n\nexpress사용시, 라우팅은 위의 함수를 활용하여 아래와 같이 작성합니다.\n\n```javascript\nrouter.get('/all', async (req, res, next) => {\n  findAll().then(data => {\n    res.status(200).send(data);\n  }).catch(e => {\n    res.status(500).send(e);\n  });\n});\n```\n\n모두 조회 후 author로 필터링\n\n```javascript\nrouter.get('/author/:author', async (req, res, next) => {\n  const {author} = req.params;\n\n  findAll().then(data => {\n    const result = data.Items.filter(item => item.author === author);\n    res.status(200).send(result);\n  }).catch(e => {\n    res.status(500).send(e);\n  });\n});\n```\n\n\\_id로 한개 조회하기\n\n```javascript\nrouter.get('/:_id', async (req, res, next) => {\n  const {_id} = req.params;\n\n  const params = {\n    TableName: SURVEY_TABLE,\n    Key: {_id}\n  };\n\n  docClient.get(params, function (err, data) {\n    if (err) {\n      const {message, time} = err;\n      res.status(500).send({message, time});\n      console.error(\"Unable to read item. Error JSON:\", JSON.stringify(err, null, 2));\n    } else {\n      res.status(200).send(data.Item);\n    }\n  });\n});\n```\n\ndocClient의 scan메소드와는 다르게, get을 사용하면 key로 설정해놓은 컬럼들을 params의 Key라는 프로퍼티에 할당해야합니다.\n\nsort key가 있다면, sort key도 넣어야합니다.\n\nref: https://docs.aws.amazon.com/ko_kr/amazondynamodb/latest/developerguide/GettingStarted.NodeJs.html\n\n\n## Node.js에서 예외처리하기\n\n```js\nprocess.on(\"uncaughtException\", error => {\n  console.log(\"Oh my god, something terrible happend: \", error);\n  process.exit(1); // exit application\n});\n```\n\n```js\nprocess.on(\"unhandledRejection\", (error, promise) => {\n  console.log(\n    \" Oh Lord! We forgot to handle a promise rejection here: \",\n    promise\n  );\n  console.log(\" The error was: \", error);\n});\n```\n\n---\n\nreference\n\nhttps://softwareontheroad.com/nodejs-crash-exception-handler/\n\n\n# node에서 간편하게 letsencrypt를 사용하여 https 구현하는 방법\n\n먼저 인증서를 생성합니다.\n\n인증서를 생성하기위해서는 먼저 도메인이 필요한데, 해당 과정은 여기서는 생략합니다.\n\n[ubuntu에서 letsencrypt 인증서발급방법](/server-side/letsencrypt/)\n\ngreenlock 라이브러리를 사용합니다.\n\n설명은 express기준으로 작성하였습니다만\n\nexpress외에 koa, hapi 등의 모듈도 준비되어있습니다.\n\n```bash\nnpm i greenlock-express\n```\n\napp.js에서,\n\n```javascript\nmodule.exports = app;\n```\n\n위의 코드 바로 전 라인에 아래 코드를 추가하면 된다.\n\n```javascript\nrequire(\"greenlock-express\")\n  .create({\n    version: \"draft-11\",\n    configDir: \"/etc/letsencrypt/\",\n    server: \"https://acme-v02.api.letsencrypt.org/directory\",\n    email: \"이메일\",\n    agreeTos: true,\n    approvedDomains: [\"도메인\"],\n    app,\n    renewWithin: 81 * 24 * 60 * 60 * 1000,\n    renewBy: 80 * 24 * 60 * 60 * 1000\n  })\n  .listen(80, 443);\n```\n\nreference: https://git.coolaj86.com/coolaj86/greenlock-express.js\n\n또 다른방법은 nginx로 reverse proxy를 구현하고, ssl을 붙이는 방법이 있긴하다. 그런데 위에 방법이 더 간편함..\n\n하지만 어플리케이션의 구조가 커질수록 불리한 점이 많다.\n\n## npm install\n\nnpm install은 package.json에 작성해놓은 dependency를 모두 설치하는 명령어이다.\n\n기존에는 -S 옵션을 붙여야 dependencies에 설치가 되었지만, npm v5 이후로는 기본값이 되었다.\n\n---\n\n서버환경에서 npm install 했을때, permission 관련 에러가 났을때 임시 해결방법\n\n```bash\nsudo npm install --unsafe-perm=true --allow-root\n```\n\n```bash\nsudo npm install ${name} --unsafe-perm=true --allow-root\n```","src/content/docs/server-side/node_js.mdx","d4e1f6efce8f574e"]